{"version":3,"file":"index.DqDvP8To.js","sources":["../../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../node_modules/@floating-ui/vue/dist/floating-ui.vue.mjs","../../node_modules/radix-vue/dist/index.js"],"sourcesContent":["/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle as getComputedStyle$1, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Safety check: ensure the scrollbar space is reasonable in case this\n// calculation is affected by unusual styles.\n// Most scrollbars leave 15-18px of space.\nconst SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\n  // visual width of the <html> but this is not considered in the size\n  // of `html.clientWidth`.\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    // If the <body> scrollbar is on the left, the width needs to be extended\n    // by the scrollbar amount so there isn't extra space on the right.\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { isNode, getNodeName } from '@floating-ui/utils/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction isComponentPublicInstance(target) {\n  return target != null && typeof target === 'object' && '$el' in target;\n}\nfunction unwrapElement(target) {\n  if (isComponentPublicInstance(target)) {\n    const element = target.$el;\n    return isNode(element) && getNodeName(element) === '#comment' ? null : element;\n  }\n  return target;\n}\n\nfunction toValue(source) {\n  return typeof source === 'function' ? source() : unref(source);\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(toValue(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _toValue;\n    return (_toValue = toValue(options.open)) != null ? _toValue : true;\n  });\n  const middlewareOption = computed(() => toValue(options.middleware));\n  const placementOption = computed(() => {\n    var _toValue2;\n    return (_toValue2 = toValue(options.placement)) != null ? _toValue2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _toValue3;\n    return (_toValue3 = toValue(options.strategy)) != null ? _toValue3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _toValue4;\n    return (_toValue4 = toValue(options.transform)) != null ? _toValue4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    const open = openOption.value;\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      /**\n       * The floating element's position may be recomputed while it's closed\n       * but still mounted (such as when transitioning out). To ensure\n       * `isPositioned` will be `false` initially on the next open, avoid\n       * setting it to `true` when `open === false` (must be specified).\n       */\n      isPositioned.value = open !== false;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption, openOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","import * as No from \"vue\";\nimport { inject as ul, provide as dl, shallowRef as Fn, watchEffect as Ce, readonly as Wa, customRef as cl, ref as T, computed as B, watch as ee, nextTick as oe, getCurrentScope as gr, onScopeDispose as fl, effectScope as pl, unref as o, onBeforeUnmount as Nn, onMounted as le, isRef as et, reactive as Fa, getCurrentInstance as gt, onUpdated as vl, Fragment as _e, defineComponent as x, toRefs as ae, renderSlot as w, onBeforeUpdate as br, toHandlerKey as Cr, camelize as ml, toRef as wr, onUnmounted as Be, mergeProps as k, h as mt, Comment as hl, cloneVNode as Ln, openBlock as b, createBlock as S, withCtx as y, createVNode as q, createCommentVNode as ce, withKeys as ie, Teleport as qt, normalizeProps as W, guardReactiveProps as U, normalizeStyle as Me, withModifiers as ue, createElementBlock as ve, withDirectives as ja, vShow as zn, createElementVNode as Ye, toDisplayString as De, createTextVNode as ye, mergeDefaults as yl, watchPostEffect as _r, renderList as ma, markRaw as xr, watchSyncEffect as Sr, resolveDynamicComponent as Xe, toHandlers as Kn, triggerRef as Lo, useSlots as Ua, onBeforeMount as gl, vModelSelect as Er, toRaw as Pr } from \"vue\";\nimport { DateFormatter as lt, createCalendar as Dr, toCalendar as zo, CalendarDateTime as $r, CalendarDate as Br, today as Ir, getLocalTimeZone as Hn, isEqualMonth as Ko, isSameDay as Oe, isEqualDay as ke, isToday as bl, isSameMonth as Cl } from \"@internationalized/date\";\nimport { k as ia, t as ze, j as wl, d as Pt, n as Pa, m as Ke, l as Ze, o as Tr, x as _l, u as Rr, r as Ar } from \"./calendar-ChFCRr4K.js\";\nimport { useFloating as Or, autoUpdate as kr, offset as Mr, flip as Ho, shift as Vr, limitShift as Fr, size as Nr, arrow as Lr, hide as zr } from \"@floating-ui/vue\";\nimport { NumberFormatter as Kr, NumberParser as Hr } from \"@internationalized/number\";\nfunction te(a, t) {\n  const e = typeof a == \"string\" && !t ? `${a}Context` : t, n = Symbol(e);\n  return [(r) => {\n    const i = ul(n, r);\n    if (i || i === null)\n      return i;\n    throw new Error(\n      `Injection \\`${n.toString()}\\` not found. Component must be used within ${Array.isArray(a) ? `one of the following components: ${a.join(\n        \", \"\n      )}` : `\\`${a}\\``}`\n    );\n  }, (r) => (dl(n, r), r)];\n}\nfunction jt(a, t, e) {\n  const n = e.originalEvent.target, l = new CustomEvent(a, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);\n}\nfunction Ut(a, t = Number.NEGATIVE_INFINITY, e = Number.POSITIVE_INFINITY) {\n  return Math.min(e, Math.max(t, a));\n}\nfunction Da(a, t) {\n  let e = a;\n  const n = t.toString(), l = n.indexOf(\".\"), s = l >= 0 ? n.length - l : 0;\n  if (s > 0) {\n    const r = 10 ** s;\n    e = Math.round(e * r) / r;\n  }\n  return e;\n}\nfunction Wr(a, t, e, n) {\n  t = Number(t), e = Number(e);\n  const l = (a - (Number.isNaN(t) ? 0 : t)) % n;\n  let s = Da(Math.abs(l) * 2 >= n ? a + Math.sign(l) * (n - Math.abs(l)) : a - l, n);\n  return Number.isNaN(t) ? !Number.isNaN(e) && s > e && (s = Math.floor(Da(e / n, n)) * n) : s < t ? s = t : !Number.isNaN(e) && s > e && (s = t + Math.floor(Da((e - t) / n, n)) * n), s = Da(s, n), s;\n}\nfunction jr(a) {\n  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, \"default\") ? a.default : a;\n}\nvar Ur = function a(t, e) {\n  if (t === e) return !0;\n  if (t && e && typeof t == \"object\" && typeof e == \"object\") {\n    if (t.constructor !== e.constructor) return !1;\n    var n, l, s;\n    if (Array.isArray(t)) {\n      if (n = t.length, n != e.length) return !1;\n      for (l = n; l-- !== 0; )\n        if (!a(t[l], e[l])) return !1;\n      return !0;\n    }\n    if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;\n    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === e.valueOf();\n    if (t.toString !== Object.prototype.toString) return t.toString() === e.toString();\n    if (s = Object.keys(t), n = s.length, n !== Object.keys(e).length) return !1;\n    for (l = n; l-- !== 0; )\n      if (!Object.prototype.hasOwnProperty.call(e, s[l])) return !1;\n    for (l = n; l-- !== 0; ) {\n      var r = s[l];\n      if (!a(t[r], e[r])) return !1;\n    }\n    return !0;\n  }\n  return t !== t && e !== e;\n};\nconst Qe = /* @__PURE__ */ jr(Ur);\nfunction Gr(a, t) {\n  if (a.length !== t.length)\n    return !1;\n  for (let e = 0; e < a.length; e++)\n    if (a[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction Bt(a, t, e) {\n  const n = a.findIndex((i) => Qe(i, t)), l = a.findIndex((i) => Qe(i, e));\n  if (n === -1 || l === -1)\n    return [];\n  const [s, r] = [n, l].sort((i, u) => i - u);\n  return a.slice(s, r + 1);\n}\nconst ha = typeof document < \"u\";\nfunction ht(a) {\n  return a == null;\n}\nfunction Yt(a) {\n  const { defaultValue: t, defaultPlaceholder: e, granularity: n = \"day\", locale: l = \"en\" } = a;\n  if (Array.isArray(t) && t.length)\n    return t.at(-1).copy();\n  if (t && !Array.isArray(t))\n    return t.copy();\n  if (e)\n    return e.copy();\n  const s = /* @__PURE__ */ new Date(), r = s.getFullYear(), i = s.getMonth() + 1, u = s.getDate(), d = [\"hour\", \"minute\", \"second\"], c = new lt(l), f = Dr(c.resolvedOptions().calendar);\n  return d.includes(n ?? \"day\") ? zo(new $r(r, i, u, 0, 0, 0), f) : zo(new Br(r, i, u), f);\n}\nconst qr = [\n  \"ach\",\n  \"af\",\n  \"am\",\n  \"an\",\n  \"ar\",\n  \"ast\",\n  \"az\",\n  \"be\",\n  \"bg\",\n  \"bn\",\n  \"br\",\n  \"bs\",\n  \"ca\",\n  \"cak\",\n  \"ckb\",\n  \"cs\",\n  \"cy\",\n  \"da\",\n  \"de\",\n  \"dsb\",\n  \"el\",\n  \"en\",\n  \"eo\",\n  \"es\",\n  \"et\",\n  \"eu\",\n  \"fa\",\n  \"ff\",\n  \"fi\",\n  \"fr\",\n  \"fy\",\n  \"ga\",\n  \"gd\",\n  \"gl\",\n  \"he\",\n  \"hr\",\n  \"hsb\",\n  \"hu\",\n  \"ia\",\n  \"id\",\n  \"it\",\n  \"ja\",\n  \"ka\",\n  \"kk\",\n  \"kn\",\n  \"ko\",\n  \"lb\",\n  \"lo\",\n  \"lt\",\n  \"lv\",\n  \"meh\",\n  \"ml\",\n  \"ms\",\n  \"nl\",\n  \"nn\",\n  \"no\",\n  \"oc\",\n  \"pl\",\n  \"pt\",\n  \"rm\",\n  \"ro\",\n  \"ru\",\n  \"sc\",\n  \"scn\",\n  \"sk\",\n  \"sl\",\n  \"sr\",\n  \"sv\",\n  \"szl\",\n  \"tg\",\n  \"th\",\n  \"tr\",\n  \"uk\",\n  \"zh-CN\",\n  \"zh-TW\"\n], Yr = [\"year\", \"month\", \"day\"], gn = {\n  ach: { year: \"mwaka\", month: \"dwe\", day: \"nino\" },\n  af: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  am: { year: \"á‹“á‹“á‹“á‹“\", month: \"áˆšáˆœ\", day: \"á‰€á‰€\" },\n  an: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  ar: { year: \"Ø³Ù†Ø©\", month: \"Ø´Ù‡Ø±\", day: \"ÙŠÙˆÙ…\" },\n  ast: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  az: { year: \"iiii\", month: \"aa\", day: \"gg\" },\n  be: { year: \"Ð³Ð³Ð³Ð³\", month: \"Ð¼Ð¼\", day: \"Ð´Ð´\" },\n  bg: { year: \"Ð³Ð³Ð³Ð³\", month: \"Ð¼Ð¼\", day: \"Ð´Ð´\" },\n  bn: { year: \"yyyy\", month: \"à¦®à¦¿à¦®à¦¿\", day: \"dd\" },\n  br: { year: \"bbbb\", month: \"mm\", day: \"dd\" },\n  bs: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  ca: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  cak: { year: \"jjjj\", month: \"ii\", day: \"q'q'\" },\n  ckb: { year: \"Ø³Ø§Úµ\", month: \"Ù…Ø§Ù†Ú¯\", day: \"Ú•Û†Ú˜\" },\n  cs: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  cy: { year: \"bbbb\", month: \"mm\", day: \"dd\" },\n  da: { year: \"Ã¥Ã¥Ã¥Ã¥\", month: \"mm\", day: \"dd\" },\n  de: { year: \"jjjj\", month: \"mm\", day: \"tt\" },\n  dsb: { year: \"llll\", month: \"mm\", day: \"ÅºÅº\" },\n  el: { year: \"ÎµÎµÎµÎµ\", month: \"Î¼Î¼\", day: \"Î·Î·\" },\n  en: { year: \"yyyy\", month: \"mm\", day: \"dd\" },\n  eo: { year: \"jjjj\", month: \"mm\", day: \"tt\" },\n  es: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  et: { year: \"aaaa\", month: \"kk\", day: \"pp\" },\n  eu: { year: \"uuuu\", month: \"hh\", day: \"ee\" },\n  fa: { year: \"Ø³Ø§Ù„\", month: \"Ù…Ø§Ù‡\", day: \"Ø±ÙˆØ²\" },\n  ff: { year: \"hhhh\", month: \"ll\", day: \"Ã±Ã±\" },\n  fi: { year: \"vvvv\", month: \"kk\", day: \"pp\" },\n  fr: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  fy: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  ga: { year: \"bbbb\", month: \"mm\", day: \"ll\" },\n  gd: { year: \"bbbb\", month: \"mm\", day: \"ll\" },\n  gl: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  he: { year: \"×©× ×”\", month: \"×—×•×“×©\", day: \"×™×•×\" },\n  hr: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  hsb: { year: \"llll\", month: \"mm\", day: \"dd\" },\n  hu: { year: \"Ã©Ã©Ã©Ã©\", month: \"hh\", day: \"nn\" },\n  ia: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  id: { year: \"tttt\", month: \"bb\", day: \"hh\" },\n  it: { year: \"aaaa\", month: \"mm\", day: \"gg\" },\n  ja: { year: \" å¹´ \", month: \"æœˆ\", day: \"æ—¥\" },\n  ka: { year: \"áƒ¬áƒ¬áƒ¬áƒ¬\", month: \"áƒ—áƒ—\", day: \"áƒ áƒ \" },\n  kk: { year: \"Ð¶Ð¶Ð¶Ð¶\", month: \"Ð°Ð°\", day: \"ÐºÐº\" },\n  kn: { year: \"à²µà²µà²µà²µ\", month: \"à²®à²¿à²®à³€\", day: \"à²¦à²¿à²¦à²¿\" },\n  ko: { year: \"ì—°ë„\", month: \"ì›”\", day: \"ì¼\" },\n  lb: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  lo: { year: \"àº›àº›àº›àº›\", month: \"àº”àº”\", day: \"àº§àº§\" },\n  lt: { year: \"mmmm\", month: \"mm\", day: \"dd\" },\n  lv: { year: \"gggg\", month: \"mm\", day: \"dd\" },\n  meh: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  ml: { year: \"à´µàµ¼à´·à´‚\", month: \"à´®à´¾à´¸à´‚\", day: \"à´¤àµ€à´¯à´¤à´¿\" },\n  ms: { year: \"tttt\", month: \"mm\", day: \"hh\" },\n  nl: { year: \"jjjj\", month: \"mm\", day: \"dd\" },\n  nn: { year: \"Ã¥Ã¥Ã¥Ã¥\", month: \"mm\", day: \"dd\" },\n  no: { year: \"Ã¥Ã¥Ã¥Ã¥\", month: \"mm\", day: \"dd\" },\n  oc: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  pl: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  pt: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  rm: { year: \"oooo\", month: \"mm\", day: \"dd\" },\n  ro: { year: \"aaaa\", month: \"ll\", day: \"zz\" },\n  ru: { year: \"Ð³Ð³Ð³Ð³\", month: \"Ð¼Ð¼\", day: \"Ð´Ð´\" },\n  sc: { year: \"aaaa\", month: \"mm\", day: \"dd\" },\n  scn: { year: \"aaaa\", month: \"mm\", day: \"jj\" },\n  sk: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  sl: { year: \"llll\", month: \"mm\", day: \"dd\" },\n  sr: { year: \"Ð³Ð³Ð³Ð³\", month: \"Ð¼Ð¼\", day: \"Ð´Ð´\" },\n  sv: { year: \"Ã¥Ã¥Ã¥Ã¥\", month: \"mm\", day: \"dd\" },\n  szl: { year: \"rrrr\", month: \"mm\", day: \"dd\" },\n  tg: { year: \"ÑÑÑÑ\", month: \"Ð¼Ð¼\", day: \"Ñ€Ñ€\" },\n  th: { year: \"à¸›à¸›à¸›à¸›\", month: \"à¸”à¸”\", day: \"à¸§à¸§\" },\n  tr: { year: \"yyyy\", month: \"aa\", day: \"gg\" },\n  uk: { year: \"Ñ€Ñ€Ñ€Ñ€\", month: \"Ð¼Ð¼\", day: \"Ð´Ð´\" },\n  \"zh-CN\": { year: \"å¹´\", month: \"æœˆ\", day: \"æ—¥\" },\n  \"zh-TW\": { year: \"å¹´\", month: \"æœˆ\", day: \"æ—¥\" }\n};\nfunction Xr(a) {\n  if (Wo(a))\n    return gn[a];\n  {\n    const t = ei(a);\n    return Wo(t) ? gn[t] : gn.en;\n  }\n}\nfunction bn(a, t, e) {\n  return Zr(a) ? Xr(e)[a] : Qr(a) ? t : Jr(a) ? \"â€“â€“\" : \"\";\n}\nfunction Wo(a) {\n  return qr.includes(a);\n}\nfunction Zr(a) {\n  return Yr.includes(a);\n}\nfunction Jr(a) {\n  return a === \"hour\" || a === \"minute\" || a === \"second\";\n}\nfunction Qr(a) {\n  return a === \"era\" || a === \"dayPeriod\";\n}\nfunction ei(a) {\n  return Intl.Locale ? new Intl.Locale(a).language : a.split(\"-\")[0];\n}\nconst Wn = [\"day\", \"month\", \"year\"], xl = [\"hour\", \"minute\", \"second\", \"dayPeriod\"], Sl = [...Wn, ...xl];\nfunction ti(a) {\n  return Wn.includes(a);\n}\nfunction El(a) {\n  return Sl.includes(a);\n}\nfunction ai(a, t) {\n  const e = {\n    year: \"numeric\",\n    month: \"2-digit\",\n    day: \"2-digit\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    timeZoneName: \"short\",\n    hourCycle: t === 24 ? \"h24\" : void 0,\n    hour12: t === 24 ? !1 : void 0\n  };\n  return a === \"day\" && (delete e.second, delete e.hour, delete e.minute, delete e.timeZoneName), a === \"hour\" && (delete e.minute, delete e.second), a === \"minute\" && delete e.second, e;\n}\nfunction Pl(a) {\n  const t = a.querySelector(\"[data-selected]\");\n  if (t)\n    return t.focus();\n  const e = a.querySelector(\"[data-today]\");\n  if (e)\n    return e.focus();\n  const n = a.querySelector(\"[data-radix-vue-calendar-day]\");\n  if (n)\n    return n.focus();\n}\nfunction ni(a, t) {\n  var e;\n  const n = Fn();\n  return Ce(() => {\n    n.value = a();\n  }, {\n    ...t,\n    flush: (e = void 0) != null ? e : \"sync\"\n  }), Wa(n);\n}\nfunction oi(a, t) {\n  let e, n, l;\n  const s = T(!0), r = () => {\n    s.value = !0, l();\n  };\n  ee(a, r, { flush: \"sync\" });\n  const i = typeof t == \"function\" ? t : t.get, u = typeof t == \"function\" ? void 0 : t.set, d = cl((c, f) => (n = c, l = f, {\n    get() {\n      return s.value && (e = i(), s.value = !1), n(), e;\n    },\n    set(v) {\n      u == null || u(v);\n    }\n  }));\n  return Object.isExtensible(d) && (d.trigger = r), d;\n}\nfunction bt(a) {\n  return gr() ? (fl(a), !0) : !1;\n}\nfunction ua() {\n  const a = /* @__PURE__ */ new Set(), t = (l) => {\n    a.delete(l);\n  };\n  return {\n    on: (l) => {\n      a.add(l);\n      const s = () => t(l);\n      return bt(s), {\n        off: s\n      };\n    },\n    off: t,\n    trigger: (...l) => Promise.all(Array.from(a).map((s) => s(...l)))\n  };\n}\nfunction li(a) {\n  let t = !1, e;\n  const n = pl(!0);\n  return (...l) => (t || (e = n.run(() => a(...l)), t = !0), e);\n}\nfunction Dl(a) {\n  let t = 0, e, n;\n  const l = () => {\n    t -= 1, n && t <= 0 && (n.stop(), e = void 0, n = void 0);\n  };\n  return (...s) => (t += 1, e || (n = pl(!0), e = n.run(() => a(...s))), bt(l), e);\n}\nfunction je(a) {\n  return typeof a == \"function\" ? a() : o(a);\n}\nfunction si(a) {\n  if (!et(a))\n    return Fa(a);\n  const t = new Proxy({}, {\n    get(e, n, l) {\n      return o(Reflect.get(a.value, n, l));\n    },\n    set(e, n, l) {\n      return et(a.value[n]) && !et(l) ? a.value[n].value = l : a.value[n] = l, !0;\n    },\n    deleteProperty(e, n) {\n      return Reflect.deleteProperty(a.value, n);\n    },\n    has(e, n) {\n      return Reflect.has(a.value, n);\n    },\n    ownKeys() {\n      return Object.keys(a.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: !0,\n        configurable: !0\n      };\n    }\n  });\n  return Fa(t);\n}\nfunction $l(a) {\n  return si(B(a));\n}\nconst Je = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst ri = (a) => typeof a < \"u\", ii = (a) => a != null, ui = Object.prototype.toString, di = (a) => ui.call(a) === \"[object Object]\", Na = () => {\n}, jo = /* @__PURE__ */ ci();\nfunction ci() {\n  var a, t;\n  return Je && ((a = window == null ? void 0 : window.navigator) == null ? void 0 : a.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent));\n}\nfunction Bl(a, t) {\n  function e(...n) {\n    return new Promise((l, s) => {\n      Promise.resolve(a(() => t.apply(this, n), { fn: t, thisArg: this, args: n })).then(l).catch(s);\n    });\n  }\n  return e;\n}\nconst Il = (a) => a();\nfunction fi(a, t = {}) {\n  let e, n, l = Na;\n  const s = (i) => {\n    clearTimeout(i), l(), l = Na;\n  };\n  return (i) => {\n    const u = je(a), d = je(t.maxWait);\n    return e && s(e), u <= 0 || d !== void 0 && d <= 0 ? (n && (s(n), n = null), Promise.resolve(i())) : new Promise((c, f) => {\n      l = t.rejectOnCancel ? f : c, d && !n && (n = setTimeout(() => {\n        e && s(e), n = null, c(i());\n      }, d)), e = setTimeout(() => {\n        n && s(n), n = null, c(i());\n      }, u);\n    });\n  };\n}\nfunction pi(a = Il) {\n  const t = T(!0);\n  function e() {\n    t.value = !1;\n  }\n  function n() {\n    t.value = !0;\n  }\n  const l = (...s) => {\n    t.value && a(...s);\n  };\n  return { isActive: Wa(t), pause: e, resume: n, eventFilter: l };\n}\nfunction Tl(a) {\n  return gt();\n}\nfunction Tt(a, t = 1e4) {\n  return cl((e, n) => {\n    let l = je(a), s;\n    const r = () => setTimeout(() => {\n      l = je(a), n();\n    }, je(t));\n    return bt(() => {\n      clearTimeout(s);\n    }), {\n      get() {\n        return e(), l;\n      },\n      set(i) {\n        l = i, n(), clearTimeout(s), s = r();\n      }\n    };\n  });\n}\nfunction jn(a, t = 200, e = {}) {\n  return Bl(\n    fi(t, e),\n    a\n  );\n}\nfunction vi(a, t, e = {}) {\n  const {\n    eventFilter: n = Il,\n    ...l\n  } = e;\n  return ee(\n    a,\n    Bl(\n      n,\n      t\n    ),\n    l\n  );\n}\nfunction Uo(a, t, e = {}) {\n  const {\n    eventFilter: n,\n    ...l\n  } = e, { eventFilter: s, pause: r, resume: i, isActive: u } = pi(n);\n  return { stop: vi(\n    a,\n    t,\n    {\n      ...l,\n      eventFilter: s\n    }\n  ), pause: r, resume: i, isActive: u };\n}\nfunction mi(a, t, ...[e]) {\n  const {\n    flush: n = \"sync\",\n    deep: l = !1,\n    immediate: s = !0,\n    direction: r = \"both\",\n    transform: i = {}\n  } = e || {}, u = [], d = \"ltr\" in i && i.ltr || ((v) => v), c = \"rtl\" in i && i.rtl || ((v) => v);\n  return (r === \"both\" || r === \"ltr\") && u.push(Uo(\n    a,\n    (v) => {\n      u.forEach((p) => p.pause()), t.value = d(v), u.forEach((p) => p.resume());\n    },\n    { flush: n, deep: l, immediate: s }\n  )), (r === \"both\" || r === \"rtl\") && u.push(Uo(\n    t,\n    (v) => {\n      u.forEach((p) => p.pause()), a.value = c(v), u.forEach((p) => p.resume());\n    },\n    { flush: n, deep: l, immediate: s }\n  )), () => {\n    u.forEach((v) => v.stop());\n  };\n}\nfunction hi(a, t) {\n  Tl() && Nn(a, t);\n}\nfunction yi(a, t = !0, e) {\n  Tl() ? le(a, e) : t ? a() : oe(a);\n}\nfunction Un(a, t, e = {}) {\n  const {\n    immediate: n = !0\n  } = e, l = T(!1);\n  let s = null;\n  function r() {\n    s && (clearTimeout(s), s = null);\n  }\n  function i() {\n    l.value = !1, r();\n  }\n  function u(...d) {\n    r(), l.value = !0, s = setTimeout(() => {\n      l.value = !1, s = null, a(...d);\n    }, je(t));\n  }\n  return n && (l.value = !0, Je && u()), bt(i), {\n    isPending: Wa(l),\n    start: u,\n    stop: i\n  };\n}\nfunction gi(a = 1e3, t = {}) {\n  const {\n    controls: e = !1,\n    callback: n\n  } = t, l = Un(\n    n ?? Na,\n    a,\n    t\n  ), s = B(() => !l.isPending.value);\n  return e ? {\n    ready: s,\n    ...l\n  } : s;\n}\nfunction bi(a, t, e) {\n  const n = ee(a, (...l) => (oe(() => n()), t(...l)), e);\n  return n;\n}\nfunction $e(a) {\n  var t;\n  const e = je(a);\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nconst Rt = Je ? window : void 0;\nfunction He(...a) {\n  let t, e, n, l;\n  if (typeof a[0] == \"string\" || Array.isArray(a[0]) ? ([e, n, l] = a, t = Rt) : [t, e, n, l] = a, !t)\n    return Na;\n  Array.isArray(e) || (e = [e]), Array.isArray(n) || (n = [n]);\n  const s = [], r = () => {\n    s.forEach((c) => c()), s.length = 0;\n  }, i = (c, f, v, p) => (c.addEventListener(f, v, p), () => c.removeEventListener(f, v, p)), u = ee(\n    () => [$e(t), je(l)],\n    ([c, f]) => {\n      if (r(), !c)\n        return;\n      const v = di(f) ? { ...f } : f;\n      s.push(\n        ...e.flatMap((p) => n.map((g) => i(c, p, g, v)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), d = () => {\n    u(), r();\n  };\n  return bt(d), d;\n}\nfunction Ci(a) {\n  return typeof a == \"function\" ? a : typeof a == \"string\" ? (t) => t.key === a : Array.isArray(a) ? (t) => a.includes(t.key) : () => !0;\n}\nfunction Gn(...a) {\n  let t, e, n = {};\n  a.length === 3 ? (t = a[0], e = a[1], n = a[2]) : a.length === 2 ? typeof a[1] == \"object\" ? (t = !0, e = a[0], n = a[1]) : (t = a[0], e = a[1]) : (t = !0, e = a[0]);\n  const {\n    target: l = Rt,\n    eventName: s = \"keydown\",\n    passive: r = !1,\n    dedupe: i = !1\n  } = n, u = Ci(t);\n  return He(l, s, (c) => {\n    c.repeat && je(i) || u(c) && e(c);\n  }, r);\n}\nfunction Ga() {\n  const a = T(!1), t = gt();\n  return t && le(() => {\n    a.value = !0;\n  }, t), a;\n}\nfunction Rl(a) {\n  const t = Ga();\n  return B(() => (t.value, !!a()));\n}\nfunction Al(a, t, e = {}) {\n  const { window: n = Rt, ...l } = e;\n  let s;\n  const r = Rl(() => n && \"MutationObserver\" in n), i = () => {\n    s && (s.disconnect(), s = void 0);\n  }, u = B(() => {\n    const v = je(a), p = (Array.isArray(v) ? v : [v]).map($e).filter(ii);\n    return new Set(p);\n  }), d = ee(\n    () => u.value,\n    (v) => {\n      i(), r.value && v.size && (s = new MutationObserver(t), v.forEach((p) => s.observe(p, l)));\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => s == null ? void 0 : s.takeRecords(), f = () => {\n    i(), d();\n  };\n  return bt(f), {\n    isSupported: r,\n    stop: f,\n    takeRecords: c\n  };\n}\nfunction wi(a = {}) {\n  var t;\n  const {\n    window: e = Rt,\n    deep: n = !0,\n    triggerOnRemoval: l = !1\n  } = a, s = (t = a.document) != null ? t : e == null ? void 0 : e.document, r = () => {\n    var d;\n    let c = s == null ? void 0 : s.activeElement;\n    if (n)\n      for (; c != null && c.shadowRoot; )\n        c = (d = c == null ? void 0 : c.shadowRoot) == null ? void 0 : d.activeElement;\n    return c;\n  }, i = T(), u = () => {\n    i.value = r();\n  };\n  return e && (He(e, \"blur\", (d) => {\n    d.relatedTarget === null && u();\n  }, !0), He(e, \"focus\", u, !0)), l && Al(s, (d) => {\n    d.filter((c) => c.removedNodes.length).map((c) => Array.from(c.removedNodes)).flat().forEach((c) => {\n      c === i.value && u();\n    });\n  }, {\n    childList: !0,\n    subtree: !0\n  }), u(), i;\n}\nfunction Ol(a, t = {}) {\n  const {\n    immediate: e = !0,\n    fpsLimit: n = void 0,\n    window: l = Rt\n  } = t, s = T(!1), r = n ? 1e3 / n : null;\n  let i = 0, u = null;\n  function d(v) {\n    if (!s.value || !l)\n      return;\n    i || (i = v);\n    const p = v - i;\n    if (r && p < r) {\n      u = l.requestAnimationFrame(d);\n      return;\n    }\n    i = v, a({ delta: p, timestamp: v }), u = l.requestAnimationFrame(d);\n  }\n  function c() {\n    !s.value && l && (s.value = !0, i = 0, u = l.requestAnimationFrame(d));\n  }\n  function f() {\n    s.value = !1, u != null && l && (l.cancelAnimationFrame(u), u = null);\n  }\n  return e && c(), bt(f), {\n    isActive: Wa(s),\n    pause: f,\n    resume: c\n  };\n}\nfunction _i(a) {\n  return JSON.parse(JSON.stringify(a));\n}\nfunction xi(a) {\n  const t = gt(), e = oi(\n    () => null,\n    () => t.proxy.$el\n  );\n  return vl(e.trigger), le(e.trigger), e;\n}\nfunction tt(a, t, e = {}) {\n  const { window: n = Rt, ...l } = e;\n  let s;\n  const r = Rl(() => n && \"ResizeObserver\" in n), i = () => {\n    s && (s.disconnect(), s = void 0);\n  }, u = B(() => Array.isArray(a) ? a.map((f) => $e(f)) : [$e(a)]), d = ee(\n    u,\n    (f) => {\n      if (i(), r.value && n) {\n        s = new ResizeObserver(t);\n        for (const v of f)\n          v && s.observe(v, l);\n      }\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => {\n    i(), d();\n  };\n  return bt(c), {\n    isSupported: r,\n    stop: c\n  };\n}\nfunction Si(a, t = {}) {\n  const e = wi(t), n = B(() => $e(a));\n  return { focused: B(() => n.value && e.value ? n.value.contains(e.value) : !1) };\n}\nfunction kl(a = xi()) {\n  const t = Fn(), e = () => {\n    const n = $e(a);\n    n && (t.value = n.parentElement);\n  };\n  return yi(e), ee(() => je(a), e), t;\n}\nfunction ne(a, t, e, n = {}) {\n  var l, s, r;\n  const {\n    clone: i = !1,\n    passive: u = !1,\n    eventName: d,\n    deep: c = !1,\n    defaultValue: f,\n    shouldEmit: v\n  } = n, p = gt(), g = e || (p == null ? void 0 : p.emit) || ((l = p == null ? void 0 : p.$emit) == null ? void 0 : l.bind(p)) || ((r = (s = p == null ? void 0 : p.proxy) == null ? void 0 : s.$emit) == null ? void 0 : r.bind(p == null ? void 0 : p.proxy));\n  let m = d;\n  t || (t = \"modelValue\"), m = m || `update:${t.toString()}`;\n  const _ = (h) => i ? typeof i == \"function\" ? i(h) : _i(h) : h, C = () => ri(a[t]) ? _(a[t]) : f, $ = (h) => {\n    v ? v(h) && g(m, h) : g(m, h);\n  };\n  if (u) {\n    const h = C(), E = T(h);\n    let P = !1;\n    return ee(\n      () => a[t],\n      (D) => {\n        P || (P = !0, E.value = _(D), oe(() => P = !1));\n      }\n    ), ee(\n      E,\n      (D) => {\n        !P && (D !== a[t] || c) && $(D);\n      },\n      { deep: c }\n    ), E;\n  } else\n    return B({\n      get() {\n        return C();\n      },\n      set(h) {\n        $(h);\n      }\n    });\n}\nfunction qa(a) {\n  return a ? a.flatMap((t) => t.type === _e ? qa(t.children) : [t]) : [];\n}\nfunction me() {\n  let a = document.activeElement;\n  if (a == null)\n    return null;\n  for (; a != null && a.shadowRoot != null && a.shadowRoot.activeElement != null; )\n    a = a.shadowRoot.activeElement;\n  return a;\n}\nconst Ei = [\"INPUT\", \"TEXTAREA\"];\nfunction At(a, t, e, n = {}) {\n  if (!t || n.enableIgnoredElement && Ei.includes(t.nodeName))\n    return null;\n  const {\n    arrowKeyOptions: l = \"both\",\n    attributeName: s = \"[data-radix-vue-collection-item]\",\n    itemsArray: r = [],\n    loop: i = !0,\n    dir: u = \"ltr\",\n    preventScroll: d = !0,\n    focus: c = !1\n  } = n, [f, v, p, g, m, _] = [\n    a.key === \"ArrowRight\",\n    a.key === \"ArrowLeft\",\n    a.key === \"ArrowUp\",\n    a.key === \"ArrowDown\",\n    a.key === \"Home\",\n    a.key === \"End\"\n  ], C = p || g, $ = f || v;\n  if (!m && !_ && (!C && !$ || l === \"vertical\" && $ || l === \"horizontal\" && C))\n    return null;\n  const h = e ? Array.from(e.querySelectorAll(s)) : r;\n  if (!h.length)\n    return null;\n  d && a.preventDefault();\n  let E = null;\n  return $ || C ? E = Ml(h, t, {\n    goForward: C ? g : u === \"ltr\" ? f : v,\n    loop: i\n  }) : m ? E = h.at(0) || null : _ && (E = h.at(-1) || null), c && (E == null || E.focus()), E;\n}\nfunction Ml(a, t, e, n = a.length) {\n  if (--n === 0)\n    return null;\n  const l = a.indexOf(t), s = e.goForward ? l + 1 : l - 1;\n  if (!e.loop && (s < 0 || s >= a.length))\n    return null;\n  const r = (s + a.length) % a.length, i = a[r];\n  return i ? i.hasAttribute(\"disabled\") && i.getAttribute(\"disabled\") !== \"false\" ? Ml(\n    a,\n    i,\n    e,\n    n\n  ) : i : null;\n}\nfunction Cn(a) {\n  if (a === null || typeof a != \"object\")\n    return !1;\n  const t = Object.getPrototypeOf(a);\n  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in a ? !1 : Symbol.toStringTag in a ? Object.prototype.toString.call(a) === \"[object Module]\" : !0;\n}\nfunction $n(a, t, e = \".\", n) {\n  if (!Cn(t))\n    return $n(a, {}, e, n);\n  const l = Object.assign({}, t);\n  for (const s in a) {\n    if (s === \"__proto__\" || s === \"constructor\")\n      continue;\n    const r = a[s];\n    r != null && (n && n(l, s, r, e) || (Array.isArray(r) && Array.isArray(l[s]) ? l[s] = [...r, ...l[s]] : Cn(r) && Cn(l[s]) ? l[s] = $n(\n      r,\n      l[s],\n      (e ? `${e}.` : \"\") + s.toString(),\n      n\n    ) : l[s] = r));\n  }\n  return l;\n}\nfunction Pi(a) {\n  return (...t) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    t.reduce((e, n) => $n(e, n, \"\", a), {})\n  );\n}\nconst Di = Pi(), [Ya, $i] = te(\"ConfigProvider\"), xv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ConfigProvider\",\n  props: {\n    dir: { default: \"ltr\" },\n    scrollBody: { type: [Boolean, Object], default: !0 },\n    nonce: { default: void 0 },\n    useId: { type: Function, default: void 0 }\n  },\n  setup(a) {\n    const t = a, { dir: e, scrollBody: n, nonce: l } = ae(t);\n    return $i({\n      dir: e,\n      scrollBody: n,\n      nonce: l,\n      useId: t.useId\n    }), (s, r) => w(s.$slots, \"default\");\n  }\n});\nlet Bi = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\", Ii = (a = 21) => {\n  let t = \"\", e = a;\n  for (; e--; )\n    t += Bi[Math.random() * 64 | 0];\n  return t;\n};\nconst Ti = Dl(() => {\n  const a = T(/* @__PURE__ */ new Map()), t = T(), e = B(() => {\n    for (const r of a.value.values())\n      if (r)\n        return !0;\n    return !1;\n  }), n = Ya({\n    scrollBody: T(!0)\n  });\n  let l = null;\n  const s = () => {\n    document.body.style.paddingRight = \"\", document.body.style.marginRight = \"\", document.body.style.pointerEvents = \"\", document.body.style.removeProperty(\"--scrollbar-width\"), document.body.style.overflow = t.value ?? \"\", jo && (l == null || l()), t.value = void 0;\n  };\n  return ee(e, (r, i) => {\n    var f;\n    if (!Je)\n      return;\n    if (!r) {\n      i && s();\n      return;\n    }\n    t.value === void 0 && (t.value = document.body.style.overflow);\n    const u = window.innerWidth - document.documentElement.clientWidth, d = { padding: u, margin: 0 }, c = (f = n.scrollBody) != null && f.value ? typeof n.scrollBody.value == \"object\" ? Di({\n      padding: n.scrollBody.value.padding === !0 ? u : n.scrollBody.value.padding,\n      margin: n.scrollBody.value.margin === !0 ? u : n.scrollBody.value.margin\n    }, d) : d : { padding: 0, margin: 0 };\n    u > 0 && (document.body.style.paddingRight = typeof c.padding == \"number\" ? `${c.padding}px` : String(c.padding), document.body.style.marginRight = typeof c.margin == \"number\" ? `${c.margin}px` : String(c.margin), document.body.style.setProperty(\"--scrollbar-width\", `${u}px`), document.body.style.overflow = \"hidden\"), jo && (l = He(\n      document,\n      \"touchmove\",\n      (v) => Ri(v),\n      { passive: !1 }\n    )), oe(() => {\n      document.body.style.pointerEvents = \"none\", document.body.style.overflow = \"hidden\";\n    });\n  }, { immediate: !0, flush: \"sync\" }), a;\n});\nfunction ya(a) {\n  const t = Ii(6), e = Ti();\n  e.value.set(t, a ?? !1);\n  const n = B({\n    get: () => e.value.get(t) ?? !1,\n    set: (l) => e.value.set(t, l)\n  });\n  return hi(() => {\n    e.value.delete(t);\n  }), n;\n}\nfunction Vl(a) {\n  const t = window.getComputedStyle(a);\n  if (t.overflowX === \"scroll\" || t.overflowY === \"scroll\" || t.overflowX === \"auto\" && a.clientWidth < a.scrollWidth || t.overflowY === \"auto\" && a.clientHeight < a.scrollHeight)\n    return !0;\n  {\n    const e = a.parentNode;\n    return !(e instanceof Element) || e.tagName === \"BODY\" ? !1 : Vl(e);\n  }\n}\nfunction Ri(a) {\n  const t = a || window.event, e = t.target;\n  return e instanceof Element && Vl(e) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);\n}\nconst Ai = \"data-radix-vue-collection-item\";\nfunction Fe(a, t = Ai) {\n  const e = a ?? Symbol();\n  return { createCollection: (s) => {\n    const r = T([]);\n    function i() {\n      const u = $e(s);\n      return u ? r.value = Array.from(\n        u.querySelectorAll(`[${t}]:not([data-disabled])`)\n      ) : r.value = [];\n    }\n    return br(() => {\n      r.value = [];\n    }), le(i), vl(i), ee(() => s == null ? void 0 : s.value, i, { immediate: !0 }), dl(e, r), r;\n  }, injectCollection: () => ul(e, T([])) };\n}\nfunction qn(a) {\n  const t = T(a);\n  function e() {\n    return t.value;\n  }\n  function n(m) {\n    t.value = m;\n  }\n  function l(m, _) {\n    return new lt(t.value, _).format(m);\n  }\n  function s(m, _ = !0) {\n    return ia(m) && _ ? l(ze(m), {\n      dateStyle: \"long\",\n      timeStyle: \"long\"\n    }) : l(ze(m), {\n      dateStyle: \"long\"\n    });\n  }\n  function r(m, _ = {}) {\n    return new lt(t.value, { month: \"long\", year: \"numeric\", ..._ }).format(m);\n  }\n  function i(m, _ = {}) {\n    return new lt(t.value, { month: \"long\", ..._ }).format(m);\n  }\n  function u() {\n    const m = Ir(Hn());\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((C) => ({ label: i(ze(m.set({ month: C }))), value: C }));\n  }\n  function d(m, _ = {}) {\n    return new lt(t.value, { year: \"numeric\", ..._ }).format(m);\n  }\n  function c(m, _) {\n    return wl(m) ? new lt(t.value, {\n      ..._,\n      timeZone: m.timeZone\n    }).formatToParts(ze(m)) : new lt(t.value, _).formatToParts(ze(m));\n  }\n  function f(m, _ = \"narrow\") {\n    return new lt(t.value, { weekday: _ }).format(m);\n  }\n  function v(m) {\n    var $;\n    return (($ = new lt(t.value, {\n      hour: \"numeric\",\n      minute: \"numeric\"\n    }).formatToParts(m).find((h) => h.type === \"dayPeriod\")) == null ? void 0 : $.value) === \"PM\" ? \"PM\" : \"AM\";\n  }\n  const p = {\n    year: \"numeric\",\n    month: \"numeric\",\n    day: \"numeric\",\n    hour: \"numeric\",\n    minute: \"numeric\",\n    second: \"numeric\"\n  };\n  function g(m, _, C = {}) {\n    const $ = { ...p, ...C }, E = c(m, $).find((P) => P.type === _);\n    return E ? E.value : \"\";\n  }\n  return {\n    setLocale: n,\n    getLocale: e,\n    fullMonth: i,\n    fullYear: d,\n    fullMonthAndYear: r,\n    toParts: c,\n    custom: l,\n    part: g,\n    dayPeriod: v,\n    selectedDate: s,\n    dayOfWeek: f,\n    getMonths: u\n  };\n}\nfunction we(a) {\n  const t = Ya({\n    dir: T(\"ltr\")\n  });\n  return B(() => {\n    var e;\n    return (a == null ? void 0 : a.value) || ((e = t.dir) == null ? void 0 : e.value) || \"ltr\";\n  });\n}\nfunction Te(a) {\n  const t = gt(), e = t == null ? void 0 : t.type.emits, n = {};\n  return e != null && e.length || console.warn(\n    `No emitted event found. Please check component: ${t == null ? void 0 : t.type.__name}`\n  ), e == null || e.forEach((l) => {\n    n[Cr(ml(l))] = (...s) => a(l, ...s);\n  }), n;\n}\nlet wn = 0;\nfunction Yn() {\n  Ce((a) => {\n    if (!Je)\n      return;\n    const t = document.querySelectorAll(\"[data-radix-focus-guard]\");\n    document.body.insertAdjacentElement(\n      \"afterbegin\",\n      t[0] ?? Go()\n    ), document.body.insertAdjacentElement(\n      \"beforeend\",\n      t[1] ?? Go()\n    ), wn++, a(() => {\n      wn === 1 && document.querySelectorAll(\"[data-radix-focus-guard]\").forEach((e) => e.remove()), wn--;\n    });\n  });\n}\nfunction Go() {\n  const a = document.createElement(\"span\");\n  return a.setAttribute(\"data-radix-focus-guard\", \"\"), a.tabIndex = 0, a.style.outline = \"none\", a.style.opacity = \"0\", a.style.position = \"fixed\", a.style.pointerEvents = \"none\", a;\n}\nfunction at(a) {\n  return B(() => {\n    var t;\n    return je(a) ? !!((t = $e(a)) != null && t.closest(\"form\")) : !0;\n  });\n}\nfunction Ot(a) {\n  const t = gt(), e = Object.keys((t == null ? void 0 : t.type.props) ?? {}).reduce((l, s) => {\n    const r = (t == null ? void 0 : t.type.props[s]).default;\n    return r !== void 0 && (l[s] = r), l;\n  }, {}), n = wr(a);\n  return B(() => {\n    const l = {}, s = (t == null ? void 0 : t.vnode.props) ?? {};\n    return Object.keys(s).forEach((r) => {\n      l[ml(r)] = s[r];\n    }), Object.keys({ ...e, ...l }).reduce((r, i) => (n.value[i] !== void 0 && (r[i] = n.value[i]), r), {});\n  });\n}\nfunction Se(a, t) {\n  const e = Ot(a), n = t ? Te(t) : {};\n  return B(() => ({\n    ...e.value,\n    ...n\n  }));\n}\nfunction R() {\n  const a = gt(), t = T(), e = B(() => {\n    var r, i;\n    return [\"#text\", \"#comment\"].includes((r = t.value) == null ? void 0 : r.$el.nodeName) ? (i = t.value) == null ? void 0 : i.$el.nextElementSibling : $e(t);\n  }), n = Object.assign({}, a.exposed), l = {};\n  for (const r in a.props)\n    Object.defineProperty(l, r, {\n      enumerable: !0,\n      configurable: !0,\n      get: () => a.props[r]\n    });\n  if (Object.keys(n).length > 0)\n    for (const r in n)\n      Object.defineProperty(l, r, {\n        enumerable: !0,\n        configurable: !0,\n        get: () => n[r]\n      });\n  Object.defineProperty(l, \"$el\", {\n    enumerable: !0,\n    configurable: !0,\n    get: () => a.vnode.el\n  }), a.exposed = l;\n  function s(r) {\n    t.value = r, r && (Object.defineProperty(l, \"$el\", {\n      enumerable: !0,\n      configurable: !0,\n      get: () => r instanceof Element ? r : r.$el\n    }), a.exposed = l);\n  }\n  return { forwardRef: s, currentRef: t, currentElement: e };\n}\nfunction Fl(a, t) {\n  const e = Tt(!1, 300), n = T(null), l = ua();\n  function s() {\n    n.value = null, e.value = !1;\n  }\n  function r(i, u) {\n    const d = i.currentTarget, c = { x: i.clientX, y: i.clientY }, f = Oi(c, d.getBoundingClientRect()), v = ki(c, f), p = Mi(u.getBoundingClientRect()), g = Fi([...v, ...p]);\n    n.value = g, e.value = !0;\n  }\n  return Ce((i) => {\n    if (a.value && t.value) {\n      const u = (c) => r(c, t.value), d = (c) => r(c, a.value);\n      a.value.addEventListener(\"pointerleave\", u), t.value.addEventListener(\"pointerleave\", d), i(() => {\n        var c, f;\n        (c = a.value) == null || c.removeEventListener(\"pointerleave\", u), (f = t.value) == null || f.removeEventListener(\"pointerleave\", d);\n      });\n    }\n  }), Ce((i) => {\n    var u;\n    if (n.value) {\n      const d = (c) => {\n        var _, C;\n        if (!n.value)\n          return;\n        const f = c.target, v = { x: c.clientX, y: c.clientY }, p = ((_ = a.value) == null ? void 0 : _.contains(f)) || ((C = t.value) == null ? void 0 : C.contains(f)), g = !Vi(v, n.value), m = !!f.closest(\"[data-grace-area-trigger]\");\n        p ? s() : (g || m) && (s(), l.trigger());\n      };\n      (u = a.value) == null || u.ownerDocument.addEventListener(\"pointermove\", d), i(() => {\n        var c;\n        return (c = a.value) == null ? void 0 : c.ownerDocument.removeEventListener(\"pointermove\", d);\n      });\n    }\n  }), {\n    isPointerInTransit: e,\n    onPointerExit: l.on\n  };\n}\nfunction Oi(a, t) {\n  const e = Math.abs(t.top - a.y), n = Math.abs(t.bottom - a.y), l = Math.abs(t.right - a.x), s = Math.abs(t.left - a.x);\n  switch (Math.min(e, n, l, s)) {\n    case s:\n      return \"left\";\n    case l:\n      return \"right\";\n    case e:\n      return \"top\";\n    case n:\n      return \"bottom\";\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\nfunction ki(a, t, e = 5) {\n  const n = [];\n  switch (t) {\n    case \"top\":\n      n.push(\n        { x: a.x - e, y: a.y + e },\n        { x: a.x + e, y: a.y + e }\n      );\n      break;\n    case \"bottom\":\n      n.push(\n        { x: a.x - e, y: a.y - e },\n        { x: a.x + e, y: a.y - e }\n      );\n      break;\n    case \"left\":\n      n.push(\n        { x: a.x + e, y: a.y - e },\n        { x: a.x + e, y: a.y + e }\n      );\n      break;\n    case \"right\":\n      n.push(\n        { x: a.x - e, y: a.y - e },\n        { x: a.x - e, y: a.y + e }\n      );\n      break;\n  }\n  return n;\n}\nfunction Mi(a) {\n  const { top: t, right: e, bottom: n, left: l } = a;\n  return [\n    { x: l, y: t },\n    { x: e, y: t },\n    { x: e, y: n },\n    { x: l, y: n }\n  ];\n}\nfunction Vi(a, t) {\n  const { x: e, y: n } = a;\n  let l = !1;\n  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {\n    const i = t[s].x, u = t[s].y, d = t[r].x, c = t[r].y;\n    u > n != c > n && e < (d - i) * (n - u) / (c - u) + i && (l = !l);\n  }\n  return l;\n}\nfunction Fi(a) {\n  const t = a.slice();\n  return t.sort((e, n) => e.x < n.x ? -1 : e.x > n.x ? 1 : e.y < n.y ? -1 : e.y > n.y ? 1 : 0), Ni(t);\n}\nfunction Ni(a) {\n  if (a.length <= 1)\n    return a.slice();\n  const t = [];\n  for (let n = 0; n < a.length; n++) {\n    const l = a[n];\n    for (; t.length >= 2; ) {\n      const s = t[t.length - 1], r = t[t.length - 2];\n      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))\n        t.pop();\n      else break;\n    }\n    t.push(l);\n  }\n  t.pop();\n  const e = [];\n  for (let n = a.length - 1; n >= 0; n--) {\n    const l = a[n];\n    for (; e.length >= 2; ) {\n      const s = e[e.length - 1], r = e[e.length - 2];\n      if ((s.x - r.x) * (l.y - r.y) >= (s.y - r.y) * (l.x - r.x))\n        e.pop();\n      else break;\n    }\n    e.push(l);\n  }\n  return e.pop(), t.length === 1 && e.length === 1 && t[0].x === e[0].x && t[0].y === e[0].y ? t : t.concat(e);\n}\nvar Li = function(a) {\n  if (typeof document > \"u\")\n    return null;\n  var t = Array.isArray(a) ? a[0] : a;\n  return t.ownerDocument.body;\n}, Kt = /* @__PURE__ */ new WeakMap(), $a = /* @__PURE__ */ new WeakMap(), Ba = {}, _n = 0, Nl = function(a) {\n  return a && (a.host || Nl(a.parentNode));\n}, zi = function(a, t) {\n  return t.map(function(e) {\n    if (a.contains(e))\n      return e;\n    var n = Nl(e);\n    return n && a.contains(n) ? n : (console.error(\"aria-hidden\", e, \"in not contained inside\", a, \". Doing nothing\"), null);\n  }).filter(function(e) {\n    return !!e;\n  });\n}, Ki = function(a, t, e, n) {\n  var l = zi(t, Array.isArray(a) ? a : [a]);\n  Ba[e] || (Ba[e] = /* @__PURE__ */ new WeakMap());\n  var s = Ba[e], r = [], i = /* @__PURE__ */ new Set(), u = new Set(l), d = function(f) {\n    !f || i.has(f) || (i.add(f), d(f.parentNode));\n  };\n  l.forEach(d);\n  var c = function(f) {\n    !f || u.has(f) || Array.prototype.forEach.call(f.children, function(v) {\n      if (i.has(v))\n        c(v);\n      else\n        try {\n          var p = v.getAttribute(n), g = p !== null && p !== \"false\", m = (Kt.get(v) || 0) + 1, _ = (s.get(v) || 0) + 1;\n          Kt.set(v, m), s.set(v, _), r.push(v), m === 1 && g && $a.set(v, !0), _ === 1 && v.setAttribute(e, \"true\"), g || v.setAttribute(n, \"true\");\n        } catch (C) {\n          console.error(\"aria-hidden: cannot operate on \", v, C);\n        }\n    });\n  };\n  return c(t), i.clear(), _n++, function() {\n    r.forEach(function(f) {\n      var v = Kt.get(f) - 1, p = s.get(f) - 1;\n      Kt.set(f, v), s.set(f, p), v || ($a.has(f) || f.removeAttribute(n), $a.delete(f)), p || f.removeAttribute(e);\n    }), _n--, _n || (Kt = /* @__PURE__ */ new WeakMap(), Kt = /* @__PURE__ */ new WeakMap(), $a = /* @__PURE__ */ new WeakMap(), Ba = {});\n  };\n}, Hi = function(a, t, e) {\n  e === void 0 && (e = \"data-aria-hidden\");\n  var n = Array.from(Array.isArray(a) ? a : [a]), l = Li(a);\n  return l ? (n.push.apply(n, Array.from(l.querySelectorAll(\"[aria-live]\"))), Ki(n, l, e, \"aria-hidden\")) : function() {\n    return null;\n  };\n};\nfunction ga(a) {\n  let t;\n  ee(() => $e(a), (e) => {\n    e ? t = Hi(e) : t && t();\n  }), Be(() => {\n    t && t();\n  });\n}\nlet Wi = 0;\nfunction ge(a, t = \"radix\") {\n  if (a)\n    return a;\n  const e = Ya({ useId: void 0 });\n  return No.useId ? `${t}-${No.useId()}` : e.useId ? `${t}-${e.useId()}` : `${t}-${++Wi}`;\n}\nfunction ji(a, t) {\n  const e = T(), n = (s, r) => {\n    if (t.multiple && Array.isArray(a.value))\n      if (t.selectionBehavior === \"replace\")\n        a.value = [s], e.value = s;\n      else {\n        const i = a.value.findIndex((u) => r(u));\n        i !== -1 ? a.value.splice(i, 1) : a.value.push(s);\n      }\n    else\n      t.selectionBehavior === \"replace\" ? a.value = { ...s } : !Array.isArray(a.value) && r(a.value) ? a.value = void 0 : a.value = { ...s };\n    return a.value;\n  };\n  function l(s, r, i, u) {\n    var v;\n    if (!(e != null && e.value) || !t.multiple || !Array.isArray(a.value))\n      return;\n    const c = (v = i().filter((p) => p.ref.dataset.disabled !== \"\").find((p) => p.ref === r)) == null ? void 0 : v.value;\n    if (!c)\n      return;\n    let f = null;\n    switch (s) {\n      case \"prev\":\n      case \"next\": {\n        f = Bt(u, e.value, c);\n        break;\n      }\n      case \"first\": {\n        f = Bt(u, e.value, u == null ? void 0 : u[0]);\n        break;\n      }\n      case \"last\": {\n        f = Bt(u, e.value, u == null ? void 0 : u[u.length - 1]);\n        break;\n      }\n    }\n    a.value = f;\n  }\n  return {\n    firstValue: e,\n    onSelectItem: n,\n    handleMultipleReplace: l\n  };\n}\nfunction Ll(a) {\n  const t = T(), e = B(() => {\n    var l;\n    return ((l = t.value) == null ? void 0 : l.width) ?? 0;\n  }), n = B(() => {\n    var l;\n    return ((l = t.value) == null ? void 0 : l.height) ?? 0;\n  });\n  return le(() => {\n    const l = $e(a);\n    if (l) {\n      t.value = { width: l.offsetWidth, height: l.offsetHeight };\n      const s = new ResizeObserver((r) => {\n        if (!Array.isArray(r) || !r.length)\n          return;\n        const i = r[0];\n        let u, d;\n        if (\"borderBoxSize\" in i) {\n          const c = i.borderBoxSize, f = Array.isArray(c) ? c[0] : c;\n          u = f.inlineSize, d = f.blockSize;\n        } else\n          u = l.offsetWidth, d = l.offsetHeight;\n        t.value = { width: u, height: d };\n      });\n      return s.observe(l, { box: \"border-box\" }), () => s.unobserve(l);\n    } else\n      t.value = void 0;\n  }), {\n    width: e,\n    height: n\n  };\n}\nfunction zl(a, t) {\n  const e = T(a);\n  function n(s) {\n    return t[e.value][s] ?? e.value;\n  }\n  return {\n    state: e,\n    dispatch: (s) => {\n      e.value = n(s);\n    }\n  };\n}\nconst Ui = \"data-item-text\";\nfunction ba(a) {\n  const t = Tt(\"\", 1e3);\n  return {\n    search: t,\n    handleTypeaheadSearch: (l, s) => {\n      if (!(a != null && a.value) && !s)\n        return;\n      t.value = t.value + l;\n      const r = (a == null ? void 0 : a.value) ?? s, i = me(), u = r.map((p) => {\n        var g;\n        return {\n          ref: p,\n          textValue: ((g = (p.querySelector(`[${Ui}]`) ?? p).textContent) == null ? void 0 : g.trim()) ?? \"\"\n        };\n      }), d = u.find((p) => p.ref === i), c = u.map((p) => p.textValue), f = Zn(c, t.value, d == null ? void 0 : d.textValue), v = u.find((p) => p.textValue === f);\n      return v && v.ref.focus(), v == null ? void 0 : v.ref;\n    },\n    resetTypeahead: () => {\n      t.value = \"\";\n    }\n  };\n}\nfunction Xn(a, t) {\n  return a.map((e, n) => a[(t + n) % a.length]);\n}\nfunction Zn(a, t, e) {\n  const l = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, s = e ? a.indexOf(e) : -1;\n  let r = Xn(a, Math.max(s, 0));\n  l.length === 1 && (r = r.filter((d) => d !== e));\n  const u = r.find(\n    (d) => d.toLowerCase().startsWith(l.toLowerCase())\n  );\n  return u !== e ? u : void 0;\n}\nfunction Sv(a, t) {\n  return {\n    inheritAttrs: !1,\n    name: `${a.__name ?? \"\"}Wrapper`,\n    setup(e, n) {\n      return () => {\n        const l = typeof (t == null ? void 0 : t.props) == \"function\" ? t == null ? void 0 : t.props(n.attrs) : t == null ? void 0 : t.props, { forwardRef: s } = R(), r = k(l, n.attrs);\n        return mt(a, { ...r, ref: s }, n.slots);\n      };\n    }\n  };\n}\nfunction nt() {\n  return {\n    ALT: \"Alt\",\n    ARROW_DOWN: \"ArrowDown\",\n    ARROW_LEFT: \"ArrowLeft\",\n    ARROW_RIGHT: \"ArrowRight\",\n    ARROW_UP: \"ArrowUp\",\n    BACKSPACE: \"Backspace\",\n    CAPS_LOCK: \"CapsLock\",\n    CONTROL: \"Control\",\n    DELETE: \"Delete\",\n    END: \"End\",\n    ENTER: \"Enter\",\n    ESCAPE: \"Escape\",\n    F1: \"F1\",\n    F10: \"F10\",\n    F11: \"F11\",\n    F12: \"F12\",\n    F2: \"F2\",\n    F3: \"F3\",\n    F4: \"F4\",\n    F5: \"F5\",\n    F6: \"F6\",\n    F7: \"F7\",\n    F8: \"F8\",\n    F9: \"F9\",\n    HOME: \"Home\",\n    META: \"Meta\",\n    PAGE_DOWN: \"PageDown\",\n    PAGE_UP: \"PageUp\",\n    SHIFT: \"Shift\",\n    SPACE: \" \",\n    TAB: \"Tab\",\n    CTRL: \"Control\",\n    ASTERISK: \"*\",\n    SPACE_CODE: \"Space\"\n  };\n}\nconst Jn = x({\n  name: \"PrimitiveSlot\",\n  inheritAttrs: !1,\n  setup(a, { attrs: t, slots: e }) {\n    return () => {\n      var u, d;\n      if (!e.default)\n        return null;\n      const n = qa(e.default()), l = n.findIndex((c) => c.type !== hl);\n      if (l === -1)\n        return n;\n      const s = n[l];\n      (u = s.props) == null || delete u.ref;\n      const r = s.props ? k(t, s.props) : t;\n      t.class && ((d = s.props) != null && d.class) && delete s.props.class;\n      const i = Ln(s, r);\n      for (const c in r)\n        c.startsWith(\"on\") && (i.props || (i.props = {}), i.props[c] = r[c]);\n      return n.length === 1 ? i : (n[l] = i, n);\n    };\n  }\n}), O = x({\n  name: \"Primitive\",\n  inheritAttrs: !1,\n  props: {\n    asChild: {\n      type: Boolean,\n      default: !1\n    },\n    as: {\n      type: [String, Object],\n      default: \"div\"\n    }\n  },\n  setup(a, { attrs: t, slots: e }) {\n    const n = a.asChild ? \"template\" : a.as;\n    return typeof n == \"string\" && [\"area\", \"img\", \"input\"].includes(n) ? () => mt(n, t) : n !== \"template\" ? () => mt(a.as, t, { default: e.default }) : () => mt(Jn, t, { default: e.default });\n  }\n});\nfunction Re() {\n  const a = T(), t = B(() => {\n    var e, n;\n    return [\"#text\", \"#comment\"].includes((e = a.value) == null ? void 0 : e.$el.nodeName) ? (n = a.value) == null ? void 0 : n.$el.nextElementSibling : $e(a);\n  });\n  return {\n    primitiveElement: a,\n    currentElement: t\n  };\n}\nconst [Kl, Gi] = te(\"CollapsibleRoot\"), qi = /* @__PURE__ */ x({\n  __name: \"CollapsibleRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:open\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, s = ne(n, \"open\", e, {\n      defaultValue: n.defaultOpen,\n      passive: n.open === void 0\n    }), r = ne(n, \"disabled\");\n    return Gi({\n      contentId: \"\",\n      disabled: r,\n      open: s,\n      onOpenToggle: () => {\n        s.value = !s.value;\n      }\n    }), t({ open: s }), R(), (i, u) => (b(), S(o(O), {\n      as: i.as,\n      \"as-child\": n.asChild,\n      \"data-state\": o(s) ? \"open\" : \"closed\",\n      \"data-disabled\": o(r) ? \"\" : void 0\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\", { open: o(s) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"]));\n  }\n}), Yi = /* @__PURE__ */ x({\n  __name: \"CollapsibleTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Kl();\n    return (n, l) => {\n      var s, r;\n      return b(), S(o(O), {\n        type: n.as === \"button\" ? \"button\" : void 0,\n        as: n.as,\n        \"as-child\": t.asChild,\n        \"aria-controls\": o(e).contentId,\n        \"aria-expanded\": o(e).open.value,\n        \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": (s = o(e).disabled) != null && s.value ? \"\" : void 0,\n        disabled: (r = o(e).disabled) == null ? void 0 : r.value,\n        onClick: o(e).onOpenToggle\n      }, {\n        default: y(() => [\n          w(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"type\", \"as\", \"as-child\", \"aria-controls\", \"aria-expanded\", \"data-state\", \"data-disabled\", \"disabled\", \"onClick\"]);\n    };\n  }\n});\nfunction Xi(a, t) {\n  var _;\n  const e = T({}), n = T(\"none\"), l = T(a), s = a.value ? \"mounted\" : \"unmounted\";\n  let r;\n  const i = ((_ = t.value) == null ? void 0 : _.ownerDocument.defaultView) ?? Rt, { state: u, dispatch: d } = zl(s, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  }), c = (C) => {\n    var $;\n    if (Je) {\n      const h = new CustomEvent(C, { bubbles: !1, cancelable: !1 });\n      ($ = t.value) == null || $.dispatchEvent(h);\n    }\n  };\n  ee(\n    a,\n    async (C, $) => {\n      var E;\n      const h = $ !== C;\n      if (await oe(), h) {\n        const P = n.value, D = Ia(t.value);\n        C ? (d(\"MOUNT\"), c(\"enter\"), D === \"none\" && c(\"after-enter\")) : D === \"none\" || ((E = e.value) == null ? void 0 : E.display) === \"none\" ? (d(\"UNMOUNT\"), c(\"leave\"), c(\"after-leave\")) : $ && P !== D ? (d(\"ANIMATION_OUT\"), c(\"leave\")) : (d(\"UNMOUNT\"), c(\"after-leave\"));\n      }\n    },\n    { immediate: !0 }\n  );\n  const f = (C) => {\n    const $ = Ia(t.value), h = $.includes(\n      C.animationName\n    ), E = u.value === \"mounted\" ? \"enter\" : \"leave\";\n    if (C.target === t.value && h && (c(`after-${E}`), d(\"ANIMATION_END\"), !l.value)) {\n      const P = t.value.style.animationFillMode;\n      t.value.style.animationFillMode = \"forwards\", r = i == null ? void 0 : i.setTimeout(() => {\n        var D;\n        ((D = t.value) == null ? void 0 : D.style.animationFillMode) === \"forwards\" && (t.value.style.animationFillMode = P);\n      });\n    }\n    C.target === t.value && $ === \"none\" && d(\"ANIMATION_END\");\n  }, v = (C) => {\n    C.target === t.value && (n.value = Ia(t.value));\n  }, p = ee(\n    t,\n    (C, $) => {\n      C ? (e.value = getComputedStyle(C), C.addEventListener(\"animationstart\", v), C.addEventListener(\"animationcancel\", f), C.addEventListener(\"animationend\", f)) : (d(\"ANIMATION_END\"), r !== void 0 && (i == null || i.clearTimeout(r)), $ == null || $.removeEventListener(\"animationstart\", v), $ == null || $.removeEventListener(\"animationcancel\", f), $ == null || $.removeEventListener(\"animationend\", f));\n    },\n    { immediate: !0 }\n  ), g = ee(u, () => {\n    const C = Ia(t.value);\n    n.value = u.value === \"mounted\" ? C : \"none\";\n  });\n  return Be(() => {\n    p(), g();\n  }), {\n    isPresent: B(\n      () => [\"mounted\", \"unmountSuspended\"].includes(u.value)\n    )\n  };\n}\nfunction Ia(a) {\n  return a && getComputedStyle(a).animationName || \"none\";\n}\nconst Pe = x({\n  name: \"Presence\",\n  props: {\n    present: {\n      type: Boolean,\n      required: !0\n    },\n    forceMount: {\n      type: Boolean\n    }\n  },\n  slots: {},\n  setup(a, { slots: t, expose: e }) {\n    var d;\n    const { present: n, forceMount: l } = ae(a), s = T(), { isPresent: r } = Xi(n, s);\n    e({ present: r });\n    let i = t.default({ present: r });\n    i = qa(i || []);\n    const u = gt();\n    if (i && (i == null ? void 0 : i.length) > 1) {\n      const c = (d = u == null ? void 0 : u.parent) != null && d.type.name ? `<${u.parent.type.name} />` : \"component\";\n      throw new Error(\n        [\n          `Detected an invalid children for \\`${c}\\` for  \\`Presence\\` component.`,\n          \"\",\n          \"Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.\",\n          \"You can apply a few solutions:\",\n          [\n            \"Provide a single child element so that `presence` directive attach correctly.\",\n            \"Ensure the first child is an actual element instead of a raw text node or comment node.\"\n          ].map((f) => `  - ${f}`).join(`\n`)\n        ].join(`\n`)\n      );\n    }\n    return () => l.value || n.value || r.value ? mt(t.default({ present: r })[0], {\n      ref: (c) => {\n        const f = $e(c);\n        return typeof (f == null ? void 0 : f.hasAttribute) > \"u\" || (f != null && f.hasAttribute(\"data-radix-popper-content-wrapper\") ? s.value = f.firstElementChild : s.value = f), f;\n      }\n    }) : null;\n  }\n}), Zi = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"CollapsibleContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Kl();\n    e.contentId || (e.contentId = ge(void 0, \"radix-vue-collapsible-content\"));\n    const n = T(), { forwardRef: l, currentElement: s } = R(), r = T(0), i = T(0), u = B(() => e.open.value), d = T(u.value), c = T();\n    return ee(\n      () => {\n        var f;\n        return [u.value, (f = n.value) == null ? void 0 : f.present];\n      },\n      async () => {\n        await oe();\n        const f = s.value;\n        if (!f)\n          return;\n        c.value = c.value || {\n          transitionDuration: f.style.transitionDuration,\n          animationName: f.style.animationName\n        }, f.style.transitionDuration = \"0s\", f.style.animationName = \"none\";\n        const v = f.getBoundingClientRect();\n        i.value = v.height, r.value = v.width, d.value || (f.style.transitionDuration = c.value.transitionDuration, f.style.animationName = c.value.animationName);\n      },\n      {\n        immediate: !0\n      }\n    ), le(() => {\n      requestAnimationFrame(() => {\n        d.value = !1;\n      });\n    }), (f, v) => (b(), S(o(Pe), {\n      ref_key: \"presentRef\",\n      ref: n,\n      present: f.forceMount || o(e).open.value,\n      \"force-mount\": !0\n    }, {\n      default: y(() => {\n        var p, g;\n        return [\n          q(o(O), k(f.$attrs, {\n            id: o(e).contentId,\n            ref: o(l),\n            \"as-child\": t.asChild,\n            as: f.as,\n            \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n            \"data-disabled\": (p = o(e).disabled) != null && p.value ? \"\" : void 0,\n            hidden: !((g = n.value) != null && g.present),\n            style: {\n              \"--radix-collapsible-content-height\": `${i.value}px`,\n              \"--radix-collapsible-content-width\": `${r.value}px`\n            }\n          }), {\n            default: y(() => {\n              var m;\n              return [\n                (m = n.value) != null && m.present ? w(f.$slots, \"default\", { key: 0 }) : ce(\"\", !0)\n              ];\n            }),\n            _: 3\n          }, 16, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-disabled\", \"hidden\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction Hl({ type: a, defaultValue: t, modelValue: e }) {\n  const n = e || t;\n  if (ht(a) && ht(e) && ht(t))\n    throw new Error(\"Either the `type` or the `value` or `default-value` prop must be defined.\");\n  if (e !== void 0 && t !== void 0 && typeof e != typeof t)\n    throw new Error(\n      `Invalid prop \\`value\\` of value \\`${e}\\` supplied, should be the same type as the \\`defaultValue\\` prop, which is \\`${t}\\`. The \\`value\\` prop must be:\n  ${a === \"single\" ? \"- a string\" : a === \"multiple\" ? \"- an array of strings\" : `- a string\n- an array of strings`}\n  - \\`undefined\\``\n    );\n  const l = e !== void 0 || t !== void 0;\n  if (a && l) {\n    const s = Array.isArray(e) || Array.isArray(t), r = e !== void 0 ? \"modelValue\" : \"defaultValue\", i = r === \"modelValue\" ? typeof e : typeof t;\n    if (a === \"single\" && s)\n      return console.error(`Invalid prop \\`${r}\\` of type ${i} supplied with type \\`single\\`. The \\`modelValue\\` prop must be a string or \\`undefined\\`.\n    You can remove the \\`type\\` prop to let the component infer the type from the ${r} prop.`), \"multiple\";\n    if (a === \"multiple\" && !s)\n      return console.error(`Invalid prop \\`${r}\\` of type ${i} supplied with type \\`multiple\\`. The \\`modelValue\\` prop must be an array of strings or \\`undefined\\`.\n    You can remove the \\`type\\` prop to let the component infer the type from the ${r} prop.`), \"single\";\n  }\n  return l ? Array.isArray(n) ? \"multiple\" : \"single\" : a;\n}\nfunction Ji({ type: a, defaultValue: t, modelValue: e }) {\n  return a || Hl({ type: a, defaultValue: t, modelValue: e });\n}\nfunction Qi({ type: a, defaultValue: t }) {\n  return t !== void 0 ? t : a === \"single\" ? void 0 : [];\n}\nfunction Wl(a, t) {\n  const e = T(Ji(a)), n = ne(a, \"modelValue\", t, {\n    defaultValue: Qi(a),\n    passive: a.modelValue === void 0,\n    deep: !0\n  });\n  ee(\n    () => [a.type, a.modelValue, a.defaultValue],\n    () => {\n      const r = Hl(a);\n      e.value !== r && (e.value = r);\n    },\n    { immediate: !0 }\n  );\n  function l(r) {\n    if (e.value === \"single\")\n      n.value = r === n.value ? void 0 : r;\n    else {\n      const i = [...n.value || []];\n      if (i.includes(r)) {\n        const u = i.findIndex((d) => d === r);\n        i.splice(u, 1);\n      } else\n        i.push(r);\n      n.value = i;\n    }\n  }\n  const s = B(() => e.value === \"single\");\n  return {\n    modelValue: n,\n    type: e,\n    changeModelValue: l,\n    isSingle: s\n  };\n}\nconst [Xa, eu] = te(\"AccordionRoot\"), Ev = /* @__PURE__ */ x({\n  __name: \"AccordionRoot\",\n  props: {\n    collapsible: { type: Boolean, default: !1 },\n    disabled: { type: Boolean, default: !1 },\n    dir: {},\n    orientation: { default: \"vertical\" },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, disabled: s } = ae(e), r = we(l), { modelValue: i, changeModelValue: u, isSingle: d } = Wl(e, n), { forwardRef: c, currentElement: f } = R();\n    return eu({\n      disabled: s,\n      direction: r,\n      orientation: e.orientation,\n      parentElement: f,\n      isSingle: d,\n      collapsible: e.collapsible,\n      modelValue: i,\n      changeModelValue: u\n    }), (v, p) => (b(), S(o(O), {\n      ref: o(c),\n      \"as-child\": v.asChild,\n      as: v.as\n    }, {\n      default: y(() => [\n        w(v.$slots, \"default\", { modelValue: o(i) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), [Qn, tu] = te(\"AccordionItem\"), Pv = /* @__PURE__ */ x({\n  __name: \"AccordionItem\",\n  props: {\n    disabled: { type: Boolean },\n    value: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, n = Xa(), l = B(\n      () => n.isSingle.value ? e.value === n.modelValue.value : Array.isArray(n.modelValue.value) && n.modelValue.value.includes(e.value)\n    ), s = B(() => n.disabled.value || e.disabled), r = B(() => s.value ? \"\" : void 0), i = B(\n      () => l.value ? \"open\" : \"closed\"\n      /* Closed */\n    );\n    t({ open: l, dataDisabled: r });\n    const { currentRef: u, currentElement: d } = R();\n    tu({\n      open: l,\n      dataState: i,\n      disabled: s,\n      dataDisabled: r,\n      triggerId: \"\",\n      currentRef: u,\n      currentElement: d,\n      value: B(() => e.value)\n    });\n    function c(f) {\n      var m;\n      const v = f.target;\n      if (Array.from(((m = n.parentElement.value) == null ? void 0 : m.querySelectorAll(\"[data-radix-vue-collection-item]\")) ?? []).findIndex((_) => _ === v) === -1)\n        return null;\n      At(\n        f,\n        d.value,\n        n.parentElement.value,\n        {\n          arrowKeyOptions: n.orientation,\n          dir: n.direction.value,\n          focus: !0\n        }\n      );\n    }\n    return (f, v) => (b(), S(o(qi), {\n      \"data-orientation\": o(n).orientation,\n      \"data-disabled\": r.value,\n      \"data-state\": i.value,\n      disabled: s.value,\n      open: l.value,\n      as: e.as,\n      \"as-child\": e.asChild,\n      onKeydown: ie(c, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\"])\n    }, {\n      default: y(() => [\n        w(f.$slots, \"default\", { open: l.value })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"data-disabled\", \"data-state\", \"disabled\", \"open\", \"as\", \"as-child\"]));\n  }\n}), Dv = /* @__PURE__ */ x({\n  __name: \"AccordionContent\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Xa(), n = Qn();\n    return R(), (l, s) => (b(), S(o(Zi), {\n      role: \"region\",\n      hidden: !o(n).open.value,\n      \"as-child\": t.asChild,\n      \"force-mount\": t.forceMount,\n      \"aria-labelledby\": o(n).triggerId,\n      \"data-state\": o(n).dataState.value,\n      \"data-disabled\": o(n).dataDisabled.value,\n      \"data-orientation\": o(e).orientation,\n      style: { \"--radix-accordion-content-width\": \"var(--radix-collapsible-content-width)\", \"--radix-accordion-content-height\": \"var(--radix-collapsible-content-height)\" }\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"hidden\", \"as-child\", \"force-mount\", \"aria-labelledby\", \"data-state\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), $v = /* @__PURE__ */ x({\n  __name: \"AccordionHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h3\" }\n  },\n  setup(a) {\n    const t = a, e = Xa(), n = Qn();\n    return R(), (l, s) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-orientation\": o(e).orientation,\n      \"data-state\": o(n).dataState.value,\n      \"data-disabled\": o(n).dataDisabled.value\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"data-state\", \"data-disabled\"]));\n  }\n}), Bv = /* @__PURE__ */ x({\n  __name: \"AccordionTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Xa(), n = Qn();\n    n.triggerId || (n.triggerId = ge(void 0, \"radix-vue-accordion-trigger\"));\n    function l() {\n      const s = e.isSingle.value && n.open.value && !e.collapsible;\n      n.disabled.value || s || e.changeModelValue(n.value.value);\n    }\n    return (s, r) => (b(), S(o(Yi), {\n      id: o(n).triggerId,\n      ref: o(n).currentRef,\n      \"data-radix-vue-collection-item\": \"\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-disabled\": o(n).disabled.value || void 0,\n      \"aria-expanded\": o(n).open.value || !1,\n      \"data-disabled\": o(n).dataDisabled.value,\n      \"data-orientation\": o(e).orientation,\n      \"data-state\": o(n).dataState.value,\n      disabled: o(n).disabled.value,\n      onClick: l\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"aria-disabled\", \"aria-expanded\", \"data-disabled\", \"data-orientation\", \"data-state\", \"disabled\"]));\n  }\n}), [ot, au] = te(\"DialogRoot\"), nu = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DialogRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean, default: !1 },\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"open\", t, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), s = T(), r = T(), { modal: i } = ae(e);\n    return au({\n      open: l,\n      modal: i,\n      openModal: () => {\n        l.value = !0;\n      },\n      onOpenChange: (u) => {\n        l.value = u;\n      },\n      onOpenToggle: () => {\n        l.value = !l.value;\n      },\n      contentId: \"\",\n      titleId: \"\",\n      descriptionId: \"\",\n      triggerElement: s,\n      contentElement: r\n    }), (u, d) => w(u.$slots, \"default\", { open: o(l) });\n  }\n}), ou = /* @__PURE__ */ x({\n  __name: \"DialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ot(), { forwardRef: n, currentElement: l } = R();\n    return e.contentId || (e.contentId = ge(void 0, \"radix-vue-dialog-content\")), le(() => {\n      e.triggerElement.value = l.value;\n    }), (s, r) => (b(), S(o(O), k(t, {\n      ref: o(n),\n      type: s.as === \"button\" ? \"button\" : void 0,\n      \"aria-haspopup\": \"dialog\",\n      \"aria-expanded\": o(e).open.value || !1,\n      \"aria-controls\": o(e).open.value ? o(e).contentId : void 0,\n      \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n      onClick: o(e).onOpenToggle\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"onClick\"]));\n  }\n}), rt = /* @__PURE__ */ x({\n  __name: \"Teleport\",\n  props: {\n    to: { default: \"body\" },\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = Ga();\n    return (e, n) => o(t) || e.forceMount ? (b(), S(qt, {\n      key: 0,\n      to: e.to,\n      disabled: e.disabled\n    }, [\n      w(e.$slots, \"default\")\n    ], 8, [\"to\", \"disabled\"])) : ce(\"\", !0);\n  }\n}), Iv = /* @__PURE__ */ x({\n  __name: \"DialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lu = \"dismissableLayer.pointerDownOutside\", su = \"dismissableLayer.focusOutside\";\nfunction jl(a, t) {\n  const e = t.closest(\n    \"[data-dismissable-layer]\"\n  ), n = a.dataset.dismissableLayer === \"\" ? a : a.querySelector(\n    \"[data-dismissable-layer]\"\n  ), l = Array.from(\n    a.ownerDocument.querySelectorAll(\"[data-dismissable-layer]\")\n  );\n  return !!(e && n === e || l.indexOf(n) < l.indexOf(e));\n}\nfunction Ul(a, t) {\n  var s;\n  const e = ((s = t == null ? void 0 : t.value) == null ? void 0 : s.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = T(!1), l = T(() => {\n  });\n  return Ce((r) => {\n    if (!Je)\n      return;\n    const i = async (d) => {\n      const c = d.target;\n      if (t != null && t.value) {\n        if (jl(t.value, c)) {\n          n.value = !1;\n          return;\n        }\n        if (d.target && !n.value) {\n          let f = function() {\n            jt(\n              lu,\n              a,\n              v\n            );\n          };\n          const v = { originalEvent: d };\n          d.pointerType === \"touch\" ? (e.removeEventListener(\"click\", l.value), l.value = f, e.addEventListener(\"click\", l.value, {\n            once: !0\n          })) : f();\n        } else\n          e.removeEventListener(\"click\", l.value);\n        n.value = !1;\n      }\n    }, u = window.setTimeout(() => {\n      e.addEventListener(\"pointerdown\", i);\n    }, 0);\n    r(() => {\n      window.clearTimeout(u), e.removeEventListener(\"pointerdown\", i), e.removeEventListener(\"click\", l.value);\n    });\n  }), {\n    onPointerDownCapture: () => n.value = !0\n  };\n}\nfunction Gl(a, t) {\n  var l;\n  const e = ((l = t == null ? void 0 : t.value) == null ? void 0 : l.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), n = T(!1);\n  return Ce((s) => {\n    if (!Je)\n      return;\n    const r = async (i) => {\n      t != null && t.value && (await oe(), !(!t.value || jl(t.value, i.target)) && i.target && !n.value && jt(\n        su,\n        a,\n        { originalEvent: i }\n      ));\n    };\n    e.addEventListener(\"focusin\", r), s(() => e.removeEventListener(\"focusin\", r));\n  }), {\n    onFocusCapture: () => n.value = !0,\n    onBlurCapture: () => n.value = !1\n  };\n}\nconst Ge = Fa({\n  layersRoot: /* @__PURE__ */ new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),\n  branches: /* @__PURE__ */ new Set()\n}), Ct = /* @__PURE__ */ x({\n  __name: \"DismissableLayer\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"dismiss\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = B(\n      () => {\n        var g;\n        return ((g = s.value) == null ? void 0 : g.ownerDocument) ?? globalThis.document;\n      }\n    ), i = B(() => Ge.layersRoot), u = B(() => s.value ? Array.from(i.value).indexOf(s.value) : -1), d = B(() => Ge.layersWithOutsidePointerEventsDisabled.size > 0), c = B(() => {\n      const g = Array.from(i.value), [m] = [...Ge.layersWithOutsidePointerEventsDisabled].slice(-1), _ = g.indexOf(m);\n      return u.value >= _;\n    }), f = Ul(async (g) => {\n      const m = [...Ge.branches].some(\n        (_) => _ == null ? void 0 : _.contains(g.target)\n      );\n      !c.value || m || (n(\"pointerDownOutside\", g), n(\"interactOutside\", g), await oe(), g.defaultPrevented || n(\"dismiss\"));\n    }, s), v = Gl((g) => {\n      [...Ge.branches].some(\n        (_) => _ == null ? void 0 : _.contains(g.target)\n      ) || (n(\"focusOutside\", g), n(\"interactOutside\", g), g.defaultPrevented || n(\"dismiss\"));\n    }, s);\n    Gn(\"Escape\", (g) => {\n      u.value === i.value.size - 1 && (n(\"escapeKeyDown\", g), g.defaultPrevented || n(\"dismiss\"));\n    });\n    let p;\n    return Ce((g) => {\n      s.value && (e.disableOutsidePointerEvents && (Ge.layersWithOutsidePointerEventsDisabled.size === 0 && (p = r.value.body.style.pointerEvents, r.value.body.style.pointerEvents = \"none\"), Ge.layersWithOutsidePointerEventsDisabled.add(s.value)), i.value.add(s.value), g(() => {\n        e.disableOutsidePointerEvents && Ge.layersWithOutsidePointerEventsDisabled.size === 1 && (r.value.body.style.pointerEvents = p);\n      }));\n    }), Ce((g) => {\n      g(() => {\n        s.value && (i.value.delete(s.value), Ge.layersWithOutsidePointerEventsDisabled.delete(s.value));\n      });\n    }), (g, m) => (b(), S(o(O), {\n      ref: o(l),\n      \"as-child\": g.asChild,\n      as: g.as,\n      \"data-dismissable-layer\": \"\",\n      style: Me({\n        pointerEvents: d.value ? c.value ? \"auto\" : \"none\" : void 0\n      }),\n      onFocusCapture: o(v).onFocusCapture,\n      onBlurCapture: o(v).onBlurCapture,\n      onPointerdownCapture: o(f).onPointerDownCapture\n    }, {\n      default: y(() => [\n        w(g.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"style\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]));\n  }\n}), ru = /* @__PURE__ */ x({\n  __name: \"DismissableLayerBranch\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = R();\n    return le(() => {\n      Ge.branches.add(n.value);\n    }), Be(() => {\n      Ge.branches.delete(n.value);\n    }), (l, s) => (b(), S(o(O), k({ ref: o(e) }, t), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xn = \"focusScope.autoFocusOnMount\", Sn = \"focusScope.autoFocusOnUnmount\", qo = { bubbles: !1, cancelable: !0 };\nfunction Ma(a, { select: t = !1 } = {}) {\n  const e = me();\n  for (const n of a)\n    if (pt(n, { select: t }), me() !== e)\n      return !0;\n}\nfunction iu(a) {\n  const t = eo(a), e = Yo(t, a), n = Yo(t.reverse(), a);\n  return [e, n];\n}\nfunction eo(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const l = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nfunction Yo(a, t) {\n  for (const e of a)\n    if (!uu(e, { upTo: t }))\n      return e;\n}\nfunction uu(a, { upTo: t }) {\n  if (getComputedStyle(a).visibility === \"hidden\")\n    return !0;\n  for (; a; ) {\n    if (t !== void 0 && a === t)\n      return !1;\n    if (getComputedStyle(a).display === \"none\")\n      return !0;\n    a = a.parentElement;\n  }\n  return !1;\n}\nfunction du(a) {\n  return a instanceof HTMLInputElement && \"select\" in a;\n}\nfunction pt(a, { select: t = !1 } = {}) {\n  if (a && a.focus) {\n    const e = me();\n    a.focus({ preventScroll: !0 }), a !== e && du(a) && t && a.select();\n  }\n}\nconst cu = li(() => T([]));\nfunction fu() {\n  const a = cu();\n  return {\n    add(t) {\n      const e = a.value[0];\n      t !== e && (e == null || e.pause()), a.value = Xo(a.value, t), a.value.unshift(t);\n    },\n    remove(t) {\n      var e;\n      a.value = Xo(a.value, t), (e = a.value[0]) == null || e.resume();\n    }\n  };\n}\nfunction Xo(a, t) {\n  const e = [...a], n = e.indexOf(t);\n  return n !== -1 && e.splice(n, 1), e;\n}\nfunction pu(a) {\n  return a.filter((t) => t.tagName !== \"A\");\n}\nconst Za = /* @__PURE__ */ x({\n  __name: \"FocusScope\",\n  props: {\n    loop: { type: Boolean, default: !1 },\n    trapped: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"mountAutoFocus\", \"unmountAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { currentRef: l, currentElement: s } = R(), r = T(null), i = fu(), u = Fa({\n      paused: !1,\n      pause() {\n        this.paused = !0;\n      },\n      resume() {\n        this.paused = !1;\n      }\n    });\n    Ce((c) => {\n      if (!Je)\n        return;\n      const f = s.value;\n      if (!e.trapped)\n        return;\n      function v(_) {\n        if (u.paused || !f)\n          return;\n        const C = _.target;\n        f.contains(C) ? r.value = C : pt(r.value, { select: !0 });\n      }\n      function p(_) {\n        if (u.paused || !f)\n          return;\n        const C = _.relatedTarget;\n        C !== null && (f.contains(C) || pt(r.value, { select: !0 }));\n      }\n      function g(_) {\n        f.contains(r.value) || pt(f);\n      }\n      document.addEventListener(\"focusin\", v), document.addEventListener(\"focusout\", p);\n      const m = new MutationObserver(g);\n      f && m.observe(f, { childList: !0, subtree: !0 }), c(() => {\n        document.removeEventListener(\"focusin\", v), document.removeEventListener(\"focusout\", p), m.disconnect();\n      });\n    }), Ce(async (c) => {\n      const f = s.value;\n      if (await oe(), !f)\n        return;\n      i.add(u);\n      const v = me();\n      if (!f.contains(v)) {\n        const g = new CustomEvent(xn, qo);\n        f.addEventListener(xn, (m) => n(\"mountAutoFocus\", m)), f.dispatchEvent(g), g.defaultPrevented || (Ma(pu(eo(f)), {\n          select: !0\n        }), me() === v && pt(f));\n      }\n      c(() => {\n        f.removeEventListener(xn, (_) => n(\"mountAutoFocus\", _));\n        const g = new CustomEvent(Sn, qo), m = (_) => {\n          n(\"unmountAutoFocus\", _);\n        };\n        f.addEventListener(Sn, m), f.dispatchEvent(g), setTimeout(() => {\n          g.defaultPrevented || pt(v ?? document.body, { select: !0 }), f.removeEventListener(Sn, m), i.remove(u);\n        }, 0);\n      });\n    });\n    function d(c) {\n      if (!e.loop && !e.trapped || u.paused)\n        return;\n      const f = c.key === \"Tab\" && !c.altKey && !c.ctrlKey && !c.metaKey, v = me();\n      if (f && v) {\n        const p = c.currentTarget, [g, m] = iu(p);\n        g && m ? !c.shiftKey && v === m ? (c.preventDefault(), e.loop && pt(g, { select: !0 })) : c.shiftKey && v === g && (c.preventDefault(), e.loop && pt(m, { select: !0 })) : v === p && c.preventDefault();\n      }\n    }\n    return (c, f) => (b(), S(o(O), {\n      ref_key: \"currentRef\",\n      ref: l,\n      tabindex: \"-1\",\n      \"as-child\": c.asChild,\n      as: c.as,\n      onKeydown: d\n    }, {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), vu = \"menu.itemSelect\", Bn = [\"Enter\", \" \"], mu = [\"ArrowDown\", \"PageUp\", \"Home\"], ql = [\"ArrowUp\", \"PageDown\", \"End\"], hu = [...mu, ...ql], yu = {\n  ltr: [...Bn, \"ArrowRight\"],\n  rtl: [...Bn, \"ArrowLeft\"]\n}, gu = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nfunction to(a) {\n  return a ? \"open\" : \"closed\";\n}\nfunction La(a) {\n  return a === \"indeterminate\";\n}\nfunction ao(a) {\n  return La(a) ? \"indeterminate\" : a ? \"checked\" : \"unchecked\";\n}\nfunction In(a) {\n  const t = me();\n  for (const e of a)\n    if (e === t || (e.focus(), me() !== t))\n      return;\n}\nfunction bu(a, t) {\n  const { x: e, y: n } = a;\n  let l = !1;\n  for (let s = 0, r = t.length - 1; s < t.length; r = s++) {\n    const i = t[s].x, u = t[s].y, d = t[r].x, c = t[r].y;\n    u > n != c > n && e < (d - i) * (n - u) / (c - u) + i && (l = !l);\n  }\n  return l;\n}\nfunction Cu(a, t) {\n  if (!t)\n    return !1;\n  const e = { x: a.clientX, y: a.clientY };\n  return bu(e, t);\n}\nfunction da(a) {\n  return a.pointerType === \"mouse\";\n}\nconst wu = \"DialogTitle\", _u = \"DialogContent\";\nfunction xu({\n  titleName: a = wu,\n  contentName: t = _u,\n  componentLink: e = \"dialog.html#title\",\n  titleId: n,\n  descriptionId: l,\n  contentElement: s\n}) {\n  const r = `Warning: \\`${t}\\` requires a \\`${a}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${a}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://www.radix-vue.com/components/${e}`, i = `Warning: Missing \\`Description\\` or \\`aria-describedby=\"undefined\"\\` for ${t}.`;\n  le(() => {\n    var c;\n    document.getElementById(n) || console.warn(r);\n    const d = (c = s.value) == null ? void 0 : c.getAttribute(\"aria-describedby\");\n    l && d && (document.getElementById(l) || console.warn(i));\n  });\n}\nconst Yl = /* @__PURE__ */ x({\n  __name: \"DialogContentImpl\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ot(), { forwardRef: s, currentElement: r } = R();\n    return l.titleId || (l.titleId = ge(void 0, \"radix-vue-dialog-title\")), l.descriptionId || (l.descriptionId = ge(void 0, \"radix-vue-dialog-description\")), le(() => {\n      l.contentElement = r, me() !== document.body && (l.triggerElement.value = me());\n    }), process.env.NODE_ENV !== \"production\" && xu({\n      titleName: \"DialogTitle\",\n      contentName: \"DialogContent\",\n      componentLink: \"dialog.html#title\",\n      titleId: l.titleId,\n      descriptionId: l.descriptionId,\n      contentElement: r\n    }), (i, u) => (b(), S(o(Za), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: e.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => n(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => n(\"closeAutoFocus\", d))\n    }, {\n      default: y(() => [\n        q(o(Ct), k({\n          id: o(l).contentId,\n          ref: o(s),\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          role: \"dialog\",\n          \"aria-describedby\": o(l).descriptionId,\n          \"aria-labelledby\": o(l).titleId,\n          \"data-state\": o(to)(o(l).open.value)\n        }, i.$attrs, {\n          onDismiss: u[0] || (u[0] = (d) => o(l).onOpenChange(!1)),\n          onEscapeKeyDown: u[1] || (u[1] = (d) => n(\"escapeKeyDown\", d)),\n          onFocusOutside: u[2] || (u[2] = (d) => n(\"focusOutside\", d)),\n          onInteractOutside: u[3] || (u[3] = (d) => n(\"interactOutside\", d)),\n          onPointerDownOutside: u[4] || (u[4] = (d) => n(\"pointerDownOutside\", d))\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"as\", \"as-child\", \"disable-outside-pointer-events\", \"aria-describedby\", \"aria-labelledby\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), Su = /* @__PURE__ */ x({\n  __name: \"DialogContentModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ot(), s = Te(n), { forwardRef: r, currentElement: i } = R();\n    return ga(i), (u, d) => (b(), S(Yl, k({ ...e, ...o(s) }, {\n      ref: o(r),\n      \"trap-focus\": o(l).open.value,\n      \"disable-outside-pointer-events\": !0,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var f;\n        c.defaultPrevented || (c.preventDefault(), (f = o(l).triggerElement.value) == null || f.focus());\n      }),\n      onPointerDownOutside: d[1] || (d[1] = (c) => {\n        const f = c.detail.originalEvent, v = f.button === 0 && f.ctrlKey === !0;\n        (f.button === 2 || v) && c.preventDefault();\n      }),\n      onFocusOutside: d[2] || (d[2] = (c) => {\n        c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), Eu = /* @__PURE__ */ x({\n  __name: \"DialogContentNonModal\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    R();\n    const s = ot(), r = T(!1), i = T(!1);\n    return (u, d) => (b(), S(Yl, k({ ...e, ...o(l) }, {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var f;\n        c.defaultPrevented || (r.value || (f = o(s).triggerElement.value) == null || f.focus(), c.preventDefault()), r.value = !1, i.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = (c) => {\n        var p;\n        c.defaultPrevented || (r.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (i.value = !0));\n        const f = c.target;\n        ((p = o(s).triggerElement.value) == null ? void 0 : p.contains(f)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && i.value && c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pu = /* @__PURE__ */ x({\n  __name: \"DialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ot(), s = Te(n), { forwardRef: r } = R();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        o(l).modal.value ? (b(), S(Su, k({\n          key: 0,\n          ref: o(r)\n        }, { ...e, ...o(s), ...i.$attrs }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), S(Eu, k({\n          key: 1,\n          ref: o(r)\n        }, { ...e, ...o(s), ...i.$attrs }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Du = /* @__PURE__ */ x({\n  __name: \"DialogOverlayImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = ot();\n    return ya(!0), R(), (e, n) => (b(), S(o(O), {\n      as: e.as,\n      \"as-child\": e.asChild,\n      \"data-state\": o(t).open.value ? \"open\" : \"closed\",\n      style: { \"pointer-events\": \"auto\" }\n    }, {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-state\"]));\n  }\n}), $u = /* @__PURE__ */ x({\n  __name: \"DialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = ot(), { forwardRef: e } = R();\n    return (n, l) => {\n      var s;\n      return (s = o(t)) != null && s.modal.value ? (b(), S(o(Pe), {\n        key: 0,\n        present: n.forceMount || o(t).open.value\n      }, {\n        default: y(() => [\n          q(Du, k(n.$attrs, {\n            ref: o(e),\n            as: n.as,\n            \"as-child\": n.asChild\n          }), {\n            default: y(() => [\n              w(n.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])) : ce(\"\", !0);\n    };\n  }\n}), Xl = /* @__PURE__ */ x({\n  __name: \"DialogClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = ot();\n    return (n, l) => (b(), S(o(O), k(t, {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), Bu = /* @__PURE__ */ x({\n  __name: \"DialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(a) {\n    const t = a, e = ot();\n    return R(), (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).titleId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Iu = /* @__PURE__ */ x({\n  __name: \"DialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = ot();\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).descriptionId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Tv = /* @__PURE__ */ x({\n  __name: \"AlertDialogRoot\",\n  props: {\n    open: { type: Boolean },\n    defaultOpen: { type: Boolean }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    return R(), (s, r) => (b(), S(o(nu), k(o(l), { modal: !0 }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rv = /* @__PURE__ */ x({\n  __name: \"AlertDialogTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(ou), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Av = /* @__PURE__ */ x({\n  __name: \"AlertDialogPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Tu, Ru] = te(\"AlertDialogContent\"), Ov = /* @__PURE__ */ x({\n  __name: \"AlertDialogContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    R();\n    const s = T();\n    return Ru({\n      onCancelElementChange: (r) => {\n        s.value = r;\n      }\n    }), (r, i) => (b(), S(o(Pu), k({ ...e, ...o(l) }, {\n      role: \"alertdialog\",\n      onPointerDownOutside: i[0] || (i[0] = ue(() => {\n      }, [\"prevent\"])),\n      onInteractOutside: i[1] || (i[1] = ue(() => {\n      }, [\"prevent\"])),\n      onOpenAutoFocus: i[2] || (i[2] = () => {\n        oe(() => {\n          var u;\n          (u = s.value) == null || u.focus({\n            preventScroll: !0\n          });\n        });\n      })\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), kv = /* @__PURE__ */ x({\n  __name: \"AlertDialogOverlay\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o($u), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Mv = /* @__PURE__ */ x({\n  __name: \"AlertDialogCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Tu(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.onCancelElementChange(l.value);\n    }), (s, r) => (b(), S(o(Xl), k(t, { ref: o(n) }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vv = /* @__PURE__ */ x({\n  __name: \"AlertDialogTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h2\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Bu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Fv = /* @__PURE__ */ x({\n  __name: \"AlertDialogDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Iu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nv = /* @__PURE__ */ x({\n  __name: \"AlertDialogAction\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Xl), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Lv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"AspectRatio\",\n  props: {\n    ratio: { default: 1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = B(() => 1 / t.ratio * 100);\n    return (l, s) => (b(), ve(\"div\", {\n      style: Me(`position: relative; width: 100%; padding-bottom: ${n.value}%`),\n      \"data-radix-aspect-ratio-wrapper\": \"\"\n    }, [\n      q(o(O), k({\n        ref: o(e),\n        \"as-child\": l.asChild,\n        as: l.as,\n        style: { position: \"absolute\", inset: \"0px\" }\n      }, l.$attrs), {\n        default: y(() => [\n          w(l.$slots, \"default\", { aspect: n.value })\n        ]),\n        _: 3\n      }, 16, [\"as-child\", \"as\"])\n    ], 4));\n  }\n}), [Zl, Au] = te(\"AvatarRoot\"), zv = /* @__PURE__ */ x({\n  __name: \"AvatarRoot\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return R(), Au({\n      imageLoadingStatus: T(\"loading\")\n    }), (t, e) => (b(), S(o(O), {\n      \"as-child\": t.asChild,\n      as: t.as\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n});\nfunction Ou(a, t) {\n  const e = T(\"idle\"), n = T(!1), l = (s) => () => {\n    n.value && (e.value = s);\n  };\n  return le(() => {\n    n.value = !0, ee([() => a.value, () => t == null ? void 0 : t.value], ([s, r]) => {\n      if (!s)\n        e.value = \"error\";\n      else {\n        const i = new window.Image();\n        e.value = \"loading\", i.onload = l(\"loaded\"), i.onerror = l(\"error\"), i.src = s, r && (i.referrerPolicy = r);\n      }\n    }, { immediate: !0 });\n  }), Be(() => {\n    n.value = !1;\n  }), e;\n}\nconst Kv = /* @__PURE__ */ x({\n  __name: \"AvatarImage\",\n  props: {\n    src: {},\n    referrerPolicy: {},\n    asChild: { type: Boolean },\n    as: { default: \"img\" }\n  },\n  emits: [\"loadingStatusChange\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { src: l, referrerPolicy: s } = ae(e);\n    R();\n    const r = Zl(), i = Ou(l, s);\n    return ee(\n      i,\n      (u) => {\n        n(\"loadingStatusChange\", u), u !== \"idle\" && (r.imageLoadingStatus.value = u);\n      },\n      { immediate: !0 }\n    ), (u, d) => ja((b(), S(o(O), {\n      role: \"img\",\n      \"as-child\": u.asChild,\n      as: u.as,\n      src: o(l),\n      \"referrer-policy\": o(s)\n    }, {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"src\", \"referrer-policy\"])), [\n      [zn, o(i) === \"loaded\"]\n    ]);\n  }\n}), Hv = /* @__PURE__ */ x({\n  __name: \"AvatarFallback\",\n  props: {\n    delayMs: { default: 0 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Zl();\n    R();\n    const n = T(!1);\n    let l;\n    return ee(e.imageLoadingStatus, (s) => {\n      s === \"loading\" && (n.value = !1, t.delayMs ? l = setTimeout(() => {\n        n.value = !0, clearTimeout(l);\n      }, t.delayMs) : n.value = !0);\n    }, { immediate: !0 }), (s, r) => n.value && o(e).imageLoadingStatus.value !== \"loaded\" ? (b(), S(o(O), {\n      key: 0,\n      \"as-child\": s.asChild,\n      as: s.as\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"])) : ce(\"\", !0);\n  }\n});\nfunction ku(a) {\n  function t(n) {\n    return Array.isArray(a.date.value) ? a.date.value.some((l) => Oe(l, n)) : a.date.value ? Oe(a.date.value, n) : !1;\n  }\n  const e = B(\n    () => {\n      var n, l, s, r;\n      if (Array.isArray(a.date.value)) {\n        if (!a.date.value.length)\n          return !1;\n        for (const i of a.date.value)\n          if ((n = a.isDateDisabled) != null && n.call(a, i) || (l = a.isDateUnavailable) != null && l.call(a, i))\n            return !0;\n      } else {\n        if (!a.date.value)\n          return !1;\n        if ((s = a.isDateDisabled) != null && s.call(a, a.date.value) || (r = a.isDateUnavailable) != null && r.call(a, a.date.value))\n          return !0;\n      }\n      return !1;\n    }\n  );\n  return {\n    isDateSelected: t,\n    isInvalid: e\n  };\n}\nfunction Mu(a, t) {\n  const e = t(a), n = e.compare(a), l = {};\n  return n >= 7 && (l.day = 1), n >= Ze(a) && (l.month = 1), e.set({ ...l });\n}\nfunction Vu(a, t) {\n  const e = t(a), n = a.compare(e), l = {};\n  return n >= 7 && (l.day = 35), n >= Ze(a) && (l.month = 13), e.set({ ...l });\n}\nfunction Fu(a, t) {\n  return t(a);\n}\nfunction Nu(a, t) {\n  return t(a);\n}\nfunction Jl(a) {\n  const t = qn(a.locale.value), e = B(() => {\n    const m = {\n      calendar: a.placeholder.value.calendar.identifier\n    };\n    return a.placeholder.value.calendar.identifier === \"gregory\" && a.placeholder.value.era === \"BC\" && (m.era = \"short\"), m;\n  }), n = T(Pt({\n    dateObj: a.placeholder.value,\n    weekStartsOn: a.weekStartsOn.value,\n    locale: a.locale.value,\n    fixedWeeks: a.fixedWeeks.value,\n    numberOfMonths: a.numberOfMonths.value\n  })), l = B(() => n.value.map((m) => m.value));\n  function s(m) {\n    return !l.value.some((_) => Ko(m, _));\n  }\n  const r = (m = \"month\", _) => {\n    if (!a.maxValue.value || !n.value.length)\n      return !1;\n    if (a.disabled.value)\n      return !0;\n    const C = n.value[n.value.length - 1].value;\n    if (_ || a.nextPage.value) {\n      const h = Mu(C, _ || a.nextPage.value);\n      return Pa(h, a.maxValue.value);\n    }\n    if (m === \"year\") {\n      const h = C.add({ years: 1 }).set({ day: 1, month: 1 });\n      return Pa(h, a.maxValue.value);\n    }\n    const $ = C.add({ months: 1 }).set({ day: 1 });\n    return Pa($, a.maxValue.value);\n  }, i = (m = \"month\", _) => {\n    if (!a.minValue.value || !n.value.length)\n      return !1;\n    if (a.disabled.value)\n      return !0;\n    const C = n.value[0].value;\n    if (_ || a.prevPage.value) {\n      const h = Vu(C, _ || a.prevPage.value);\n      return Ke(h, a.minValue.value);\n    }\n    if (m === \"year\") {\n      const h = C.subtract({ years: 1 }).set({ day: 35, month: 13 });\n      return Ke(h, a.minValue.value);\n    }\n    const $ = C.subtract({ months: 1 }).set({ day: 35 });\n    return Ke($, a.minValue.value);\n  };\n  function u(m) {\n    var _;\n    return !!((_ = a.isDateDisabled) != null && _.call(a, m) || a.disabled.value || a.maxValue.value && Pa(m, a.maxValue.value) || a.minValue.value && Ke(m, a.minValue.value));\n  }\n  const d = (m) => {\n    var _;\n    return !!((_ = a.isDateUnavailable) != null && _.call(a, m));\n  }, c = B(() => n.value.length ? n.value[0].rows[0].map((m) => t.dayOfWeek(ze(m), a.weekdayFormat.value)) : []), f = (m = \"month\", _) => {\n    const C = n.value[0].value;\n    if (_ || a.nextPage.value) {\n      const E = Fu(C, _ || a.nextPage.value), P = Pt({\n        dateObj: E,\n        weekStartsOn: a.weekStartsOn.value,\n        locale: a.locale.value,\n        fixedWeeks: a.fixedWeeks.value,\n        numberOfMonths: a.numberOfMonths.value\n      });\n      n.value = P;\n      const D = {};\n      if (!_) {\n        const I = P[0].value.compare(C);\n        I >= Ze(C) && (D.day = 1), I >= 365 && (D.month = 1);\n      }\n      a.placeholder.value = P[0].value.set({ ...D });\n      return;\n    }\n    const $ = m === \"month\" ? C.add({ months: a.pagedNavigation.value ? a.numberOfMonths.value : 1 }) : C.add({ years: 1 }), h = Pt({\n      dateObj: $,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n    n.value = h, a.placeholder.value = h[0].value.set({ day: 1 });\n  }, v = (m = \"month\", _) => {\n    const C = n.value[0].value;\n    if (_ || a.prevPage.value) {\n      const E = Nu(C, _ || a.prevPage.value), P = Pt({\n        dateObj: E,\n        weekStartsOn: a.weekStartsOn.value,\n        locale: a.locale.value,\n        fixedWeeks: a.fixedWeeks.value,\n        numberOfMonths: a.numberOfMonths.value\n      });\n      n.value = P;\n      const D = {};\n      if (!_) {\n        const I = C.compare(P[0].value);\n        I >= Ze(C) && (D.day = 1), I >= 365 && (D.month = 1);\n      }\n      a.placeholder.value = P[0].value.set({ ...D });\n      return;\n    }\n    const $ = m === \"month\" ? C.subtract({ months: a.pagedNavigation.value ? a.numberOfMonths.value : 1 }) : C.subtract({ years: 1 }), h = Pt({\n      dateObj: $,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n    n.value = h, a.placeholder.value = h[0].value.set({ day: 1 });\n  };\n  ee(a.placeholder, (m) => {\n    l.value.some((_) => Ko(_, m)) || (n.value = Pt({\n      dateObj: m,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    }));\n  }), ee([a.locale, a.weekStartsOn, a.fixedWeeks, a.numberOfMonths], () => {\n    n.value = Pt({\n      dateObj: a.placeholder.value,\n      weekStartsOn: a.weekStartsOn.value,\n      locale: a.locale.value,\n      fixedWeeks: a.fixedWeeks.value,\n      numberOfMonths: a.numberOfMonths.value\n    });\n  });\n  const p = B(() => {\n    if (!n.value.length)\n      return \"\";\n    if (a.locale.value !== t.getLocale() && t.setLocale(a.locale.value), n.value.length === 1) {\n      const D = n.value[0].value;\n      return `${t.fullMonthAndYear(ze(D), e.value)}`;\n    }\n    const m = ze(n.value[0].value), _ = ze(n.value[n.value.length - 1].value), C = t.fullMonth(m, e.value), $ = t.fullMonth(_, e.value), h = t.fullYear(m, e.value), E = t.fullYear(_, e.value);\n    return h === E ? `${C} - ${$} ${E}` : `${C} ${h} - ${$} ${E}`;\n  }), g = B(() => `${a.calendarLabel.value ?? \"Event Date\"}, ${p.value}`);\n  return {\n    isDateDisabled: u,\n    isDateUnavailable: d,\n    isNextButtonDisabled: r,\n    isPrevButtonDisabled: i,\n    grid: n,\n    weekdays: c,\n    visibleView: l,\n    isOutsideVisibleView: s,\n    formatter: t,\n    nextPage: f,\n    prevPage: v,\n    headingValue: p,\n    fullCalendarLabel: g\n  };\n}\nconst Lu = { style: { border: \"0px\", clip: \"rect(0px, 0px, 0px, 0px)\", \"clip-path\": \"inset(50%)\", height: \"1px\", margin: \"-1px\", overflow: \"hidden\", padding: \"0px\", position: \"absolute\", \"white-space\": \"nowrap\", width: \"1px\" } }, zu = {\n  role: \"heading\",\n  \"aria-level\": \"2\"\n}, [Xt, Ku] = te(\"CalendarRoot\"), Hu = /* @__PURE__ */ x({\n  __name: \"CalendarRoot\",\n  props: {\n    modelValue: {},\n    multiple: { type: Boolean, default: !1 },\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    preventDeselect: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    calendarLabel: {},\n    fixedWeeks: { type: Boolean, default: !1 },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    numberOfMonths: { default: 1 },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    initialFocus: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    dir: {},\n    nextPage: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      initialFocus: i,\n      pagedNavigation: u,\n      weekStartsOn: d,\n      weekdayFormat: c,\n      fixedWeeks: f,\n      multiple: v,\n      minValue: p,\n      maxValue: g,\n      numberOfMonths: m,\n      preventDeselect: _,\n      isDateDisabled: C,\n      isDateUnavailable: $,\n      calendarLabel: h,\n      defaultValue: E,\n      nextPage: P,\n      prevPage: D,\n      dir: I\n    } = ae(e), { primitiveElement: M, currentElement: V } = Re(), A = we(I), F = ne(e, \"modelValue\", n, {\n      defaultValue: E.value,\n      passive: e.modelValue === void 0\n    }), j = Yt({\n      defaultPlaceholder: e.placeholder,\n      defaultValue: F.value,\n      locale: e.locale\n    }), H = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? j.copy(),\n      passive: e.placeholder === void 0\n    });\n    function Q(de) {\n      H.value = de.copy();\n    }\n    const {\n      fullCalendarLabel: G,\n      headingValue: J,\n      isDateDisabled: z,\n      isDateUnavailable: K,\n      isNextButtonDisabled: L,\n      isPrevButtonDisabled: N,\n      weekdays: Z,\n      isOutsideVisibleView: Y,\n      nextPage: re,\n      prevPage: X,\n      formatter: se,\n      grid: fe\n    } = Jl({\n      locale: l,\n      placeholder: H,\n      weekStartsOn: d,\n      fixedWeeks: f,\n      numberOfMonths: m,\n      minValue: p,\n      maxValue: g,\n      disabled: s,\n      weekdayFormat: c,\n      pagedNavigation: u,\n      isDateDisabled: C.value,\n      isDateUnavailable: $.value,\n      calendarLabel: h,\n      nextPage: P,\n      prevPage: D\n    }), {\n      isInvalid: xe,\n      isDateSelected: Ee\n    } = ku({\n      date: F,\n      isDateDisabled: z,\n      isDateUnavailable: K\n    });\n    ee(F, (de) => {\n      if (Array.isArray(de) && de.length) {\n        const Ie = de[de.length - 1];\n        Ie && !ke(H.value, Ie) && Q(Ie);\n      } else !Array.isArray(de) && de && !ke(H.value, de) && Q(de);\n    });\n    function be(de) {\n      if (v.value) {\n        if (!F.value)\n          F.value = [de.copy()];\n        else if (Array.isArray(F.value)) {\n          if (F.value.findIndex((Ae) => Oe(Ae, de)) === -1)\n            F.value = [...F.value, de];\n          else if (!_.value) {\n            const Ae = F.value.filter((We) => !Oe(We, de));\n            if (!Ae.length) {\n              H.value = de.copy(), F.value = void 0;\n              return;\n            }\n            F.value = Ae.map((We) => We.copy());\n          }\n        }\n      } else {\n        if (!F.value) {\n          F.value = de.copy();\n          return;\n        }\n        !_.value && ke(F.value, de) ? (H.value = de.copy(), F.value = void 0) : F.value = de.copy();\n      }\n    }\n    return le(() => {\n      i.value && Pl(V.value);\n    }), Ku({\n      isDateUnavailable: K,\n      dir: A,\n      isDateDisabled: z,\n      locale: l,\n      formatter: se,\n      modelValue: F,\n      placeholder: H,\n      disabled: s,\n      initialFocus: i,\n      pagedNavigation: u,\n      weekStartsOn: d,\n      weekdayFormat: c,\n      fixedWeeks: f,\n      multiple: v,\n      numberOfMonths: m,\n      readonly: r,\n      preventDeselect: _,\n      fullCalendarLabel: G,\n      headingValue: J,\n      isInvalid: xe,\n      isDateSelected: Ee,\n      isNextButtonDisabled: L,\n      isPrevButtonDisabled: N,\n      isOutsideVisibleView: Y,\n      nextPage: re,\n      prevPage: X,\n      parentElement: V,\n      onPlaceholderChange: Q,\n      onDateChange: be\n    }), (de, Ie) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: M,\n      as: de.as,\n      \"as-child\": de.asChild,\n      role: \"application\",\n      \"aria-label\": o(G),\n      \"data-readonly\": o(r) ? \"\" : void 0,\n      \"data-disabled\": o(s) ? \"\" : void 0,\n      \"data-invalid\": o(xe) ? \"\" : void 0,\n      dir: o(A)\n    }, {\n      default: y(() => [\n        w(de.$slots, \"default\", {\n          date: o(H),\n          grid: o(fe),\n          weekDays: o(Z),\n          weekStartsOn: o(d),\n          locale: o(l),\n          fixedWeeks: o(f)\n        }),\n        Ye(\"div\", Lu, [\n          Ye(\"div\", zu, De(o(G)), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-label\", \"data-readonly\", \"data-disabled\", \"data-invalid\", \"dir\"]));\n  }\n}), Wu = /* @__PURE__ */ x({\n  __name: \"CalendarHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ju = /* @__PURE__ */ x({\n  __name: \"CalendarHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = Xt();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {\n          headingValue: o(e).headingValue.value\n        }, () => [\n          ye(De(o(e).headingValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-disabled\"]));\n  }\n}), Uu = /* @__PURE__ */ x({\n  __name: \"CalendarGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"table\" }\n  },\n  setup(a) {\n    const t = a, e = Xt(), n = B(() => e.disabled.value ? !0 : void 0), l = B(() => e.readonly.value ? !0 : void 0);\n    return (s, r) => (b(), S(o(O), k(t, {\n      tabindex: \"-1\",\n      role: \"grid\",\n      \"aria-readonly\": l.value,\n      \"aria-disabled\": n.value,\n      \"data-readonly\": l.value && \"\",\n      \"data-disabled\": n.value && \"\"\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-readonly\", \"aria-disabled\", \"data-readonly\", \"data-disabled\"]));\n  }\n}), Gu = /* @__PURE__ */ x({\n  __name: \"CalendarCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: { default: \"td\" }\n  },\n  setup(a) {\n    const t = Xt();\n    return (e, n) => {\n      var l, s;\n      return b(), S(o(O), {\n        as: e.as,\n        \"as-child\": e.asChild,\n        role: \"gridcell\",\n        \"aria-selected\": o(t).isDateSelected(e.date) ? !0 : void 0,\n        \"aria-disabled\": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),\n        \"data-disabled\": o(t).isDateDisabled(e.date) ? \"\" : void 0\n      }, {\n        default: y(() => [\n          w(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"aria-selected\", \"aria-disabled\", \"data-disabled\"]);\n    };\n  }\n}), qu = /* @__PURE__ */ x({\n  __name: \"CalendarHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"th\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Yu = /* @__PURE__ */ x({\n  __name: \"CalendarNext\",\n  props: {\n    step: { default: \"month\" },\n    nextPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isNextButtonDisabled(t.step, t.nextPage)), n = Xt();\n    return (l, s) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"aria-label\": \"Next page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).nextPage(t.step, t.nextPage))\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Xu = /* @__PURE__ */ x({\n  __name: \"CalendarPrev\",\n  props: {\n    step: { default: \"month\" },\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isPrevButtonDisabled(t.step, t.prevPage)), n = Xt();\n    return (l, s) => (b(), S(o(O), {\n      \"aria-label\": \"Previous page\",\n      as: t.as,\n      \"as-child\": t.asChild,\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).prevPage(t.step, t.prevPage))\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Zu = /* @__PURE__ */ x({\n  __name: \"CalendarGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"thead\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ju = /* @__PURE__ */ x({\n  __name: \"CalendarGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tbody\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qu = /* @__PURE__ */ x({\n  __name: \"CalendarGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tr\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ed = /* @__PURE__ */ x({\n  __name: \"CalendarCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = nt(), n = Xt(), { primitiveElement: l, currentElement: s } = Re(), r = B(() => t.day.day.toLocaleString(n.locale.value)), i = B(() => n.formatter.custom(ze(t.day), {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      year: \"numeric\"\n    })), u = B(() => n.isDateDisabled(t.day)), d = B(\n      () => {\n        var h;\n        return (h = n.isDateUnavailable) == null ? void 0 : h.call(n, t.day);\n      }\n    ), c = B(() => bl(t.day, Hn())), f = B(() => !Cl(t.day, t.month)), v = B(\n      () => n.isOutsideVisibleView(t.day)\n    ), p = B(() => !n.disabled.value && Oe(t.day, n.placeholder.value)), g = B(() => n.isDateSelected(t.day)), m = \"[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-view]):not([data-outside-visible-view])\";\n    function _(h) {\n      var E;\n      n.readonly.value || n.isDateDisabled(h) || (E = n.isDateUnavailable) != null && E.call(n, h) || n.onDateChange(h);\n    }\n    function C() {\n      _(t.day);\n    }\n    function $(h) {\n      h.preventDefault(), h.stopPropagation();\n      const E = n.parentElement.value, P = E ? Array.from(E.querySelectorAll(m)) : [];\n      let I = P.indexOf(s.value);\n      const M = 7, V = n.dir.value === \"rtl\" ? -1 : 1;\n      switch (h.code) {\n        case e.ARROW_RIGHT:\n          I += V;\n          break;\n        case e.ARROW_LEFT:\n          I -= V;\n          break;\n        case e.ARROW_UP:\n          I -= M;\n          break;\n        case e.ARROW_DOWN:\n          I += M;\n          break;\n        case e.ENTER:\n        case e.SPACE_CODE:\n          _(t.day);\n          return;\n        default:\n          return;\n      }\n      if (I >= 0 && I < P.length) {\n        P[I].focus();\n        return;\n      }\n      if (I < 0) {\n        if (n.isPrevButtonDisabled(\"month\"))\n          return;\n        n.prevPage(), oe(() => {\n          const A = E ? Array.from(E.querySelectorAll(m)) : [];\n          if (!n.pagedNavigation.value) {\n            const F = Ze(n.placeholder.value);\n            A[F - Math.abs(I)].focus();\n            return;\n          }\n          A[A.length - Math.abs(I)].focus();\n        });\n        return;\n      }\n      if (I >= P.length) {\n        if (n.isNextButtonDisabled(\"month\"))\n          return;\n        n.nextPage(), oe(() => {\n          const A = E ? Array.from(E.querySelectorAll(m)) : [];\n          if (!n.pagedNavigation.value) {\n            const F = Ze(n.placeholder.value.add({ months: n.numberOfMonths.value - 1 }));\n            A[A.length - F + I - P.length].focus();\n            return;\n          }\n          A[I - P.length].focus();\n        });\n      }\n    }\n    return (h, E) => (b(), S(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: l\n    }, t, {\n      role: \"button\",\n      \"aria-label\": i.value,\n      \"data-radix-vue-calendar-cell-trigger\": \"\",\n      \"aria-disabled\": u.value || d.value ? !0 : void 0,\n      \"data-selected\": g.value ? !0 : void 0,\n      \"data-value\": h.day.toString(),\n      \"data-disabled\": u.value ? \"\" : void 0,\n      \"data-unavailable\": d.value ? \"\" : void 0,\n      \"data-today\": c.value ? \"\" : void 0,\n      \"data-outside-view\": f.value ? \"\" : void 0,\n      \"data-outside-visible-view\": v.value ? \"\" : void 0,\n      \"data-focused\": p.value ? \"\" : void 0,\n      tabindex: p.value ? 0 : f.value || u.value ? void 0 : -1,\n      onClick: C,\n      onKeydown: [\n        ie($, [\"up\", \"down\", \"left\", \"right\", \"space\", \"enter\"]),\n        E[0] || (E[0] = ie(ue(() => {\n        }, [\"prevent\"]), [\"enter\"]))\n      ]\n    }), {\n      default: y(() => [\n        w(h.$slots, \"default\", { dayValue: r.value }, () => [\n          ye(De(r.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-disabled\", \"data-selected\", \"data-value\", \"data-disabled\", \"data-unavailable\", \"data-today\", \"data-outside-view\", \"data-outside-visible-view\", \"data-focused\", \"tabindex\"]));\n  }\n});\nfunction za(a) {\n  return a === \"indeterminate\";\n}\nfunction Ql(a) {\n  return za(a) ? \"indeterminate\" : a ? \"checked\" : \"unchecked\";\n}\nconst td = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], [ad, nd] = te(\"CheckboxRoot\"), Wv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"CheckboxRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: [Boolean, String], default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    value: { default: \"on\" },\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ae(e), s = ne(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    }), { forwardRef: r, currentElement: i } = R(), u = at(i), d = B(() => {\n      var c;\n      return e.id && i.value ? (c = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : c.innerText : void 0;\n    });\n    return nd({\n      disabled: l,\n      state: s\n    }), (c, f) => (b(), ve(_e, null, [\n      q(o(O), k(c.$attrs, {\n        id: c.id,\n        ref: o(r),\n        role: \"checkbox\",\n        \"as-child\": e.asChild,\n        as: c.as,\n        type: c.as === \"button\" ? \"button\" : void 0,\n        \"aria-checked\": o(za)(o(s)) ? \"mixed\" : o(s),\n        \"aria-required\": e.required,\n        \"aria-label\": c.$attrs[\"aria-label\"] || d.value,\n        \"data-state\": o(Ql)(o(s)),\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        disabled: o(l),\n        onKeydown: ie(ue(() => {\n        }, [\"prevent\"]), [\"enter\"]),\n        onClick: f[0] || (f[0] = (v) => s.value = o(za)(o(s)) ? !0 : !o(s))\n      }), {\n        default: y(() => [\n          w(c.$slots, \"default\", { checked: o(s) })\n        ]),\n        _: 3\n      }, 16, [\"id\", \"as-child\", \"as\", \"type\", \"aria-checked\", \"aria-required\", \"aria-label\", \"data-state\", \"data-disabled\", \"disabled\", \"onKeydown\"]),\n      o(u) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: c.value,\n        checked: !!o(s),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, td)) : ce(\"\", !0)\n    ], 64));\n  }\n}), jv = /* @__PURE__ */ x({\n  __name: \"CheckboxIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = R(), e = ad();\n    return (n, l) => (b(), S(o(Pe), {\n      present: n.forceMount || o(za)(o(e).state.value) || o(e).state.value === !0\n    }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(t),\n          \"data-state\": o(Ql)(o(e).state.value),\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          style: { pointerEvents: \"none\" },\n          \"as-child\": n.asChild,\n          as: n.as\n        }, n.$attrs), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [es, od] = te(\"PopperRoot\"), kt = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PopperRoot\",\n  setup(a) {\n    const t = T();\n    return od({\n      anchor: t,\n      onAnchorChange: (e) => t.value = e\n    }), (e, n) => w(e.$slots, \"default\");\n  }\n}), Mt = /* @__PURE__ */ x({\n  __name: \"PopperAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = R(), l = es();\n    return Ce(() => {\n      l.onAnchorChange(t.element ?? n.value);\n    }), (s, r) => (b(), S(o(O), {\n      ref: o(e),\n      as: s.as,\n      \"as-child\": s.asChild\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n});\nfunction ld(a) {\n  return a !== null;\n}\nfunction sd(a) {\n  return {\n    name: \"transformOrigin\",\n    options: a,\n    fn(t) {\n      var _, C, $;\n      const { placement: e, rects: n, middlewareData: l } = t, r = ((_ = l.arrow) == null ? void 0 : _.centerOffset) !== 0, i = r ? 0 : a.arrowWidth, u = r ? 0 : a.arrowHeight, [d, c] = Tn(e), f = { start: \"0%\", center: \"50%\", end: \"100%\" }[c], v = (((C = l.arrow) == null ? void 0 : C.x) ?? 0) + i / 2, p = ((($ = l.arrow) == null ? void 0 : $.y) ?? 0) + u / 2;\n      let g = \"\", m = \"\";\n      return d === \"bottom\" ? (g = r ? f : `${v}px`, m = `${-u}px`) : d === \"top\" ? (g = r ? f : `${v}px`, m = `${n.floating.height + u}px`) : d === \"right\" ? (g = `${-u}px`, m = r ? f : `${p}px`) : d === \"left\" && (g = `${n.floating.width + u}px`, m = r ? f : `${p}px`), { data: { x: g, y: m } };\n    }\n  };\n}\nfunction Tn(a) {\n  const [t, e = \"center\"] = a.split(\"-\");\n  return [t, e];\n}\nconst ts = {\n  side: \"bottom\",\n  sideOffset: 0,\n  align: \"center\",\n  alignOffset: 0,\n  arrowPadding: 0,\n  avoidCollisions: !0,\n  collisionBoundary: () => [],\n  collisionPadding: 0,\n  sticky: \"partial\",\n  hideWhenDetached: !1,\n  updatePositionStrategy: \"optimized\",\n  prioritizePosition: !1\n}, [rd, id] = te(\"PopperContent\"), It = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PopperContent\",\n  props: /* @__PURE__ */ yl({\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...ts\n  }),\n  emits: [\"placed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = es(), { forwardRef: s, currentElement: r } = R(), i = T(), u = T(), { width: d, height: c } = Ll(u), f = B(\n      () => e.side + (e.align !== \"center\" ? `-${e.align}` : \"\")\n    ), v = B(() => typeof e.collisionPadding == \"number\" ? e.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...e.collisionPadding }), p = B(() => Array.isArray(e.collisionBoundary) ? e.collisionBoundary : [e.collisionBoundary]), g = B(() => ({\n      padding: v.value,\n      boundary: p.value.filter(ld),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: p.value.length > 0\n    })), m = ni(() => [\n      Mr({\n        mainAxis: e.sideOffset + c.value,\n        alignmentAxis: e.alignOffset\n      }),\n      e.prioritizePosition && e.avoidCollisions && Ho({\n        ...g.value\n      }),\n      e.avoidCollisions && Vr({\n        mainAxis: !0,\n        crossAxis: !!e.prioritizePosition,\n        limiter: e.sticky === \"partial\" ? Fr() : void 0,\n        ...g.value\n      }),\n      !e.prioritizePosition && e.avoidCollisions && Ho({\n        ...g.value\n      }),\n      Nr({\n        ...g.value,\n        apply: ({ elements: A, rects: F, availableWidth: j, availableHeight: H }) => {\n          const { width: Q, height: G } = F.reference, J = A.floating.style;\n          J.setProperty(\n            \"--radix-popper-available-width\",\n            `${j}px`\n          ), J.setProperty(\n            \"--radix-popper-available-height\",\n            `${H}px`\n          ), J.setProperty(\n            \"--radix-popper-anchor-width\",\n            `${Q}px`\n          ), J.setProperty(\n            \"--radix-popper-anchor-height\",\n            `${G}px`\n          );\n        }\n      }),\n      u.value && Lr({ element: u.value, padding: e.arrowPadding }),\n      sd({\n        arrowWidth: d.value,\n        arrowHeight: c.value\n      }),\n      e.hideWhenDetached && zr({ strategy: \"referenceHidden\", ...g.value })\n    ]), { floatingStyles: _, placement: C, isPositioned: $, middlewareData: h } = Or(\n      l.anchor,\n      i,\n      {\n        strategy: \"fixed\",\n        placement: f,\n        whileElementsMounted: (...A) => kr(...A, {\n          animationFrame: e.updatePositionStrategy === \"always\"\n        }),\n        middleware: m\n      }\n    ), E = B(\n      () => Tn(C.value)[0]\n    ), P = B(\n      () => Tn(C.value)[1]\n    );\n    _r(() => {\n      $.value && n(\"placed\");\n    });\n    const D = B(\n      () => {\n        var A;\n        return ((A = h.value.arrow) == null ? void 0 : A.centerOffset) !== 0;\n      }\n    ), I = T(\"\");\n    Ce(() => {\n      r.value && (I.value = window.getComputedStyle(r.value).zIndex);\n    });\n    const M = B(() => {\n      var A;\n      return ((A = h.value.arrow) == null ? void 0 : A.x) ?? 0;\n    }), V = B(() => {\n      var A;\n      return ((A = h.value.arrow) == null ? void 0 : A.y) ?? 0;\n    });\n    return id({\n      placedSide: E,\n      onArrowChange: (A) => u.value = A,\n      arrowX: M,\n      arrowY: V,\n      shouldHideArrow: D\n    }), (A, F) => {\n      var j, H, Q;\n      return b(), ve(\"div\", {\n        ref_key: \"floatingRef\",\n        ref: i,\n        \"data-radix-popper-content-wrapper\": \"\",\n        style: Me({\n          ...o(_),\n          transform: o($) ? o(_).transform : \"translate(0, -200%)\",\n          // keep off the page when measuring\n          minWidth: \"max-content\",\n          zIndex: I.value,\n          \"--radix-popper-transform-origin\": [\n            (j = o(h).transformOrigin) == null ? void 0 : j.x,\n            (H = o(h).transformOrigin) == null ? void 0 : H.y\n          ].join(\" \"),\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...((Q = o(h).hide) == null ? void 0 : Q.referenceHidden) && {\n            visibility: \"hidden\",\n            pointerEvents: \"none\"\n          }\n        })\n      }, [\n        q(o(O), k({ ref: o(s) }, A.$attrs, {\n          \"as-child\": e.asChild,\n          as: A.as,\n          \"data-side\": E.value,\n          \"data-align\": P.value,\n          style: {\n            // if the PopperContent hasn't been placed yet (not all measurements done)\n            // we prevent animations so that users's animation don't kick in too early referring wrong sides\n            animation: o($) ? void 0 : \"none\"\n          }\n        }), {\n          default: y(() => [\n            w(A.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-side\", \"data-align\", \"style\"])\n      ], 4);\n    };\n  }\n}), ud = /* @__PURE__ */ Ye(\"polygon\", { points: \"0,0 30,0 15,10\" }, null, -1), dd = /* @__PURE__ */ x({\n  __name: \"Arrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, {\n      width: e.width,\n      height: e.height,\n      viewBox: e.asChild ? void 0 : \"0 0 30 10\",\n      preserveAspectRatio: e.asChild ? void 0 : \"none\"\n    }), {\n      default: y(() => [\n        w(e.$slots, \"default\", {}, () => [\n          ud\n        ])\n      ]),\n      _: 3\n    }, 16, [\"width\", \"height\", \"viewBox\", \"preserveAspectRatio\"]));\n  }\n}), cd = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n}, Zt = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PopperArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = R(), e = rd(), n = B(() => cd[e.placedSide.value]);\n    return (l, s) => {\n      var r, i, u, d;\n      return b(), ve(\"span\", {\n        ref: (c) => {\n          o(e).onArrowChange(c);\n        },\n        style: Me({\n          position: \"absolute\",\n          left: (r = o(e).arrowX) != null && r.value ? `${(i = o(e).arrowX) == null ? void 0 : i.value}px` : void 0,\n          top: (u = o(e).arrowY) != null && u.value ? `${(d = o(e).arrowY) == null ? void 0 : d.value}px` : void 0,\n          [n.value]: 0,\n          transformOrigin: {\n            top: \"\",\n            right: \"0 0\",\n            bottom: \"center 0\",\n            left: \"100% 0\"\n          }[o(e).placedSide.value],\n          transform: {\n            top: \"translateY(100%)\",\n            right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n            bottom: \"rotate(180deg)\",\n            left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n          }[o(e).placedSide.value],\n          visibility: o(e).shouldHideArrow.value ? \"hidden\" : void 0\n        })\n      }, [\n        q(dd, k(l.$attrs, {\n          ref: o(t),\n          style: {\n            display: \"block\"\n          },\n          as: l.as,\n          \"as-child\": l.asChild,\n          width: l.width,\n          height: l.height\n        }), {\n          default: y(() => [\n            w(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"width\", \"height\"])\n      ], 4);\n    };\n  }\n}), Jt = /* @__PURE__ */ x({\n  __name: \"VisuallyHidden\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return R(), (t, e) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      style: {\n        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss\n        position: \"absolute\",\n        border: 0,\n        width: \"1px\",\n        display: \"inline-block\",\n        height: \"1px\",\n        padding: 0,\n        margin: \"-1px\",\n        overflow: \"hidden\",\n        clip: \"rect(0, 0, 0, 0)\",\n        whiteSpace: \"nowrap\",\n        wordWrap: \"normal\"\n      }\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), no = /* @__PURE__ */ x({\n  __name: \"VisuallyHiddenInput\",\n  props: {\n    name: {},\n    value: {},\n    required: { type: Boolean },\n    disabled: { type: Boolean }\n  },\n  setup(a) {\n    const t = a, e = B(() => typeof t.value == \"string\" || typeof t.value == \"number\" || typeof t.value == \"boolean\" ? [{ name: t.name, value: t.value }] : typeof t.value == \"object\" && Array.isArray(t.value) ? t.value.flatMap((n, l) => typeof n == \"object\" ? Object.entries(n).map(([s, r]) => ({ name: `[${l}][${t.name}][${s}]`, value: r })) : { name: `[${t.name}][${l}]`, value: n }) : t.value !== null && typeof t.value == \"object\" && !Array.isArray(t.value) ? Object.entries(t.value).map(([n, l]) => ({ name: `[${t.name}][${n}]`, value: l })) : []);\n    return (n, l) => (b(!0), ve(_e, null, ma(e.value, (s) => (b(), S(Jt, {\n      key: s.name,\n      as: \"input\",\n      type: \"hidden\",\n      hidden: \"\",\n      readonly: \"\",\n      name: s.name,\n      value: s.value,\n      required: n.required,\n      disabled: n.disabled\n    }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"]))), 128));\n  }\n}), fd = \"data-radix-vue-collection-item\", [oo, pd] = te(\"CollectionProvider\");\nfunction Ca(a = fd) {\n  const t = T(/* @__PURE__ */ new Map()), e = T(), n = pd({\n    collectionRef: e,\n    itemMap: t,\n    attrName: a\n  }), { getItems: l } = ea(n), s = B(() => Array.from(n.itemMap.value.values())), r = B(() => n.itemMap.value.size);\n  return { getItems: l, reactiveItems: s, itemMapSize: r };\n}\nconst wa = x({\n  name: \"CollectionSlot\",\n  setup(a, { slots: t }) {\n    const e = oo(), { primitiveElement: n, currentElement: l } = Re();\n    return ee(l, () => {\n      e.collectionRef.value = l.value;\n    }), () => mt(Jn, { ref: n }, t);\n  }\n}), Qt = x({\n  name: \"CollectionItem\",\n  inheritAttrs: !1,\n  props: {\n    value: {\n      // It accepts any value\n      validator: () => !0\n    }\n  },\n  setup(a, { slots: t, attrs: e }) {\n    const n = oo(), { primitiveElement: l, currentElement: s } = Re();\n    return Ce((r) => {\n      if (s.value) {\n        const i = xr(s.value);\n        n.itemMap.value.set(i, { ref: s.value, value: a.value }), r(() => n.itemMap.value.delete(i));\n      }\n    }), () => mt(Jn, { ...e, [n.attrName]: \"\", ref: l }, t);\n  }\n});\nfunction ea(a) {\n  const t = a ?? oo();\n  return { getItems: () => {\n    const n = t.collectionRef.value;\n    if (!n)\n      return [];\n    const l = Array.from(n.querySelectorAll(`[${t.attrName}]`));\n    return Array.from(t.itemMap.value.values()).sort(\n      (i, u) => l.indexOf(i.ref) - l.indexOf(u.ref)\n    );\n  } };\n}\nconst [it, vd] = te(\"ComboboxRoot\"), Uv = /* @__PURE__ */ x({\n  __name: \"ComboboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    searchTerm: {},\n    selectedValue: {},\n    multiple: { type: Boolean },\n    disabled: { type: Boolean },\n    name: {},\n    dir: {},\n    filterFunction: {},\n    displayValue: {},\n    resetSearchTermOnBlur: { type: Boolean, default: !0 },\n    resetSearchTermOnSelect: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:open\", \"update:searchTerm\", \"update:selectedValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { multiple: l, disabled: s, dir: r } = ae(e), i = we(r), u = ne(e, \"searchTerm\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: \"\",\n      passive: e.searchTerm === void 0\n    }), d = ne(e, \"modelValue\", n, {\n      // @ts-expect-error ignore the type error here\n      defaultValue: e.defaultValue ?? l.value ? [] : void 0,\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), c = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), f = ne(e, \"selectedValue\", n, {\n      defaultValue: void 0,\n      passive: e.selectedValue === void 0\n    });\n    async function v(L) {\n      var N, Z;\n      c.value = L, await oe(), L ? (d.value && (Array.isArray(d.value) && l.value ? f.value = (N = h().find((Y) => {\n        var re, X;\n        return ((X = (re = Y.ref) == null ? void 0 : re.dataset) == null ? void 0 : X.state) === \"checked\";\n      })) == null ? void 0 : N.value : f.value = d.value), await oe(), (Z = m.value) == null || Z.focus(), H()) : (g.value = !1, e.resetSearchTermOnBlur && M(\"blur\"));\n    }\n    function p(L) {\n      if (Array.isArray(d.value) && l.value) {\n        const N = d.value.findIndex((Y) => Qe(Y, L)), Z = [...d.value];\n        N === -1 ? Z.push(L) : Z.splice(N, 1), d.value = Z;\n      } else\n        d.value = L, v(!1);\n    }\n    const g = T(!1), m = T(), _ = T(), { forwardRef: C, currentElement: $ } = R(), { getItems: h, reactiveItems: E, itemMapSize: P } = Ca(\"data-radix-vue-combobox-item\"), D = T([]);\n    ee(() => P.value, () => {\n      D.value = h().map((L) => L.value);\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    });\n    const I = B(() => {\n      if (g.value) {\n        if (e.filterFunction)\n          return e.filterFunction(D.value, u.value);\n        const L = D.value.filter((N) => typeof N == \"string\");\n        if (L.length)\n          return L.filter((N) => {\n            var Z;\n            return N.toLowerCase().includes((Z = u.value) == null ? void 0 : Z.toLowerCase());\n          });\n      }\n      return D.value;\n    });\n    function M(L) {\n      const N = L === \"blur\" || L === \"select\" && e.resetSearchTermOnSelect;\n      !l.value && d.value && !Array.isArray(d.value) ? e.displayValue ? u.value = e.displayValue(d.value) : typeof d.value != \"object\" ? u.value = d.value.toString() : N && (u.value = \"\") : N && (u.value = \"\");\n    }\n    const V = B(() => I.value.findIndex((L) => Qe(L, f.value))), A = B(() => {\n      var L;\n      return (L = E.value.find((N) => Qe(N.value, f.value))) == null ? void 0 : L.ref;\n    }), F = B(() => JSON.stringify(d.value));\n    ee(F, async () => {\n      await oe(), await oe(), M(\"select\");\n    }, {\n      // If searchTerm is provided with value during initialization, we don't reset it immediately\n      immediate: !e.searchTerm\n    }), ee(() => [I.value.length, u.value.length], async ([L, N], [Z, Y]) => {\n      await oe(), await oe(), L && (Y > N || V.value === -1) && (f.value = I.value[0]);\n    });\n    const j = at($);\n    function H() {\n      var L;\n      A.value instanceof Element && ((L = A.value) == null || L.scrollIntoView({ block: \"nearest\" }));\n    }\n    function Q() {\n      A.value instanceof Element && A.value.focus && A.value.focus();\n    }\n    const G = T(!1);\n    function J() {\n      G.value = !0;\n    }\n    function z() {\n      requestAnimationFrame(() => {\n        G.value = !1;\n      });\n    }\n    async function K(L) {\n      var N;\n      I.value.length && f.value && A.value instanceof Element && (L.preventDefault(), L.stopPropagation(), G.value || (N = A.value) == null || N.click());\n    }\n    return vd({\n      searchTerm: u,\n      modelValue: d,\n      // @ts-expect-error ignoring\n      onValueChange: p,\n      isUserInputted: g,\n      multiple: l,\n      disabled: s,\n      open: c,\n      onOpenChange: v,\n      filteredOptions: I,\n      contentId: \"\",\n      inputElement: m,\n      selectedElement: A,\n      onInputElementChange: (L) => m.value = L,\n      onInputNavigation: async (L) => {\n        const N = V.value;\n        N === 0 && L === \"up\" || N === I.value.length - 1 && L === \"down\" || (N === -1 && I.value.length || L === \"home\" ? f.value = I.value[0] : L === \"end\" ? f.value = I.value[I.value.length - 1] : f.value = I.value[L === \"up\" ? N - 1 : N + 1], await oe(), H(), Q(), oe(() => {\n          var Z;\n          return (Z = m.value) == null ? void 0 : Z.focus({ preventScroll: !0 });\n        }));\n      },\n      onInputEnter: K,\n      onCompositionEnd: z,\n      onCompositionStart: J,\n      selectedValue: f,\n      onSelectedValueChange: (L) => f.value = L,\n      parentElement: $,\n      contentElement: _,\n      onContentElementChange: (L) => _.value = L\n    }), (L, N) => (b(), S(o(kt), null, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(C),\n          style: {\n            pointerEvents: o(c) ? \"auto\" : void 0\n          },\n          as: L.as,\n          \"as-child\": L.asChild,\n          dir: o(i)\n        }, L.$attrs), {\n          default: y(() => [\n            w(L.$slots, \"default\", {\n              open: o(c),\n              modelValue: o(d)\n            }),\n            o(j) && e.name ? (b(), S(o(no), {\n              key: 0,\n              name: e.name,\n              value: o(d)\n            }, null, 8, [\"name\", \"value\"])) : ce(\"\", !0)\n          ]),\n          _: 3\n        }, 16, [\"style\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Gv = /* @__PURE__ */ x({\n  __name: \"ComboboxInput\",\n  props: {\n    type: { default: \"text\" },\n    disabled: { type: Boolean },\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = it(), { forwardRef: n, currentElement: l } = R();\n    le(() => {\n      const c = l.value.nodeName === \"INPUT\" ? l.value : l.value.querySelector(\"input\");\n      c && (e.onInputElementChange(c), setTimeout(() => {\n        t.autoFocus && (c == null || c.focus());\n      }, 1));\n    });\n    const s = B(() => t.disabled || e.disabled.value || !1), r = T();\n    Sr(() => {\n      var c;\n      return r.value = (c = e.selectedElement.value) == null ? void 0 : c.id;\n    });\n    function i(c) {\n      e.open.value ? e.onInputNavigation(c.key === \"ArrowUp\" ? \"up\" : \"down\") : e.onOpenChange(!0);\n    }\n    function u(c) {\n      e.open.value && e.onInputNavigation(c.key === \"Home\" ? \"home\" : \"end\");\n    }\n    function d(c) {\n      var f;\n      e.searchTerm.value = (f = c.target) == null ? void 0 : f.value, e.open.value || e.onOpenChange(!0), e.isUserInputted.value = !0;\n    }\n    return (c, f) => (b(), S(o(O), {\n      ref: o(n),\n      as: c.as,\n      \"as-child\": c.asChild,\n      type: c.type,\n      disabled: s.value,\n      value: o(e).searchTerm.value,\n      \"aria-expanded\": o(e).open.value,\n      \"aria-controls\": o(e).contentId,\n      \"aria-disabled\": s.value ?? void 0,\n      \"aria-activedescendant\": r.value,\n      \"aria-autocomplete\": \"list\",\n      role: \"combobox\",\n      autocomplete: \"false\",\n      onInput: d,\n      onKeydown: [\n        ie(ue(i, [\"prevent\"]), [\"down\", \"up\"]),\n        ie(o(e).onInputEnter, [\"enter\"]),\n        ie(ue(u, [\"prevent\"]), [\"home\", \"end\"])\n      ],\n      onCompositionstart: o(e).onCompositionStart,\n      onCompositionend: o(e).onCompositionEnd\n    }, {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"type\", \"disabled\", \"value\", \"aria-expanded\", \"aria-controls\", \"aria-disabled\", \"aria-activedescendant\", \"onKeydown\", \"onCompositionstart\", \"onCompositionend\"]));\n  }\n}), qv = /* @__PURE__ */ x({\n  __name: \"ComboboxAnchor\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const { forwardRef: t } = R();\n    return (e, n) => (b(), S(o(Mt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(t),\n          \"as-child\": e.asChild,\n          as: e.as\n        }, e.$attrs), {\n          default: y(() => [\n            w(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Yv = /* @__PURE__ */ x({\n  __name: \"ComboboxTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = it(), n = B(() => t.disabled || e.disabled.value || !1);\n    return (l, s) => (b(), S(o(O), k(t, {\n      type: l.as === \"button\" ? \"button\" : void 0,\n      tabindex: \"-1\",\n      \"aria-label\": \"Show popup\",\n      \"aria-haspopup\": \"listbox\",\n      \"aria-expanded\": o(e).open.value,\n      \"aria-controls\": o(e).contentId,\n      \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n      disabled: n.value,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"aria-disabled\": n.value ?? void 0,\n      onClick: s[0] || (s[0] = (r) => o(e).onOpenChange(!o(e).open.value))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"aria-disabled\"]));\n  }\n}), Xv = /* @__PURE__ */ x({\n  __name: \"ComboboxCancel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = it();\n    function n() {\n      var l;\n      e.searchTerm.value = \"\", (l = e.inputElement.value) == null || l.focus();\n    }\n    return (l, s) => (b(), S(o(O), k({\n      type: l.as === \"button\" ? \"button\" : void 0\n    }, t, {\n      tabindex: \"-1\",\n      onClick: n\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\"]));\n  }\n}), [as, md] = te(\"ComboboxGroup\"), Zv = /* @__PURE__ */ x({\n  __name: \"ComboboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { currentRef: e, currentElement: n } = R(), l = ge(void 0, \"radix-vue-combobox-group\"), s = it(), r = T(!1);\n    function i() {\n      if (!n.value)\n        return;\n      const u = n.value.querySelectorAll(\"[data-radix-vue-combobox-item]:not([data-hidden])\");\n      r.value = !!u.length;\n    }\n    return Al(n, () => {\n      oe(() => {\n        i();\n      });\n    }, { childList: !0 }), ee(() => s.searchTerm.value, () => {\n      oe(() => {\n        i();\n      });\n    }, { immediate: !0 }), md({\n      id: l\n    }), (u, d) => ja((b(), S(o(O), k(t, {\n      ref_key: \"currentRef\",\n      ref: e,\n      role: \"group\",\n      \"aria-labelledby\": o(l)\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"])), [\n      [zn, r.value]\n    ]);\n  }\n}), Jv = /* @__PURE__ */ x({\n  __name: \"ComboboxLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = as({ id: \"\" });\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [hd, yd] = te(\"ComboboxContent\"), gd = /* @__PURE__ */ x({\n  __name: \"ComboboxContentImpl\",\n  props: {\n    position: { default: \"inline\" },\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean, default: !0 },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { position: l } = ae(e), s = it();\n    ya(e.bodyLock);\n    const { forwardRef: r, currentElement: i } = R();\n    ga(s.parentElement);\n    const u = B(() => e.position === \"popper\" ? e : {}), d = Ot(u.value);\n    function c(v) {\n      s.onSelectedValueChange(\"\");\n    }\n    le(() => {\n      s.onContentElementChange(i.value);\n    });\n    const f = {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-combobox-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-combobox-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-combobox-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-combobox-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-combobox-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    };\n    return yd({ position: l }), (v, p) => (b(), S(o(wa), null, {\n      default: y(() => [\n        v.dismissable ? (b(), S(o(Ct), {\n          key: 0,\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": v.disableOutsidePointerEvents,\n          onDismiss: p[0] || (p[0] = (g) => o(s).onOpenChange(!1)),\n          onFocusOutside: p[1] || (p[1] = (g) => {\n            var m;\n            (m = o(s).parentElement.value) != null && m.contains(g.target) && g.preventDefault(), n(\"focusOutside\", g);\n          }),\n          onInteractOutside: p[2] || (p[2] = (g) => n(\"interactOutside\", g)),\n          onEscapeKeyDown: p[3] || (p[3] = (g) => n(\"escapeKeyDown\", g)),\n          onPointerDownOutside: p[4] || (p[4] = (g) => {\n            var m;\n            (m = o(s).parentElement.value) != null && m.contains(g.target) && g.preventDefault(), n(\"pointerDownOutside\", g);\n          })\n        }, {\n          default: y(() => [\n            (b(), S(Xe(o(l) === \"popper\" ? o(It) : o(O)), k({ ...v.$attrs, ...o(d) }, {\n              id: o(s).contentId,\n              ref: o(r),\n              role: \"listbox\",\n              \"data-state\": o(s).open.value ? \"open\" : \"closed\",\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\",\n                ...o(l) === \"popper\" ? f : {}\n              },\n              onPointerleave: c\n            }), {\n              default: y(() => [\n                w(v.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"style\"]))\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])) : (b(), S(Xe(o(l) === \"popper\" ? o(It) : o(O)), k({ key: 1 }, { ...v.$attrs, ...u.value }, {\n          id: o(s).contentId,\n          ref: o(r),\n          role: \"listbox\",\n          \"data-state\": o(s).open.value ? \"open\" : \"closed\",\n          style: {\n            // flex layout so we can place the scroll buttons properly\n            display: \"flex\",\n            flexDirection: \"column\",\n            // reset the outline by default as the content MAY get focused\n            outline: \"none\",\n            ...o(l) === \"popper\" ? f : {}\n          },\n          onPointerleave: c\n        }), {\n          default: y(() => [\n            w(v.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"data-state\", \"style\"]))\n      ]),\n      _: 3\n    }));\n  }\n}), Qv = /* @__PURE__ */ x({\n  __name: \"ComboboxContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    dismissable: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t), { forwardRef: s } = R(), r = it();\n    return r.contentId || (r.contentId = ge(void 0, \"radix-vue-combobox-content\")), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(r).open.value\n    }, {\n      default: y(() => [\n        q(gd, k({ ...o(l), ...i.$attrs }, { ref: o(s) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), em = /* @__PURE__ */ x({\n  __name: \"ComboboxEmpty\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = it(), n = B(() => e.filteredOptions.value.length === 0);\n    return (l, s) => n.value ? (b(), S(o(O), W(k({ key: 0 }, t)), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"No options\")\n        ])\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n});\nfunction Ja(a) {\n  const t = Ya({\n    nonce: T()\n  });\n  return B(() => {\n    var e;\n    return (a == null ? void 0 : a.value) || ((e = t.nonce) == null ? void 0 : e.value);\n  });\n}\nconst tm = /* @__PURE__ */ x({\n  __name: \"ComboboxViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), { nonce: n } = ae(t), l = Ja(n);\n    return (s, r) => (b(), ve(_e, null, [\n      q(o(O), k({ ...s.$attrs, ...t }, {\n        ref: o(e),\n        \"data-radix-combobox-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: y(() => [\n          w(s.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          ye(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-combobox-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n}), [bd, Cd] = te(\"ComboboxItem\"), wd = \"combobox.select\", am = /* @__PURE__ */ x({\n  __name: \"ComboboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ae(e), s = it();\n    as({ id: \"\", options: T([]) });\n    const { forwardRef: r } = R(), i = B(\n      () => {\n        var m, _;\n        return s.multiple.value && Array.isArray(s.modelValue.value) ? (m = s.modelValue.value) == null ? void 0 : m.some((C) => Qe(C, e.value)) : Qe((_ = s.modelValue) == null ? void 0 : _.value, e.value);\n      }\n    ), u = B(() => Qe(s.selectedValue.value, e.value)), d = ge(void 0, \"radix-vue-combobox-item\"), c = ge(void 0, \"radix-vue-combobox-option\"), f = B(() => s.isUserInputted.value ? s.searchTerm.value === \"\" || !!s.filteredOptions.value.find((m) => Qe(m, e.value)) : !0);\n    async function v(m) {\n      n(\"select\", m), !(m != null && m.defaultPrevented) && !l.value && m && s.onValueChange(e.value);\n    }\n    function p(m) {\n      if (!m)\n        return;\n      const _ = { originalEvent: m, value: e.value };\n      jt(wd, v, _);\n    }\n    async function g(m) {\n      await oe(), !m.defaultPrevented && s.onSelectedValueChange(e.value);\n    }\n    if (e.value === \"\")\n      throw new Error(\n        \"A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return Cd({\n      isSelected: i\n    }), (m, _) => (b(), S(o(Qt), { value: m.value }, {\n      default: y(() => [\n        ja(q(o(O), {\n          id: o(c),\n          ref: o(r),\n          role: \"option\",\n          tabindex: \"-1\",\n          \"aria-labelledby\": o(d),\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"aria-selected\": i.value,\n          \"data-state\": i.value ? \"checked\" : \"unchecked\",\n          \"aria-disabled\": o(l) || void 0,\n          \"data-disabled\": o(l) ? \"\" : void 0,\n          as: m.as,\n          \"as-child\": m.asChild,\n          \"data-hidden\": f.value ? void 0 : !0,\n          onClick: p,\n          onPointermove: g\n        }, {\n          default: y(() => [\n            w(m.$slots, \"default\", {}, () => [\n              ye(De(m.value), 1)\n            ])\n          ]),\n          _: 3\n        }, 8, [\"id\", \"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"as\", \"as-child\", \"data-hidden\"]), [\n          [zn, f.value]\n        ])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), nm = /* @__PURE__ */ x({\n  __name: \"ComboboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = bd();\n    return (n, l) => o(e).isSelected.value ? (b(), S(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"true\"\n    }, t), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), om = /* @__PURE__ */ x({\n  __name: \"ComboboxSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lm = /* @__PURE__ */ x({\n  __name: \"ComboboxArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a, e = it(), n = hd();\n    return R(), (l, s) => o(e).open.value && o(n).position.value === \"popper\" ? (b(), S(o(Zt), W(k({ key: 0 }, t)), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), sm = /* @__PURE__ */ x({\n  __name: \"ComboboxPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qa = /* @__PURE__ */ x({\n  __name: \"MenuAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Mt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lo = /* @__PURE__ */ x({\n  __name: \"MenuArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Zt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction _d() {\n  const a = T(!1);\n  return le(() => {\n    He(\"keydown\", () => {\n      a.value = !0;\n    }, { capture: !0, passive: !0 }), He([\"pointerdown\", \"pointermove\"], () => {\n      a.value = !1;\n    }, { capture: !0, passive: !0 });\n  }), a;\n}\nconst xd = Dl(_d), [Vt, ns] = te([\"MenuRoot\", \"MenuSub\"], \"MenuContext\"), [_a, Sd] = te(\"MenuRoot\"), so = /* @__PURE__ */ x({\n  __name: \"MenuRoot\",\n  props: {\n    open: { type: Boolean, default: !1 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { modal: l, dir: s } = ae(e), r = we(s), i = ne(e, \"open\", n), u = T(), d = xd();\n    return ns({\n      open: i,\n      onOpenChange: (c) => {\n        i.value = c;\n      },\n      content: u,\n      onContentChange: (c) => {\n        u.value = c;\n      }\n    }), Sd({\n      onClose: () => {\n        i.value = !1;\n      },\n      isUsingKeyboardRef: d,\n      dir: r,\n      modal: l\n    }), (c, f) => (b(), S(o(kt), null, {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), Ed = \"rovingFocusGroup.onEntryFocus\", Pd = { bubbles: !1, cancelable: !0 }, en = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction Dd(a, t) {\n  return t !== \"rtl\" ? a : a === \"ArrowLeft\" ? \"ArrowRight\" : a === \"ArrowRight\" ? \"ArrowLeft\" : a;\n}\nfunction os(a, t, e) {\n  const n = Dd(a.key, e);\n  if (!(t === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(n)) && !(t === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(n)))\n    return en[n];\n}\nfunction ls(a, t = !1) {\n  const e = me();\n  for (const n of a)\n    if (n === e || (n.focus({ preventScroll: t }), me() !== e))\n      return;\n}\nfunction $d(a, t) {\n  return a.map((e, n) => a[(t + n) % a.length]);\n}\nconst [Bd, Id] = te(\"RovingFocusGroup\"), Ft = /* @__PURE__ */ x({\n  __name: \"RovingFocusGroup\",\n  props: {\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !1 },\n    currentTabStopId: {},\n    defaultCurrentTabStopId: {},\n    preventScrollOnEntryFocus: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"entryFocus\", \"update:currentTabStopId\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, { loop: s, orientation: r, dir: i } = ae(n), u = we(i), d = ne(n, \"currentTabStopId\", l, {\n      defaultValue: n.defaultCurrentTabStopId,\n      passive: n.currentTabStopId === void 0\n    }), c = T(!1), f = T(!1), v = T(0), { getItems: p } = Ca();\n    function g(_) {\n      const C = !f.value;\n      if (_.currentTarget && _.target === _.currentTarget && C && !c.value) {\n        const $ = new CustomEvent(Ed, Pd);\n        if (_.currentTarget.dispatchEvent($), l(\"entryFocus\", $), !$.defaultPrevented) {\n          const h = p().map((I) => I.ref).filter((I) => I.dataset.disabled !== \"\"), E = h.find((I) => I.getAttribute(\"data-active\") === \"true\"), P = h.find(\n            (I) => I.id === d.value\n          ), D = [E, P, ...h].filter(\n            Boolean\n          );\n          ls(D, n.preventScrollOnEntryFocus);\n        }\n      }\n      f.value = !1;\n    }\n    function m() {\n      setTimeout(() => {\n        f.value = !1;\n      }, 1);\n    }\n    return t({\n      getItems: p\n    }), Id({\n      loop: s,\n      dir: u,\n      orientation: r,\n      currentTabStopId: d,\n      onItemFocus: (_) => {\n        d.value = _;\n      },\n      onItemShiftTab: () => {\n        c.value = !0;\n      },\n      onFocusableItemAdd: () => {\n        v.value++;\n      },\n      onFocusableItemRemove: () => {\n        v.value--;\n      }\n    }), (_, C) => (b(), S(o(wa), null, {\n      default: y(() => [\n        q(o(O), {\n          tabindex: c.value || v.value === 0 ? -1 : 0,\n          \"data-orientation\": o(r),\n          as: _.as,\n          \"as-child\": _.asChild,\n          dir: o(u),\n          style: { outline: \"none\" },\n          onMousedown: C[0] || (C[0] = ($) => f.value = !0),\n          onMouseup: m,\n          onFocus: g,\n          onBlur: C[1] || (C[1] = ($) => c.value = !1)\n        }, {\n          default: y(() => [\n            w(_.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"tabindex\", \"data-orientation\", \"as\", \"as-child\", \"dir\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Nt = /* @__PURE__ */ x({\n  __name: \"RovingFocusItem\",\n  props: {\n    tabStopId: {},\n    focusable: { type: Boolean, default: !0 },\n    active: { type: Boolean, default: !0 },\n    allowShiftKey: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Bd(), n = B(() => t.tabStopId || ge()), l = B(\n      () => e.currentTabStopId.value === n.value\n    ), { getItems: s } = ea();\n    le(() => {\n      t.focusable && e.onFocusableItemAdd();\n    }), Be(() => {\n      t.focusable && e.onFocusableItemRemove();\n    });\n    function r(i) {\n      if (i.key === \"Tab\" && i.shiftKey) {\n        e.onItemShiftTab();\n        return;\n      }\n      if (i.target !== i.currentTarget)\n        return;\n      const u = os(\n        i,\n        e.orientation.value,\n        e.dir.value\n      );\n      if (u !== void 0) {\n        if (i.metaKey || i.ctrlKey || i.altKey || !t.allowShiftKey && i.shiftKey)\n          return;\n        i.preventDefault();\n        let d = [...s().map((c) => c.ref).filter((c) => c.dataset.disabled !== \"\")];\n        if (u === \"last\")\n          d.reverse();\n        else if (u === \"prev\" || u === \"next\") {\n          u === \"prev\" && d.reverse();\n          const c = d.indexOf(\n            i.currentTarget\n          );\n          d = e.loop.value ? $d(d, c + 1) : d.slice(c + 1);\n        }\n        oe(() => ls(d));\n      }\n    }\n    return (i, u) => (b(), S(o(Qt), null, {\n      default: y(() => [\n        q(o(O), {\n          tabindex: l.value ? 0 : -1,\n          \"data-orientation\": o(e).orientation.value,\n          \"data-active\": i.active,\n          \"data-disabled\": i.focusable ? void 0 : \"\",\n          as: i.as,\n          \"as-child\": i.asChild,\n          onMousedown: u[0] || (u[0] = (d) => {\n            i.focusable ? o(e).onItemFocus(n.value) : d.preventDefault();\n          }),\n          onFocus: u[1] || (u[1] = (d) => o(e).onItemFocus(n.value)),\n          onKeydown: r\n        }, {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"tabindex\", \"data-orientation\", \"data-active\", \"data-disabled\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [ro, Td] = te(\"MenuContent\"), io = /* @__PURE__ */ x({\n  __name: \"MenuContentImpl\",\n  props: /* @__PURE__ */ yl({\n    loop: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    disableOutsideScroll: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  }, {\n    ...ts\n  }),\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\", \"dismiss\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Vt(), s = _a(), { trapFocus: r, disableOutsidePointerEvents: i, loop: u } = ae(e);\n    Yn(), ya(i.value);\n    const d = T(\"\"), c = T(0), f = T(0), v = T(null), p = T(\"right\"), g = T(0), m = T(null), { createCollection: _ } = Fe(), { forwardRef: C, currentElement: $ } = R(), h = _($);\n    ee($, (A) => {\n      l.onContentChange(A);\n    });\n    const { handleTypeaheadSearch: E } = ba(h);\n    Be(() => {\n      window.clearTimeout(c.value);\n    });\n    function P(A) {\n      var j, H;\n      return p.value === ((j = v.value) == null ? void 0 : j.side) && Cu(A, (H = v.value) == null ? void 0 : H.area);\n    }\n    async function D(A) {\n      var F;\n      n(\"openAutoFocus\", A), !A.defaultPrevented && (A.preventDefault(), (F = $.value) == null || F.focus({\n        preventScroll: !0\n      }));\n    }\n    function I(A) {\n      if (A.defaultPrevented)\n        return;\n      const j = A.target.closest(\"[data-radix-menu-content]\") === A.currentTarget, H = A.ctrlKey || A.altKey || A.metaKey, Q = A.key.length === 1, G = At(\n        A,\n        me(),\n        $.value,\n        {\n          loop: u.value,\n          arrowKeyOptions: \"vertical\",\n          dir: s == null ? void 0 : s.dir.value,\n          focus: !0,\n          attributeName: \"[data-radix-vue-collection-item]:not([data-disabled])\"\n        }\n      );\n      if (G)\n        return G == null ? void 0 : G.focus();\n      if (A.code === \"Space\" || (j && (A.key === \"Tab\" && A.preventDefault(), !H && Q && E(A.key)), A.target !== $.value) || !hu.includes(A.key))\n        return;\n      A.preventDefault();\n      const J = h.value;\n      ql.includes(A.key) && J.reverse(), In(J);\n    }\n    function M(A) {\n      var F, j;\n      (j = (F = A == null ? void 0 : A.currentTarget) == null ? void 0 : F.contains) != null && j.call(F, A.target) || (window.clearTimeout(c.value), d.value = \"\");\n    }\n    function V(A) {\n      var H;\n      if (!da(A))\n        return;\n      const F = A.target, j = g.value !== A.clientX;\n      if ((H = A == null ? void 0 : A.currentTarget) != null && H.contains(F) && j) {\n        const Q = A.clientX > g.value ? \"right\" : \"left\";\n        p.value = Q, g.value = A.clientX;\n      }\n    }\n    return Td({\n      onItemEnter: (A) => !!P(A),\n      onItemLeave: (A) => {\n        var F;\n        P(A) || ((F = $.value) == null || F.focus(), m.value = null);\n      },\n      onTriggerLeave: (A) => !!P(A),\n      searchRef: d,\n      pointerGraceTimerRef: f,\n      onPointerGraceIntentChange: (A) => {\n        v.value = A;\n      }\n    }), (A, F) => (b(), S(o(Za), {\n      \"as-child\": \"\",\n      trapped: o(r),\n      onMountAutoFocus: D,\n      onUnmountAutoFocus: F[7] || (F[7] = (j) => n(\"closeAutoFocus\", j))\n    }, {\n      default: y(() => [\n        q(o(Ct), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": o(i),\n          onEscapeKeyDown: F[2] || (F[2] = (j) => n(\"escapeKeyDown\", j)),\n          onPointerDownOutside: F[3] || (F[3] = (j) => n(\"pointerDownOutside\", j)),\n          onFocusOutside: F[4] || (F[4] = (j) => n(\"focusOutside\", j)),\n          onInteractOutside: F[5] || (F[5] = (j) => n(\"interactOutside\", j)),\n          onDismiss: F[6] || (F[6] = (j) => n(\"dismiss\"))\n        }, {\n          default: y(() => [\n            q(o(Ft), {\n              \"current-tab-stop-id\": m.value,\n              \"onUpdate:currentTabStopId\": F[0] || (F[0] = (j) => m.value = j),\n              \"as-child\": \"\",\n              orientation: \"vertical\",\n              dir: o(s).dir.value,\n              loop: o(u),\n              onEntryFocus: F[1] || (F[1] = (j) => {\n                n(\"entryFocus\", j), o(s).isUsingKeyboardRef.value || j.preventDefault();\n              })\n            }, {\n              default: y(() => [\n                q(o(It), {\n                  ref: o(C),\n                  role: \"menu\",\n                  as: A.as,\n                  \"as-child\": A.asChild,\n                  \"aria-orientation\": \"vertical\",\n                  \"data-radix-menu-content\": \"\",\n                  \"data-state\": o(to)(o(l).open.value),\n                  dir: o(s).dir.value,\n                  side: A.side,\n                  \"side-offset\": A.sideOffset,\n                  align: A.align,\n                  \"align-offset\": A.alignOffset,\n                  \"avoid-collisions\": A.avoidCollisions,\n                  \"collision-boundary\": A.collisionBoundary,\n                  \"collision-padding\": A.collisionPadding,\n                  \"arrow-padding\": A.arrowPadding,\n                  \"prioritize-position\": A.prioritizePosition,\n                  sticky: A.sticky,\n                  \"hide-when-detached\": A.hideWhenDetached,\n                  onKeydown: I,\n                  onBlur: M,\n                  onPointermove: V\n                }, {\n                  default: y(() => [\n                    w(A.$slots, \"default\")\n                  ]),\n                  _: 3\n                }, 8, [\"as\", \"as-child\", \"data-state\", \"dir\", \"side\", \"side-offset\", \"align\", \"align-offset\", \"avoid-collisions\", \"collision-boundary\", \"collision-padding\", \"arrow-padding\", \"prioritize-position\", \"sticky\", \"hide-when-detached\"])\n              ]),\n              _: 3\n            }, 8, [\"current-tab-stop-id\", \"dir\", \"loop\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), ss = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"MenuItemImpl\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = ro(), { forwardRef: n } = R(), l = T(!1);\n    async function s(i) {\n      if (!i.defaultPrevented && da(i)) {\n        if (t.disabled)\n          e.onItemLeave(i);\n        else if (!e.onItemEnter(i)) {\n          const d = i.currentTarget;\n          d == null || d.focus({ preventScroll: !0 });\n        }\n      }\n    }\n    async function r(i) {\n      await oe(), !i.defaultPrevented && da(i) && e.onItemLeave(i);\n    }\n    return (i, u) => (b(), S(o(Qt), {\n      value: { textValue: i.textValue }\n    }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(n),\n          role: \"menuitem\",\n          tabindex: \"-1\"\n        }, i.$attrs, {\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"data-radix-vue-collection-item\": \"\",\n          \"aria-disabled\": i.disabled || void 0,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-highlighted\": l.value ? \"\" : void 0,\n          onPointermove: s,\n          onPointerleave: r,\n          onFocus: u[0] || (u[0] = async (d) => {\n            await oe(), !(d.defaultPrevented || i.disabled) && (l.value = !0);\n          }),\n          onBlur: u[1] || (u[1] = async (d) => {\n            await oe(), !d.defaultPrevented && (l.value = !1);\n          })\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"aria-disabled\", \"data-disabled\", \"data-highlighted\"])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), xa = /* @__PURE__ */ x({\n  __name: \"MenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = _a(), i = ro(), u = T(!1);\n    async function d() {\n      const c = s.value;\n      if (!e.disabled && c) {\n        const f = new CustomEvent(vu, {\n          bubbles: !0,\n          cancelable: !0\n        });\n        n(\"select\", f), await oe(), f.defaultPrevented ? u.value = !1 : r.onClose();\n      }\n    }\n    return (c, f) => (b(), S(ss, k(e, {\n      ref: o(l),\n      onClick: d,\n      onPointerdown: f[0] || (f[0] = () => {\n        u.value = !0;\n      }),\n      onPointerup: f[1] || (f[1] = async (v) => {\n        var p;\n        await oe(), !v.defaultPrevented && (u.value || (p = v.currentTarget) == null || p.click());\n      }),\n      onKeydown: f[2] || (f[2] = async (v) => {\n        const p = o(i).searchRef.value !== \"\";\n        c.disabled || p && v.key === \" \" || o(Bn).includes(v.key) && (v.currentTarget.click(), v.preventDefault());\n      })\n    }), {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Rd, rs] = te(\n  [\"MenuCheckboxItem\", \"MenuRadioItem\"],\n  \"MenuItemIndicatorContext\"\n), uo = /* @__PURE__ */ x({\n  __name: \"MenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = Rd({\n      checked: T(!1)\n    });\n    return (e, n) => (b(), S(o(Pe), {\n      present: e.forceMount || o(La)(o(t).checked.value) || o(t).checked.value === !0\n    }, {\n      default: y(() => [\n        q(o(O), {\n          as: e.as,\n          \"as-child\": e.asChild,\n          \"data-state\": o(ao)(o(t).checked.value)\n        }, {\n          default: y(() => [\n            w(e.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), co = /* @__PURE__ */ x({\n  __name: \"MenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String], default: !1 },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ne(e, \"checked\", n);\n    return rs({ checked: l }), (s, r) => (b(), S(xa, k({ role: \"menuitemcheckbox\" }, e, {\n      \"aria-checked\": o(La)(o(l)) ? \"mixed\" : o(l),\n      \"data-state\": o(ao)(o(l)),\n      onSelect: r[0] || (r[0] = async (i) => {\n        n(\"select\", i), o(La)(o(l)) ? l.value = !0 : l.value = !o(l);\n      })\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\", { checked: o(l) })\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), Ad = /* @__PURE__ */ x({\n  __name: \"MenuRootContentModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Se(e, n), s = Vt(), { forwardRef: r, currentElement: i } = R();\n    return ga(i), (u, d) => (b(), S(io, k(o(l), {\n      ref: o(r),\n      \"trap-focus\": o(s).open.value,\n      \"disable-outside-pointer-events\": o(s).open.value,\n      \"disable-outside-scroll\": !0,\n      onDismiss: d[0] || (d[0] = (c) => o(s).onOpenChange(!1)),\n      onFocusOutside: d[1] || (d[1] = ue((c) => n(\"focusOutside\", c), [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\", \"disable-outside-pointer-events\"]));\n  }\n}), Od = /* @__PURE__ */ x({\n  __name: \"MenuRootContentNonModal\",\n  props: {\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t), s = Vt();\n    return (r, i) => (b(), S(io, k(o(l), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      \"disable-outside-scroll\": !1,\n      onDismiss: i[0] || (i[0] = (u) => o(s).onOpenChange(!1))\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fo = /* @__PURE__ */ x({\n  __name: \"MenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t), s = Vt(), r = _a();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(s).open.value\n    }, {\n      default: y(() => [\n        o(r).modal.value ? (b(), S(Ad, W(k({ key: 0 }, { ...i.$attrs, ...o(l) })), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), S(Od, W(k({ key: 1 }, { ...i.$attrs, ...o(l) })), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), tn = /* @__PURE__ */ x({\n  __name: \"MenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k({ role: \"group\" }, t), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), po = /* @__PURE__ */ x({\n  __name: \"MenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vo = /* @__PURE__ */ x({\n  __name: \"MenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [kd, Md] = te(\"MenuRadioGroup\"), mo = /* @__PURE__ */ x({\n  __name: \"MenuRadioGroup\",\n  props: {\n    modelValue: { default: \"\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t);\n    return Md({\n      modelValue: l,\n      onValueChange: (s) => {\n        l.value = s;\n      }\n    }), (s, r) => (b(), S(tn, W(U(e)), {\n      default: y(() => [\n        w(s.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ho = /* @__PURE__ */ x({\n  __name: \"MenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { value: l } = ae(e), s = kd(), r = B(\n      () => s.modelValue.value === (l == null ? void 0 : l.value)\n    );\n    return rs({ checked: r }), (i, u) => (b(), S(xa, k({ role: \"menuitemradio\" }, e, {\n      \"aria-checked\": r.value,\n      \"data-state\": o(ao)(r.value),\n      onSelect: u[0] || (u[0] = async (d) => {\n        n(\"select\", d), o(s).onValueChange(o(l));\n      })\n    }), {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-checked\", \"data-state\"]));\n  }\n}), yo = /* @__PURE__ */ x({\n  __name: \"MenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k(t, {\n      role: \"separator\",\n      \"aria-orientation\": \"horizontal\"\n    }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [is, Vd] = te(\"MenuSub\"), go = /* @__PURE__ */ x({\n  __name: \"MenuSub\",\n  props: {\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"open\", t, {\n      defaultValue: !1,\n      passive: e.open === void 0\n    }), s = Vt(), r = T(), i = T();\n    return Ce((u) => {\n      (s == null ? void 0 : s.open.value) === !1 && (l.value = !1), u(() => l.value = !1);\n    }), ns({\n      open: l,\n      onOpenChange: (u) => {\n        l.value = u;\n      },\n      content: i,\n      onContentChange: (u) => {\n        i.value = u;\n      }\n    }), Vd({\n      triggerId: \"\",\n      contentId: \"\",\n      trigger: r,\n      onTriggerChange: (u) => {\n        r.value = u;\n      }\n    }), (u, d) => (b(), S(o(kt), null, {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), bo = /* @__PURE__ */ x({\n  __name: \"MenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t), s = Vt(), r = _a(), i = is(), { forwardRef: u, currentElement: d } = R();\n    return i.contentId || (i.contentId = ge(void 0, \"radix-vue-menu-sub-content\")), (c, f) => (b(), S(o(Pe), {\n      present: c.forceMount || o(s).open.value\n    }, {\n      default: y(() => [\n        q(io, k(o(l), {\n          id: o(i).contentId,\n          ref: o(u),\n          \"aria-labelledby\": o(i).triggerId,\n          align: \"start\",\n          side: o(r).dir.value === \"rtl\" ? \"left\" : \"right\",\n          \"disable-outside-pointer-events\": !1,\n          \"disable-outside-scroll\": !1,\n          \"trap-focus\": !1,\n          onOpenAutoFocus: f[0] || (f[0] = ue((v) => {\n            var p;\n            o(r).isUsingKeyboardRef.value && ((p = o(d)) == null || p.focus());\n          }, [\"prevent\"])),\n          onCloseAutoFocus: f[1] || (f[1] = ue(() => {\n          }, [\"prevent\"])),\n          onFocusOutside: f[2] || (f[2] = (v) => {\n            v.defaultPrevented || v.target !== o(i).trigger.value && o(s).onOpenChange(!1);\n          }),\n          onEscapeKeyDown: f[3] || (f[3] = (v) => {\n            o(r).onClose(), v.preventDefault();\n          }),\n          onKeydown: f[4] || (f[4] = (v) => {\n            var m, _;\n            const p = (m = v.currentTarget) == null ? void 0 : m.contains(v.target), g = o(gu)[o(r).dir.value].includes(v.key);\n            p && g && (o(s).onOpenChange(!1), (_ = o(i).trigger.value) == null || _.focus(), v.preventDefault());\n          })\n        }), {\n          default: y(() => [\n            w(c.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-labelledby\", \"side\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Co = /* @__PURE__ */ x({\n  __name: \"MenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Vt(), n = _a(), l = is(), s = ro(), r = T(null);\n    l.triggerId || (l.triggerId = ge(void 0, \"radix-vue-menu-sub-trigger\"));\n    function i() {\n      r.value && window.clearTimeout(r.value), r.value = null;\n    }\n    Be(() => {\n      i();\n    });\n    function u(f) {\n      !da(f) || s.onItemEnter(f) || !t.disabled && !e.open.value && !r.value && (s.onPointerGraceIntentChange(null), r.value = window.setTimeout(() => {\n        e.onOpenChange(!0), i();\n      }, 100));\n    }\n    async function d(f) {\n      var p, g;\n      if (!da(f))\n        return;\n      i();\n      const v = (p = e.content.value) == null ? void 0 : p.getBoundingClientRect();\n      if (v != null && v.width) {\n        const m = (g = e.content.value) == null ? void 0 : g.dataset.side, _ = m === \"right\", C = _ ? -5 : 5, $ = v[_ ? \"left\" : \"right\"], h = v[_ ? \"right\" : \"left\"];\n        s.onPointerGraceIntentChange({\n          area: [\n            // Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            { x: f.clientX + C, y: f.clientY },\n            { x: $, y: v.top },\n            { x: h, y: v.top },\n            { x: h, y: v.bottom },\n            { x: $, y: v.bottom }\n          ],\n          side: m\n        }), window.clearTimeout(s.pointerGraceTimerRef.value), s.pointerGraceTimerRef.value = window.setTimeout(\n          () => s.onPointerGraceIntentChange(null),\n          300\n        );\n      } else {\n        if (s.onTriggerLeave(f))\n          return;\n        s.onPointerGraceIntentChange(null);\n      }\n    }\n    async function c(f) {\n      var p;\n      const v = s.searchRef.value !== \"\";\n      t.disabled || v && f.key === \" \" || yu[n.dir.value].includes(f.key) && (e.onOpenChange(!0), await oe(), (p = e.content.value) == null || p.focus(), f.preventDefault());\n    }\n    return (f, v) => (b(), S(Qa, { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(ss, k(t, {\n          id: o(l).triggerId,\n          ref: (p) => {\n            var g;\n            (g = o(l)) == null || g.onTriggerChange(p == null ? void 0 : p.$el);\n          },\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(l).contentId,\n          \"data-state\": o(to)(o(e).open.value),\n          onClick: v[0] || (v[0] = async (p) => {\n            t.disabled || p.defaultPrevented || (p.currentTarget.focus(), o(e).open.value || o(e).onOpenChange(!0));\n          }),\n          onPointermove: u,\n          onPointerleave: d,\n          onKeydown: c\n        }), {\n          default: y(() => [\n            w(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"id\", \"aria-expanded\", \"aria-controls\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), [us, Fd] = te(\"ContextMenuRoot\"), rm = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ContextMenuRoot\",\n  props: {\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, modal: s } = ae(e);\n    R();\n    const r = we(l), i = T(!1);\n    return Fd({\n      open: i,\n      onOpenChange: (u) => {\n        i.value = u;\n      },\n      dir: r,\n      modal: s\n    }), ee(i, (u) => {\n      n(\"update:open\", u);\n    }), (u, d) => (b(), S(o(so), {\n      open: i.value,\n      \"onUpdate:open\": d[0] || (d[0] = (c) => i.value = c),\n      dir: o(r),\n      modal: o(s)\n    }, {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n});\nfunction Zo(a) {\n  return a.pointerType !== \"mouse\";\n}\nconst im = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ContextMenuTrigger\",\n  props: {\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, { disabled: e } = ae(t), { forwardRef: n } = R(), l = us(), s = T({ x: 0, y: 0 }), r = B(() => ({\n      getBoundingClientRect: () => ({\n        width: 0,\n        height: 0,\n        left: s.value.x,\n        right: s.value.x,\n        top: s.value.y,\n        bottom: s.value.y,\n        ...s.value\n      })\n    })), i = T(0);\n    function u() {\n      window.clearTimeout(i.value);\n    }\n    function d(p) {\n      s.value = { x: p.clientX, y: p.clientY }, l.onOpenChange(!0);\n    }\n    async function c(p) {\n      e.value || (await oe(), p.defaultPrevented || (u(), d(p), p.preventDefault()));\n    }\n    async function f(p) {\n      e.value || (await oe(), Zo(p) && !p.defaultPrevented && (u(), i.value = window.setTimeout(() => d(p), 700)));\n    }\n    async function v(p) {\n      e.value || (await oe(), Zo(p) && !p.defaultPrevented && u());\n    }\n    return (p, g) => (b(), ve(_e, null, [\n      q(o(Qa), {\n        as: \"template\",\n        element: r.value\n      }, null, 8, [\"element\"]),\n      q(o(O), k({\n        ref: o(n),\n        as: p.as,\n        \"as-child\": p.asChild,\n        \"data-state\": o(l).open.value ? \"open\" : \"closed\",\n        \"data-disabled\": o(e) ? \"\" : void 0,\n        style: {\n          WebkitTouchCallout: \"none\"\n        }\n      }, p.$attrs, {\n        onContextmenu: c,\n        onPointerdown: f,\n        onPointermove: v,\n        onPointercancel: v,\n        onPointerup: v\n      }), {\n        default: y(() => [\n          w(p.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-state\", \"data-disabled\"])\n    ], 64));\n  }\n}), um = /* @__PURE__ */ x({\n  __name: \"ContextMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(vo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), dm = /* @__PURE__ */ x({\n  __name: \"ContextMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    alignOffset: { default: 0 },\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 },\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    R();\n    const s = us(), r = T(!1);\n    return (i, u) => (b(), S(o(fo), k(o(l), {\n      side: \"right\",\n      \"side-offset\": 2,\n      align: \"start\",\n      style: {\n        \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: u[0] || (u[0] = (d) => {\n        !d.defaultPrevented && r.value && d.preventDefault(), r.value = !1;\n      }),\n      onInteractOutside: u[1] || (u[1] = (d) => {\n        !d.defaultPrevented && !o(s).modal.value && (r.value = !0);\n      })\n    }), {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), cm = /* @__PURE__ */ x({\n  __name: \"ContextMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(lo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fm = /* @__PURE__ */ x({\n  __name: \"ContextMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(xa), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), pm = /* @__PURE__ */ x({\n  __name: \"ContextMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(tn), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vm = /* @__PURE__ */ x({\n  __name: \"ContextMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(yo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mm = /* @__PURE__ */ x({\n  __name: \"ContextMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(co), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hm = /* @__PURE__ */ x({\n  __name: \"ContextMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(uo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ym = /* @__PURE__ */ x({\n  __name: \"ContextMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(po), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gm = /* @__PURE__ */ x({\n  __name: \"ContextMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(mo), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bm = /* @__PURE__ */ x({\n  __name: \"ContextMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(ho), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Cm = /* @__PURE__ */ x({\n  __name: \"ContextMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (s, r) => (b(), S(o(go), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => et(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), wm = /* @__PURE__ */ x({\n  __name: \"ContextMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    return R(), (s, r) => (b(), S(o(bo), k(o(l), { style: {\n      \"--radix-context-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-context-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-context-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-context-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-context-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), _m = /* @__PURE__ */ x({\n  __name: \"ContextMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Co), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nd = [\"hour\", \"minute\", \"second\"];\nfunction Ht(a) {\n  const { formatter: t } = a, e = Wn.map((n) => [n, a.value[n]]);\n  if (\"hour\" in a.value) {\n    const n = xl.map((s) => s === \"dayPeriod\" ? [s, t.dayPeriod(ze(a.value))] : [s, a.value[s]]), l = [...e, ...n];\n    return Object.fromEntries(l);\n  }\n  return Object.fromEntries(e);\n}\nfunction ds(a) {\n  const t = Sl.map((e) => e === \"dayPeriod\" ? [e, \"AM\"] : [e, null]).filter(([e]) => e === \"literal\" || e === null || a === \"minute\" && e === \"second\" || a === \"hour\" && (e === \"second\" || e === \"minute\") ? !1 : a === \"day\" ? !Nd.includes(e) && e !== \"dayPeriod\" : !0);\n  return Object.fromEntries(t);\n}\nfunction Ld(a) {\n  const { segmentValues: t, formatter: e, locale: n } = a;\n  function l(r) {\n    if (\"hour\" in t) {\n      const i = t[r];\n      return i !== null ? r === \"day\" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r, {\n        hourCycle: a.hourCycle === 24 ? \"h24\" : void 0\n      }) : e.part(a.dateRef.set({ [r]: i }), r, {\n        hourCycle: a.hourCycle === 24 ? \"h24\" : void 0\n      }) : bn(r, \"\", n.value);\n    } else {\n      if (ti(r)) {\n        const i = t[r];\n        return i !== null ? r === \"day\" && t.month !== null ? e.part(a.dateRef.set({ [r]: i, month: t.month }), r) : e.part(a.dateRef.set({ [r]: i }), r) : bn(r, \"\", n.value);\n      }\n      return \"\";\n    }\n  }\n  return Object.keys(t).reduce((r, i) => {\n    if (!El(i))\n      return r;\n    if (\"hour\" in t && i === \"dayPeriod\") {\n      const u = t[i];\n      u !== null ? r[i] = u : r[i] = bn(i, \"AM\", n.value);\n    } else\n      r[i] = l(i);\n    return r;\n  }, {});\n}\nfunction zd(a) {\n  const { granularity: t, formatter: e, contentObj: n, hideTimeZone: l, hourCycle: s } = a;\n  return e.toParts(a.dateRef, ai(t, s)).map((u) => [\"literal\", \"timeZoneName\", null].includes(u.type) || !El(u.type) ? {\n    part: u.type,\n    value: u.value\n  } : {\n    part: u.type,\n    value: n[u.type]\n  }).filter((u) => !(u.part === null || u.value === null || u.part === \"timeZoneName\" && (!wl(a.dateRef) || l)));\n}\nfunction Rn(a) {\n  const t = Ld(a), e = zd({\n    contentObj: t,\n    ...a\n  });\n  return {\n    obj: t,\n    arr: e\n  };\n}\nfunction st(a) {\n  const t = nt();\n  return a === t.ARROW_RIGHT || a === t.ARROW_LEFT;\n}\nfunction Dt(a) {\n  return !Number.isNaN(Number.parseInt(a));\n}\nfunction ut(a) {\n  const t = nt();\n  return !!([\n    t.ENTER,\n    t.ARROW_UP,\n    t.ARROW_DOWN,\n    t.ARROW_LEFT,\n    t.ARROW_RIGHT,\n    t.BACKSPACE,\n    t.SPACE,\n    \"a\",\n    \"A\",\n    \"p\",\n    \"P\"\n  ].includes(a) || Dt(a));\n}\nfunction Ka(a) {\n  return Array.from(a.querySelectorAll(\"[data-radix-vue-date-field-segment]\")).filter((t) => t.getAttribute(\"data-radix-vue-date-field-segment\") !== \"literal\");\n}\nconst Kd = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [Hd, Wd] = te(\"DateFieldRoot\"), jd = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DateFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u, granularity: d, defaultValue: c, dir: f } = ae(n), v = qn(n.locale), p = we(f), { primitiveElement: g, currentElement: m } = Re(), _ = T(/* @__PURE__ */ new Set());\n    le(() => {\n      Ka(m.value).forEach((K) => _.value.add(K));\n    });\n    const C = ne(n, \"modelValue\", l, {\n      defaultValue: c.value,\n      passive: n.modelValue === void 0\n    }), $ = Yt({\n      defaultPlaceholder: n.placeholder,\n      granularity: d.value,\n      defaultValue: C.value,\n      locale: n.locale\n    }), h = ne(n, \"placeholder\", l, {\n      defaultValue: n.defaultPlaceholder ?? $.copy(),\n      passive: n.placeholder === void 0\n    }), E = B(() => n.granularity ? ia(h.value) ? n.granularity : \"day\" : ia(h.value) ? \"minute\" : \"day\"), P = B(() => {\n      var K;\n      return C.value ? !!((K = u.value) != null && K.call(u, C.value) || n.minValue && Ke(C.value, n.minValue) || n.maxValue && Ke(n.maxValue, C.value)) : !1;\n    }), D = ds(E.value), I = T(C.value ? { ...Ht({ value: C.value, formatter: v }) } : { ...D }), M = B(() => Rn({\n      granularity: E.value,\n      dateRef: h.value,\n      formatter: v,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: I.value,\n      locale: s\n    })), V = B(() => M.value.arr), A = B(() => V.value.filter(({ part: K }) => K !== \"literal\"));\n    ee(s, (K) => {\n      v.getLocale() !== K && (v.setLocale(K), oe(() => {\n        _.value.clear(), Ka(m.value).forEach((L) => _.value.add(L));\n      }));\n    }), ee(C, (K) => {\n      !ht(K) && h.value.compare(K) !== 0 && (h.value = K.copy());\n    }), ee([C, s], ([K]) => {\n      ht(K) ? Object.values(I.value).every((L) => L !== null) && K === void 0 && (I.value = { ...D }) : I.value = { ...Ht({ value: K, formatter: v }) };\n    });\n    const F = T(null), j = B(() => Array.from(_.value).findIndex((K) => {\n      var L;\n      return K.getAttribute(\"data-radix-vue-date-field-segment\") === ((L = F.value) == null ? void 0 : L.getAttribute(\"data-radix-vue-date-field-segment\"));\n    })), H = B(() => {\n      const K = p.value === \"rtl\" ? -1 : 1;\n      return (K < 0 ? j.value < 0 : j.value > _.value.size - 1) ? null : Array.from(_.value)[j.value + K];\n    }), Q = B(() => {\n      const K = p.value === \"rtl\" ? -1 : 1;\n      return (K > 0 ? j.value < 0 : j.value > _.value.size - 1) ? null : Array.from(_.value)[j.value - K];\n    }), G = nt();\n    function J(K) {\n      var L, N;\n      st(K.key) && (K.key === G.ARROW_LEFT && ((L = Q.value) == null || L.focus()), K.key === G.ARROW_RIGHT && ((N = H.value) == null || N.focus()));\n    }\n    function z(K) {\n      F.value = K;\n    }\n    return Wd({\n      isDateUnavailable: u.value,\n      locale: s,\n      modelValue: C,\n      placeholder: h,\n      disabled: r,\n      formatter: v,\n      hourCycle: n.hourCycle,\n      readonly: i,\n      segmentValues: I,\n      isInvalid: P,\n      segmentContents: A,\n      elements: _,\n      setFocusedElement: z,\n      focusNext() {\n        var K;\n        (K = H.value) == null || K.focus();\n      }\n    }), t({\n      /** Helper to set the focused element inside the DateField */\n      setFocusedElement: z\n    }), (K, L) => (b(), ve(_e, null, [\n      q(o(O), k(K.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: g,\n        role: \"group\",\n        \"aria-disabled\": o(r) ? !0 : void 0,\n        \"data-disabled\": o(r) ? \"\" : void 0,\n        \"data-readonly\": o(i) ? \"\" : void 0,\n        \"data-invalid\": P.value ? \"\" : void 0,\n        dir: o(p),\n        onKeydown: ie(J, [\"left\", \"right\"])\n      }), {\n        default: y(() => [\n          w(K.$slots, \"default\", {\n            modelValue: o(C),\n            segments: V.value,\n            isInvalid: P.value\n          })\n        ]),\n        _: 3\n      }, 16, [\"aria-disabled\", \"data-disabled\", \"data-readonly\", \"data-invalid\", \"dir\"]),\n      Ye(\"input\", {\n        id: K.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(C) ? o(C).toString() : \"\",\n        name: K.name,\n        disabled: o(r),\n        required: K.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        },\n        onFocus: L[0] || (L[0] = (N) => {\n          var Z, Y;\n          return (Y = (Z = Array.from(_.value)) == null ? void 0 : Z[0]) == null ? void 0 : Y.focus();\n        })\n      }, null, 40, Kd)\n    ], 64));\n  }\n});\nfunction wt(a) {\n  return {\n    role: \"spinbutton\",\n    contenteditable: !0,\n    tabindex: a.disabled ? void 0 : 0,\n    spellcheck: !1,\n    inputmode: \"numeric\",\n    autocorrect: \"off\",\n    enterkeyhint: \"next\",\n    style: \"caret-color: transparent;\"\n  };\n}\nfunction Ud(a) {\n  const { segmentValues: t, placeholder: e } = a, n = t.day === null, l = t.day ? e.set({ day: t.day }) : e, s = l.day, r = 1, i = Ze(l), u = n ? \"Empty\" : `${s}`;\n  return {\n    ...wt(a),\n    \"aria-label\": \"day,\",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Gd(a) {\n  const { segmentValues: t, placeholder: e, formatter: n } = a, l = t.month === null, s = t.month ? e.set({ month: t.month }) : e, r = s.month, i = 1, u = 12, d = l ? \"Empty\" : `${r} - ${n.fullMonth(ze(s))}`;\n  return {\n    ...wt(a),\n    \"aria-label\": \"month, \",\n    contenteditable: !0,\n    \"aria-valuemin\": i,\n    \"aria-valuemax\": u,\n    \"aria-valuenow\": r,\n    \"aria-valuetext\": d,\n    \"data-placeholder\": l ? \"\" : void 0\n  };\n}\nfunction qd(a) {\n  const { segmentValues: t, placeholder: e } = a, n = t.year === null, l = t.year ? e.set({ year: t.year }) : e, s = 1, r = 9999, i = l.year, u = n ? \"Empty\" : `${i}`;\n  return {\n    ...wt(a),\n    \"aria-label\": \"year, \",\n    \"aria-valuemin\": s,\n    \"aria-valuemax\": r,\n    \"aria-valuenow\": i,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Yd(a) {\n  const { segmentValues: t, hourCycle: e, placeholder: n } = a;\n  if (!(\"hour\" in t) || !(\"hour\" in n))\n    return {};\n  const l = t.hour === null, s = t.hour ? n.set({ hour: t.hour }) : n, r = e === 12 ? 1 : 0, i = e === 12 ? 12 : 23, u = s.hour, d = l ? \"Empty\" : `${u} ${t.dayPeriod ?? \"\"}`;\n  return {\n    ...wt(a),\n    \"aria-label\": \"hour, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": u,\n    \"aria-valuetext\": d,\n    \"data-placeholder\": l ? \"\" : void 0\n  };\n}\nfunction Xd(a) {\n  const { segmentValues: t, placeholder: e } = a;\n  if (!(\"minute\" in t) || !(\"minute\" in e))\n    return {};\n  const n = t.minute === null, s = (t.minute ? e.set({ minute: t.minute }) : e).minute, r = 0, i = 59, u = n ? \"Empty\" : `${s}`;\n  return {\n    ...wt(a),\n    \"aria-label\": \"minute, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Zd(a) {\n  const { segmentValues: t, placeholder: e } = a;\n  if (!(\"second\" in t) || !(\"second\" in e))\n    return {};\n  const n = t.second === null, s = (t.second ? e.set({ second: t.second }) : e).second, r = 0, i = 59, u = n ? \"Empty\" : `${s}`;\n  return {\n    ...wt(a),\n    \"aria-label\": \"second, \",\n    \"aria-valuemin\": r,\n    \"aria-valuemax\": i,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": u,\n    \"data-placeholder\": n ? \"\" : void 0\n  };\n}\nfunction Jd(a) {\n  const { segmentValues: t } = a;\n  if (!(\"dayPeriod\" in t))\n    return {};\n  const e = 0, n = 12, l = t.hour ? t.hour > 12 ? t.hour - 12 : t.hour : 0, s = t.dayPeriod ?? \"AM\";\n  return {\n    ...wt(a),\n    inputmode: \"text\",\n    \"aria-label\": \"AM/PM\",\n    \"aria-valuemin\": e,\n    \"aria-valuemax\": n,\n    \"aria-valuenow\": l,\n    \"aria-valuetext\": s\n  };\n}\nfunction Qd(a) {\n  return {\n    \"aria-hidden\": !0,\n    \"data-segment\": \"literal\"\n  };\n}\nfunction ec(a) {\n  return {\n    role: \"textbox\",\n    \"aria-label\": \"timezone, \",\n    \"data-readonly\": !0,\n    \"data-segment\": \"timeZoneName\",\n    tabindex: a.disabled ? void 0 : 0,\n    style: \"caret-color: transparent;\"\n  };\n}\nfunction tc(a) {\n  const { segmentValues: t, placeholder: e } = a, n = 0, l = 0, s = 0, r = \"era\" in t ? t.era : e.era;\n  return {\n    ...wt(a),\n    \"aria-label\": \"era\",\n    \"aria-valuemin\": n,\n    \"aria-valuemax\": l,\n    \"aria-valuenow\": s,\n    \"aria-valuetext\": r\n  };\n}\nconst ac = {\n  day: {\n    attrs: Ud\n  },\n  month: {\n    attrs: Gd\n  },\n  year: {\n    attrs: qd\n  },\n  hour: {\n    attrs: Yd\n  },\n  minute: {\n    attrs: Xd\n  },\n  second: {\n    attrs: Zd\n  },\n  dayPeriod: {\n    attrs: Jd\n  },\n  literal: {\n    attrs: Qd\n  },\n  timeZoneName: {\n    attrs: ec\n  },\n  era: {\n    attrs: tc\n  }\n};\nfunction cs(a) {\n  const t = nt();\n  function e({ e: h, part: E, dateRef: P, prevValue: D }) {\n    const I = h.key === t.ARROW_UP ? 1 : -1, M = 0, V = 59;\n    if (D === null)\n      return I > 0 ? M : V;\n    const A = [E, I];\n    return P.set({ [E]: D }).cycle(...A)[E];\n  }\n  function n(h) {\n    if (a.hasLeftFocus.value = !1, h === null)\n      return h;\n    const E = h.toString();\n    return E.length === 1 ? (a.modelValue.value = void 0, null) : Number.parseInt(E.slice(0, -1));\n  }\n  function l({ e: h, part: E, dateRef: P, prevValue: D, hourCycle: I }) {\n    const M = h.key === t.ARROW_UP ? 1 : -1;\n    if (D === null)\n      return P[E];\n    if (E === \"hour\" && \"hour\" in P) {\n      const A = [E, M, { hourCycle: I }];\n      return P.set({ [E]: D }).cycle(...A)[E];\n    }\n    const V = [E, M];\n    return E === \"day\" && a.segmentValues.value.month !== null ? P.set({ [E]: D, month: a.segmentValues.value.month }).cycle(...V)[E] : P.set({ [E]: D }).cycle(...V)[E];\n  }\n  function s(h, E, P) {\n    let D = !1;\n    const I = Math.floor(h / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, P = null), P === null)\n      return E === 0 ? (a.lastKeyZero.value = !0, { value: null, moveToNext: D }) : ((a.lastKeyZero.value || E > I) && (D = !0), a.lastKeyZero.value = !1, { value: E, moveToNext: D });\n    const M = P.toString().length, V = Number.parseInt(P.toString() + E.toString());\n    return M === 2 || V > h ? ((E > I || V > h) && (D = !0), { value: E, moveToNext: D }) : (D = !0, { value: V, moveToNext: D });\n  }\n  function r(h, E) {\n    let D = !1;\n    const I = Math.floor(59 / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return h === 0 ? (a.lastKeyZero.value = !0, { value: 0, moveToNext: D }) : ((a.lastKeyZero.value || h > I) && (D = !0), a.lastKeyZero.value = !1, { value: h, moveToNext: D });\n    const M = E.toString().length, V = Number.parseInt(E.toString() + h.toString());\n    return M === 2 || V > 59 ? (h > I && (D = !0), { value: h, moveToNext: D }) : (D = !0, { value: V, moveToNext: D });\n  }\n  function i(h, E) {\n    let D = !1;\n    const I = Math.floor(24 / 10);\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return h === 0 ? (a.lastKeyZero.value = !0, { value: 0, moveToNext: D }) : ((a.lastKeyZero.value || h > I) && (D = !0), a.lastKeyZero.value = !1, { value: h, moveToNext: D });\n    const M = E.toString().length, V = Number.parseInt(E.toString() + h.toString());\n    return M === 2 || V > 24 ? (h > I && (D = !0), { value: h, moveToNext: D }) : (D = !0, { value: V, moveToNext: D });\n  }\n  function u(h, E) {\n    let P = !1;\n    if (a.hasLeftFocus.value && (a.hasLeftFocus.value = !1, E = null), E === null)\n      return { value: h === 0 ? 1 : h, moveToNext: P };\n    const D = E.toString() + h.toString();\n    return D.length > 4 ? { value: h === 0 ? 1 : h, moveToNext: P } : (D.length === 4 && (P = !0), { value: Number.parseInt(D), moveToNext: P });\n  }\n  const d = B(() => {\n    var h;\n    return ((h = ac[a.part]) == null ? void 0 : h.attrs({\n      disabled: a.disabled.value,\n      placeholder: a.placeholder.value,\n      hourCycle: a.hourCycle,\n      segmentValues: a.segmentValues.value,\n      formatter: a.formatter\n    })) ?? {};\n  });\n  function c(h) {\n    if (!ut(h.key) || st(h.key))\n      return;\n    const E = a.segmentValues.value.day;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.day = l({ e: h, part: \"day\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (Dt(h.key)) {\n      const P = Number.parseInt(h.key), D = a.segmentValues.value.month, I = D ? Ze(a.placeholder.value.set({ month: D })) : Ze(a.placeholder.value), { value: M, moveToNext: V } = s(I, P, E);\n      a.segmentValues.value.day = M, V && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.day = n(E));\n  }\n  function f(h) {\n    if (!ut(h.key) || st(h.key))\n      return;\n    const E = a.segmentValues.value.month;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.month = l({ e: h, part: \"month\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (Dt(h.key)) {\n      const P = Number.parseInt(h.key), { value: D, moveToNext: I } = s(12, P, E);\n      a.segmentValues.value.month = D, I && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.month = n(E));\n  }\n  function v(h) {\n    if (!ut(h.key) || st(h.key))\n      return;\n    const E = a.segmentValues.value.year;\n    if (h.key === t.ARROW_DOWN || h.key === t.ARROW_UP) {\n      a.segmentValues.value.year = l({ e: h, part: \"year\", dateRef: a.placeholder.value, prevValue: E });\n      return;\n    }\n    if (Dt(h.key)) {\n      const P = Number.parseInt(h.key), { value: D, moveToNext: I } = u(P, E);\n      a.segmentValues.value.year = D, I && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.year = n(E));\n  }\n  function p(h) {\n    const E = a.placeholder.value;\n    if (!ut(h.key) || st(h.key) || !(\"hour\" in E) || !(\"hour\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.hour, D = a.hourCycle;\n    if (h.key === t.ARROW_UP || h.key === t.ARROW_DOWN) {\n      a.segmentValues.value.hour = l({ e: h, part: \"hour\", dateRef: a.placeholder.value, prevValue: P, hourCycle: D }), \"dayPeriod\" in a.segmentValues.value && (a.segmentValues.value.hour < 12 ? a.segmentValues.value.dayPeriod = \"AM\" : a.segmentValues.value.hour && (a.segmentValues.value.dayPeriod = \"PM\"));\n      return;\n    }\n    if (Dt(h.key)) {\n      const I = Number.parseInt(h.key), { value: M, moveToNext: V } = i(I, P);\n      \"dayPeriod\" in a.segmentValues.value && M && M > 12 ? a.segmentValues.value.dayPeriod = \"PM\" : \"dayPeriod\" in a.segmentValues.value && M && (a.segmentValues.value.dayPeriod = \"AM\"), a.segmentValues.value.hour = M, V && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.hour = n(P));\n  }\n  function g(h) {\n    const E = a.placeholder.value;\n    if (!ut(h.key) || st(h.key) || !(\"minute\" in E) || !(\"minute\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.minute;\n    if (a.segmentValues.value.minute = e({ e: h, part: \"minute\", dateRef: a.placeholder.value, prevValue: P }), Dt(h.key)) {\n      const D = Number.parseInt(h.key), { value: I, moveToNext: M } = r(D, P);\n      a.segmentValues.value.minute = I, M && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.minute = n(P));\n  }\n  function m(h) {\n    const E = a.placeholder.value;\n    if (!ut(h.key) || st(h.key) || !(\"second\" in E) || !(\"second\" in a.segmentValues.value))\n      return;\n    const P = a.segmentValues.value.second;\n    if (a.segmentValues.value.second = e({ e: h, part: \"second\", dateRef: a.placeholder.value, prevValue: P }), Dt(h.key)) {\n      const D = Number.parseInt(h.key), { value: I, moveToNext: M } = r(D, P);\n      a.segmentValues.value.second = I, M && a.focusNext();\n    }\n    h.key === t.BACKSPACE && (a.hasLeftFocus.value = !1, a.segmentValues.value.second = n(P));\n  }\n  function _(h) {\n    if (!((!ut(h.key) || st(h.key)) && h.key !== \"a\" && h.key !== \"p\" || !(\"hour\" in a.placeholder.value) || !(\"dayPeriod\" in a.segmentValues.value))) {\n      if (h.key === t.ARROW_UP || h.key === t.ARROW_DOWN) {\n        if (a.segmentValues.value.dayPeriod === \"AM\") {\n          a.segmentValues.value.dayPeriod = \"PM\", a.segmentValues.value.hour = a.segmentValues.value.hour + 12;\n          return;\n        }\n        a.segmentValues.value.dayPeriod = \"AM\", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;\n        return;\n      }\n      if ([\"a\", \"A\"].includes(h.key) && a.segmentValues.value.dayPeriod !== \"AM\") {\n        a.segmentValues.value.dayPeriod = \"AM\", a.segmentValues.value.hour = a.segmentValues.value.hour - 12;\n        return;\n      }\n      [\"p\", \"P\"].includes(h.key) && a.segmentValues.value.dayPeriod !== \"PM\" && (a.segmentValues.value.dayPeriod = \"PM\", a.segmentValues.value.hour = a.segmentValues.value.hour + 12);\n    }\n  }\n  function C(h) {\n    a.disabled.value && h.preventDefault();\n  }\n  function $(h) {\n    const E = a.disabled.value, P = a.readonly.value;\n    if (h.key !== t.TAB && h.preventDefault(), E || P)\n      return;\n    if ({\n      day: c,\n      month: f,\n      year: v,\n      hour: p,\n      minute: g,\n      second: m,\n      dayPeriod: _,\n      timeZoneName: () => {\n      }\n    }[a.part](h), ![t.ARROW_LEFT, t.ARROW_RIGHT].includes(h.key) && h.key !== t.TAB && h.key !== t.SHIFT && ut(h.key) && Object.values(a.segmentValues.value).every((I) => I !== null)) {\n      const I = { ...a.segmentValues.value };\n      let M = a.placeholder.value.copy();\n      Object.keys(I).forEach((V) => {\n        const A = I[V];\n        M = M.set({ [V]: A });\n      }), a.modelValue.value = M.copy();\n    }\n  }\n  return {\n    handleSegmentClick: C,\n    handleSegmentKeydown: $,\n    attributes: d\n  };\n}\nconst nc = /* @__PURE__ */ x({\n  __name: \"DateFieldInput\",\n  props: {\n    part: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Hd(), n = T(!0), l = T(!1), {\n      handleSegmentClick: s,\n      handleSegmentKeydown: r,\n      attributes: i\n    } = cs({\n      hasLeftFocus: n,\n      lastKeyZero: l,\n      placeholder: e.placeholder,\n      hourCycle: e.hourCycle,\n      segmentValues: e.segmentValues,\n      formatter: e.formatter,\n      part: t.part,\n      disabled: e.disabled,\n      readonly: e.readonly,\n      focusNext: e.focusNext,\n      modelValue: e.modelValue\n    }), u = B(() => e.disabled.value), d = B(() => e.readonly.value), c = B(() => e.isInvalid.value);\n    return (f, v) => (b(), S(o(O), k({\n      as: f.as,\n      \"as-child\": f.asChild\n    }, o(i), {\n      contenteditable: u.value || d.value ? !1 : f.part !== \"literal\",\n      \"data-radix-vue-date-field-segment\": f.part,\n      \"aria-disabled\": u.value ? !0 : void 0,\n      \"aria-readonly\": d.value ? !0 : void 0,\n      \"data-disabled\": u.value ? \"\" : void 0,\n      \"data-invalid\": c.value ? \"\" : void 0,\n      \"aria-invalid\": c.value ? !0 : void 0\n    }, Kn(f.part !== \"literal\" ? {\n      mousedown: o(s),\n      keydown: o(r),\n      focusout: () => {\n        n.value = !0;\n      },\n      focusin: (p) => {\n        o(e).setFocusedElement(p.target);\n      }\n    } : {})), {\n      default: y(() => [\n        w(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"contenteditable\", \"data-radix-vue-date-field-segment\", \"aria-disabled\", \"aria-readonly\", \"data-disabled\", \"data-invalid\", \"aria-invalid\"]));\n  }\n}), xm = /* @__PURE__ */ x({\n  __name: \"DatePickerHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Wu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sm = /* @__PURE__ */ x({\n  __name: \"DatePickerHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ju), W(U(t)), {\n      default: y(({ headingValue: l }) => [\n        w(e.$slots, \"default\", { headingValue: l }, () => [\n          ye(De(l), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Em = /* @__PURE__ */ x({\n  __name: \"DatePickerGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Uu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pm = /* @__PURE__ */ x({\n  __name: \"DatePickerCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Gu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Dm = /* @__PURE__ */ x({\n  __name: \"DatePickerHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(qu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), $m = /* @__PURE__ */ x({\n  __name: \"DatePickerNext\",\n  props: {\n    step: {},\n    nextPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Yu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Bm = /* @__PURE__ */ x({\n  __name: \"DatePickerPrev\",\n  props: {\n    step: {},\n    prevPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Xu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Im = /* @__PURE__ */ x({\n  __name: \"DatePickerGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Zu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Tm = /* @__PURE__ */ x({\n  __name: \"DatePickerGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Ju), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Rm = /* @__PURE__ */ x({\n  __name: \"DatePickerGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Qu), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Am = /* @__PURE__ */ x({\n  __name: \"DatePickerCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(ed), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Om = /* @__PURE__ */ x({\n  __name: \"DatePickerInput\",\n  props: {\n    part: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(nc), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [wo, oc] = te(\"DatePickerRoot\"), km = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DatePickerRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {},\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    fixedWeeks: { type: Boolean, default: !1 },\n    numberOfMonths: { default: 1 },\n    preventDeselect: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: f,\n      preventDeselect: v,\n      isDateDisabled: p,\n      isDateUnavailable: g,\n      defaultOpen: m,\n      modal: _,\n      id: C,\n      name: $,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: D,\n      hideTimeZone: I,\n      hourCycle: M,\n      defaultValue: V,\n      dir: A\n    } = ae(e), F = we(A), j = ne(e, \"modelValue\", n, {\n      defaultValue: V.value,\n      passive: e.modelValue === void 0\n    }), H = B(() => Yt({\n      defaultPlaceholder: e.placeholder,\n      granularity: e.granularity,\n      defaultValue: j.value,\n      locale: e.locale\n    })), Q = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? H.value.copy(),\n      passive: e.placeholder === void 0\n    }), G = ne(e, \"open\", n, {\n      defaultValue: m.value,\n      passive: e.open === void 0\n    }), J = T();\n    return ee(j, (z) => {\n      z && z.compare(Q.value) !== 0 && (Q.value = z.copy());\n    }), oc({\n      isDateUnavailable: g.value,\n      isDateDisabled: p.value,\n      locale: l,\n      disabled: s,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: f,\n      readonly: r,\n      preventDeselect: v,\n      modelValue: j,\n      placeholder: Q,\n      defaultOpen: m,\n      modal: _,\n      open: G,\n      id: C,\n      name: $,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: D,\n      hideTimeZone: I,\n      hourCycle: M,\n      dateFieldRef: J,\n      dir: F,\n      onDateChange(z) {\n        !z || !j.value ? j.value = (z == null ? void 0 : z.copy()) ?? void 0 : !v.value && z && j.value.compare(z) === 0 ? j.value = void 0 : j.value = z.copy();\n      },\n      onPlaceholderChange(z) {\n        Q.value = z.copy();\n      }\n    }), (z, K) => (b(), S(o(Cs), {\n      open: o(G),\n      \"onUpdate:open\": K[0] || (K[0] = (L) => et(G) ? G.value = L : null),\n      \"default-open\": o(m),\n      modal: o(_)\n    }, {\n      default: y(() => [\n        w(z.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"default-open\", \"modal\"]));\n  }\n}), Mm = /* @__PURE__ */ x({\n  __name: \"DatePickerCalendar\",\n  setup(a) {\n    const t = wo();\n    return (e, n) => (b(), S(o(Hu), k({\n      isDateDisabled: o(t).isDateDisabled,\n      isDateUnavailable: o(t).isDateUnavailable,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      locale: o(t).locale.value,\n      disabled: o(t).disabled.value,\n      pagedNavigation: o(t).pagedNavigation.value,\n      weekStartsOn: o(t).weekStartsOn.value,\n      weekdayFormat: o(t).weekdayFormat.value,\n      fixedWeeks: o(t).fixedWeeks.value,\n      numberOfMonths: o(t).numberOfMonths.value,\n      readonly: o(t).readonly.value,\n      preventDeselect: o(t).preventDeselect.value,\n      dir: o(t).dir.value\n    }, {\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value,\n      \"initial-focus\": \"\",\n      multiple: !1,\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l && o(t).modelValue.value && o(ke)(l, o(t).modelValue.value) || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(ke)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ weekDays: l, grid: s, date: r, weekStartsOn: i, locale: u, fixedWeeks: d }) => [\n        w(e.$slots, \"default\", {\n          date: r,\n          grid: s,\n          weekDays: l,\n          weekStartsOn: i,\n          locale: u,\n          fixedWeeks: d\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), Vm = /* @__PURE__ */ x({\n  __name: \"DatePickerField\",\n  setup(a) {\n    const t = wo();\n    return (e, n) => (b(), S(o(jd), k({\n      ref: o(t).dateFieldRef,\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value\n    }, {\n      id: o(t).id.value,\n      name: o(t).name.value,\n      disabled: o(t).disabled.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      readonly: o(t).readonly.value,\n      hourCycle: o(t).hourCycle.value,\n      granularity: o(t).granularity.value,\n      hideTimeZone: o(t).hideTimeZone.value,\n      locale: o(t).locale.value,\n      isDateUnavailable: o(t).isDateUnavailable,\n      required: o(t).required.value,\n      dir: o(t).dir.value\n    }, {\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l && o(t).modelValue.value && l.compare(o(t).modelValue.value) === 0 || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        l.compare(o(t).placeholder.value) !== 0 && o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ segments: l, modelValue: s }) => [\n        w(e.$slots, \"default\", {\n          segments: l,\n          modelValue: s\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), Fm = /* @__PURE__ */ x({\n  __name: \"DatePickerAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Ds), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Nm = /* @__PURE__ */ x({\n  __name: \"DatePickerArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Es), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Lm = /* @__PURE__ */ x({\n  __name: \"DatePickerClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Ps), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zm = /* @__PURE__ */ x({\n  __name: \"DatePickerTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = wo();\n    return (n, l) => (b(), S(o(ws), k({ \"data-radix-vue-date-field-segment\": \"trigger\" }, t, {\n      disabled: o(e).disabled.value,\n      onFocusin: l[0] || (l[0] = (s) => {\n        var r;\n        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);\n      })\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"disabled\"]));\n  }\n}), Km = /* @__PURE__ */ x({\n  __name: \"DatePickerContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    return (s, r) => (b(), S(o(_s), null, {\n      default: y(() => [\n        q(o(Ss), W(U({ ...o(l), ...s.$attrs })), {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Hm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(gf), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Wm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(bf), W(U(t)), {\n      default: y(({ headingValue: l }) => [\n        w(e.$slots, \"default\", { headingValue: l }, () => [\n          ye(De(l), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), jm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Cf), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Um = /* @__PURE__ */ x({\n  __name: \"DateRangePickerCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(wf), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Gm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(_f), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), qm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerNext\",\n  props: {\n    step: {},\n    nextPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(xf), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ym = /* @__PURE__ */ x({\n  __name: \"DateRangePickerPrev\",\n  props: {\n    step: {},\n    prevPage: { type: Function },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Sf), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Ef), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Zm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Pf), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Jm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Df), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qm = /* @__PURE__ */ x({\n  __name: \"DateRangePickerCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o($f), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), eh = /* @__PURE__ */ x({\n  __name: \"DateRangePickerInput\",\n  props: {\n    part: {},\n    type: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(dc), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [_o, lc] = te(\"DateRangePickerRoot\"), th = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DateRangePickerRoot\",\n  props: {\n    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {},\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    fixedWeeks: { type: Boolean, default: !1 },\n    numberOfMonths: { default: 1 },\n    preventDeselect: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:startValue\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      locale: l,\n      disabled: s,\n      readonly: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: f,\n      preventDeselect: v,\n      isDateDisabled: p,\n      isDateUnavailable: g,\n      defaultOpen: m,\n      modal: _,\n      id: C,\n      name: $,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: D,\n      hideTimeZone: I,\n      hourCycle: M,\n      dir: V\n    } = ae(e), A = we(V), F = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? { start: void 0, end: void 0 },\n      passive: e.modelValue === void 0\n    }), j = Yt({\n      defaultPlaceholder: e.placeholder,\n      granularity: e.granularity,\n      defaultValue: F.value.start,\n      locale: e.locale\n    }), H = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? j.copy(),\n      passive: e.placeholder === void 0\n    }), Q = ne(e, \"open\", n, {\n      defaultValue: m.value,\n      passive: e.open === void 0\n    }), G = T();\n    return ee(F, (J) => {\n      J.start && J.start.compare(H.value) !== 0 && (H.value = J.start.copy());\n    }), lc({\n      isDateUnavailable: g.value,\n      isDateDisabled: p.value,\n      locale: l,\n      disabled: s,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: f,\n      readonly: r,\n      preventDeselect: v,\n      modelValue: F,\n      placeholder: H,\n      defaultOpen: m,\n      modal: _,\n      open: Q,\n      id: C,\n      name: $,\n      required: h,\n      minValue: E,\n      maxValue: P,\n      granularity: D,\n      hideTimeZone: I,\n      hourCycle: M,\n      dateFieldRef: G,\n      dir: A,\n      onStartValueChange(J) {\n        n(\"update:startValue\", J);\n      },\n      onDateChange(J) {\n        var z, K;\n        F.value = { start: (z = J.start) == null ? void 0 : z.copy(), end: (K = J.end) == null ? void 0 : K.copy() };\n      },\n      onPlaceholderChange(J) {\n        H.value = J.copy();\n      }\n    }), (J, z) => (b(), S(o(Cs), {\n      open: o(Q),\n      \"onUpdate:open\": z[0] || (z[0] = (K) => et(Q) ? Q.value = K : null),\n      \"default-open\": o(m),\n      modal: o(_)\n    }, {\n      default: y(() => [\n        w(J.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"default-open\", \"modal\"]));\n  }\n}), ah = /* @__PURE__ */ x({\n  __name: \"DateRangePickerCalendar\",\n  setup(a) {\n    const t = _o();\n    return (e, n) => (b(), S(o(yf), k({\n      isDateDisabled: o(t).isDateDisabled,\n      isDateUnavailable: o(t).isDateUnavailable,\n      locale: o(t).locale.value,\n      disabled: o(t).disabled.value,\n      pagedNavigation: o(t).pagedNavigation.value,\n      weekStartsOn: o(t).weekStartsOn.value,\n      weekdayFormat: o(t).weekdayFormat.value,\n      fixedWeeks: o(t).fixedWeeks.value,\n      numberOfMonths: o(t).numberOfMonths.value,\n      readonly: o(t).readonly.value,\n      preventDeselect: o(t).preventDeselect.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      dir: o(t).dir.value\n    }, {\n      \"initial-focus\": \"\",\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value,\n      \"onUpdate:startValue\": n[0] || (n[0] = (l) => {\n        o(t).onStartValueChange(l);\n      }),\n      \"onUpdate:modelValue\": n[1] || (n[1] = (l) => {\n        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && o(ke)(l.start, o(t).modelValue.value.start) && o(ke)(l.end, o(t).modelValue.value.end) || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[2] || (n[2] = (l) => {\n        o(ke)(l, o(t).placeholder.value) || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ weekDays: l, grid: s, date: r, weekStartsOn: i, locale: u, fixedWeeks: d }) => [\n        w(e.$slots, \"default\", {\n          date: r,\n          grid: s,\n          weekDays: l,\n          weekStartsOn: i,\n          locale: u,\n          fixedWeeks: d\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), nh = /* @__PURE__ */ x({\n  __name: \"DateRangePickerField\",\n  setup(a) {\n    const t = _o();\n    return (e, n) => (b(), S(o(uc), k({\n      ref: o(t).dateFieldRef,\n      \"model-value\": o(t).modelValue.value,\n      placeholder: o(t).placeholder.value\n    }, {\n      id: o(t).id.value,\n      name: o(t).name.value,\n      disabled: o(t).disabled.value,\n      minValue: o(t).minValue.value,\n      maxValue: o(t).maxValue.value,\n      readonly: o(t).readonly.value,\n      hourCycle: o(t).hourCycle.value,\n      granularity: o(t).granularity.value,\n      hideTimeZone: o(t).hideTimeZone.value,\n      locale: o(t).locale.value,\n      isDateUnavailable: o(t).isDateUnavailable,\n      required: o(t).required.value,\n      dir: o(t).dir.value\n    }, {\n      \"onUpdate:modelValue\": n[0] || (n[0] = (l) => {\n        l.start && o(t).modelValue.value.start && l.end && o(t).modelValue.value.end && l.start.compare(o(t).modelValue.value.start) === 0 && l.end.compare(o(t).modelValue.value.end) === 0 || o(t).onDateChange(l);\n      }),\n      \"onUpdate:placeholder\": n[1] || (n[1] = (l) => {\n        o(ke)(l, o(t).placeholder.value) && l.compare(o(t).placeholder.value) === 0 || o(t).onPlaceholderChange(l);\n      })\n    }), {\n      default: y(({ segments: l, modelValue: s }) => [\n        w(e.$slots, \"default\", {\n          segments: l,\n          modelValue: s\n        })\n      ]),\n      _: 3\n    }, 16, [\"model-value\", \"placeholder\"]));\n  }\n}), oh = /* @__PURE__ */ x({\n  __name: \"DateRangePickerAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Ds), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lh = /* @__PURE__ */ x({\n  __name: \"DateRangePickerArrow\",\n  props: {\n    width: {},\n    height: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Es), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sh = /* @__PURE__ */ x({\n  __name: \"DateRangePickerClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(Ps), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), rh = /* @__PURE__ */ x({\n  __name: \"DateRangePickerTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = _o();\n    return (n, l) => (b(), S(o(ws), k({ \"data-radix-vue-date-field-segment\": \"trigger\" }, t, {\n      disabled: o(e).disabled.value,\n      onFocusin: l[0] || (l[0] = (s) => {\n        var r;\n        (r = o(e).dateFieldRef.value) == null || r.setFocusedElement(s.target);\n      })\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"disabled\"]));\n  }\n}), ih = /* @__PURE__ */ x({\n  __name: \"DateRangePickerContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    return (s, r) => (b(), S(o(_s), null, {\n      default: y(() => [\n        q(o(Ss), W(U({ ...o(l), ...s.$attrs })), {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), sc = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [rc, ic] = te(\"DateRangeFieldRoot\"), uc = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"DateRangeFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    defaultPlaceholder: {},\n    placeholder: { default: void 0 },\n    modelValue: {},\n    hourCycle: {},\n    granularity: {},\n    hideTimeZone: { type: Boolean },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    name: {},\n    required: { type: Boolean },\n    id: {},\n    dir: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\"],\n  setup(a, { expose: t, emit: e }) {\n    var Y, re;\n    const n = a, l = e, { locale: s, disabled: r, readonly: i, isDateUnavailable: u, dir: d } = ae(n), c = qn(n.locale), { primitiveElement: f, currentElement: v } = Re(), p = T(/* @__PURE__ */ new Set()), g = we(d);\n    le(() => {\n      Ka(v.value).forEach((X) => p.value.add(X));\n    });\n    const m = ne(n, \"modelValue\", l, {\n      defaultValue: n.defaultValue ?? { start: void 0, end: void 0 },\n      passive: n.modelValue === void 0\n    }), _ = Yt({\n      defaultPlaceholder: n.placeholder,\n      granularity: n.granularity,\n      defaultValue: m.value.start,\n      locale: n.locale\n    }), C = ne(n, \"placeholder\", l, {\n      defaultValue: n.defaultPlaceholder ?? _.copy(),\n      passive: n.placeholder === void 0\n    }), $ = B(() => n.granularity ? ia(C.value) ? n.granularity : \"day\" : ia(C.value) ? \"minute\" : \"day\"), h = B(() => {\n      var X;\n      return m.value.start ? !!((X = u.value) != null && X.call(u, m.value.start) || n.minValue && Ke(m.value.start, n.minValue) || n.maxValue && Ke(n.maxValue, m.value.start)) : !1;\n    }), E = B(() => {\n      var X;\n      return m.value.end ? !!((X = u.value) != null && X.call(u, m.value.end) || n.minValue && Ke(m.value.end, n.minValue) || n.maxValue && Ke(n.maxValue, m.value.end)) : !1;\n    }), P = B(() => h.value || E.value ? !0 : !m.value.start || !m.value.end ? !1 : !Tr(m.value.start, m.value.end) || u.value !== void 0 && !_l(\n      m.value.start,\n      m.value.end,\n      u.value,\n      void 0\n    )), D = ds($.value), I = T(m.value.start ? { ...Ht({ value: m.value.start, formatter: c }) } : { ...D }), M = T(m.value.end ? { ...Ht({ value: m.value.end, formatter: c }) } : { ...D }), V = B(() => Rn({\n      granularity: $.value,\n      dateRef: C.value,\n      formatter: c,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: I.value,\n      locale: s\n    })), A = B(() => Rn({\n      granularity: $.value,\n      dateRef: C.value,\n      formatter: c,\n      hideTimeZone: n.hideTimeZone,\n      hourCycle: n.hourCycle,\n      segmentValues: M.value,\n      locale: s\n    })), F = B(() => ({\n      start: V.value.arr,\n      end: A.value.arr\n    })), j = B(() => ({ start: F.value.start.filter(({ part: X }) => X !== \"literal\"), end: F.value.end.filter(({ part: X }) => X !== \"literal\") })), H = T((Y = m.value.start) == null ? void 0 : Y.copy()), Q = T((re = m.value.end) == null ? void 0 : re.copy());\n    ee([H, Q], ([X, se]) => {\n      m.value = { start: X == null ? void 0 : X.copy(), end: se == null ? void 0 : se.copy() };\n    }), ee(m, (X) => {\n      X.start && X.end && ((!H.value || X.start.compare(H.value) !== 0) && (H.value = X.start.copy()), (!Q.value || X.end.compare(Q.value) !== 0) && (Q.value = X.end.copy()));\n    }), ee([H, s], ([X]) => {\n      X !== void 0 ? I.value = { ...Ht({ value: X, formatter: c }) } : Object.values(I.value).every((se) => se !== null) && X === void 0 && (I.value = { ...D });\n    }), ee(s, (X) => {\n      c.getLocale() !== X && (c.setLocale(X), oe(() => {\n        p.value.clear(), Ka(v.value).forEach((se) => p.value.add(se));\n      }));\n    }), ee(m, (X) => {\n      X.start !== void 0 && C.value.compare(X.start) !== 0 && (C.value = X.start.copy());\n    }), ee([Q, s], ([X]) => {\n      X !== void 0 ? M.value = { ...Ht({ value: X, formatter: c }) } : Object.values(M.value).every((se) => se !== null) && X === void 0 && (M.value = { ...D });\n    });\n    const G = T(null), J = B(() => Array.from(p.value).findIndex((X) => {\n      var se, fe;\n      return X.getAttribute(\"data-radix-vue-date-field-segment\") === ((se = G.value) == null ? void 0 : se.getAttribute(\"data-radix-vue-date-field-segment\")) && X.getAttribute(\"data-radix-vue-date-range-field-segment-type\") === ((fe = G.value) == null ? void 0 : fe.getAttribute(\"data-radix-vue-date-range-field-segment-type\"));\n    })), z = B(() => {\n      const X = g.value === \"rtl\" ? -1 : 1;\n      return (X < 0 ? J.value < 0 : J.value > p.value.size - 1) ? null : Array.from(p.value)[J.value + X];\n    }), K = B(() => {\n      const X = g.value === \"rtl\" ? -1 : 1;\n      return (X > 0 ? J.value < 0 : J.value > p.value.size - 1) ? null : Array.from(p.value)[J.value - X];\n    }), L = nt();\n    function N(X) {\n      var se, fe;\n      st(X.key) && (X.key === L.ARROW_LEFT && ((se = K.value) == null || se.focus()), X.key === L.ARROW_RIGHT && ((fe = z.value) == null || fe.focus()));\n    }\n    function Z(X) {\n      G.value = X;\n    }\n    return ic({\n      isDateUnavailable: u.value,\n      locale: s,\n      startValue: H,\n      endValue: Q,\n      placeholder: C,\n      disabled: r,\n      formatter: c,\n      hourCycle: n.hourCycle,\n      readonly: i,\n      segmentValues: { start: I, end: M },\n      isInvalid: P,\n      segmentContents: j,\n      elements: p,\n      setFocusedElement: Z,\n      focusNext() {\n        var X;\n        (X = z.value) == null || X.focus();\n      }\n    }), t({\n      setFocusedElement: Z\n    }), (X, se) => {\n      var fe, xe;\n      return b(), ve(_e, null, [\n        q(o(O), k(X.$attrs, {\n          ref_key: \"primitiveElement\",\n          ref: f,\n          role: \"group\",\n          \"aria-disabled\": o(r) ? !0 : void 0,\n          \"data-disabled\": o(r) ? \"\" : void 0,\n          \"data-readonly\": o(i) ? \"\" : void 0,\n          \"data-invalid\": P.value ? \"\" : void 0,\n          dir: o(g),\n          onKeydown: ie(N, [\"left\", \"right\"])\n        }), {\n          default: y(() => [\n            w(X.$slots, \"default\", {\n              modelValue: o(m),\n              segments: F.value\n            })\n          ]),\n          _: 3\n        }, 16, [\"aria-disabled\", \"data-disabled\", \"data-readonly\", \"data-invalid\", \"dir\"]),\n        Ye(\"input\", {\n          id: X.id,\n          type: \"text\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"true\",\n          value: `${(fe = o(m).start) == null ? void 0 : fe.toString()} - ${(xe = o(m).end) == null ? void 0 : xe.toString()}`,\n          name: X.name,\n          disabled: o(r),\n          required: X.required,\n          style: {\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          },\n          onFocus: se[0] || (se[0] = (Ee) => {\n            var be, de;\n            return (de = (be = Array.from(p.value)) == null ? void 0 : be[0]) == null ? void 0 : de.focus();\n          })\n        }, null, 40, sc)\n      ], 64);\n    };\n  }\n}), dc = /* @__PURE__ */ x({\n  __name: \"DateRangeFieldInput\",\n  props: {\n    part: {},\n    type: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = rc(), n = T(!0), l = T(!1), {\n      handleSegmentClick: s,\n      handleSegmentKeydown: r,\n      attributes: i\n    } = cs({\n      hasLeftFocus: n,\n      lastKeyZero: l,\n      placeholder: e.placeholder,\n      hourCycle: e.hourCycle,\n      segmentValues: e.segmentValues[t.type],\n      formatter: e.formatter,\n      part: t.part,\n      disabled: e.disabled,\n      readonly: e.readonly,\n      focusNext: e.focusNext,\n      modelValue: t.type === \"start\" ? e.startValue : e.endValue\n    }), u = B(() => e.disabled.value), d = B(() => e.readonly.value), c = B(() => e.isInvalid.value);\n    return (f, v) => (b(), S(o(O), k({\n      as: f.as,\n      \"as-child\": f.asChild\n    }, o(i), {\n      contenteditable: u.value || d.value ? !1 : f.part !== \"literal\",\n      \"data-radix-vue-date-field-segment\": f.part,\n      \"aria-disabled\": u.value ? !0 : void 0,\n      \"aria-readonly\": d.value ? !0 : void 0,\n      \"data-disabled\": u.value ? \"\" : void 0,\n      \"data-radix-vue-date-range-field-segment-type\": f.type,\n      \"data-invalid\": c.value ? \"\" : void 0,\n      \"aria-invalid\": c.value ? !0 : void 0\n    }, Kn(f.part !== \"literal\" ? {\n      mousedown: o(s),\n      keydown: o(r),\n      focusout: () => {\n        n.value = !0;\n      },\n      focusin: (p) => {\n        o(e).setFocusedElement(p.target);\n      }\n    } : {})), {\n      default: y(() => [\n        w(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"contenteditable\", \"data-radix-vue-date-field-segment\", \"aria-disabled\", \"aria-readonly\", \"data-disabled\", \"data-radix-vue-date-range-field-segment-type\", \"data-invalid\", \"aria-invalid\"]));\n  }\n}), [fs, cc] = te(\"DropdownMenuRoot\"), uh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuRoot\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 },\n    dir: {},\n    modal: { type: Boolean, default: !0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), s = T(), { modal: r, dir: i } = ae(e), u = we(i);\n    return cc({\n      open: l,\n      onOpenChange: (d) => {\n        l.value = d;\n      },\n      onOpenToggle: () => {\n        l.value = !l.value;\n      },\n      triggerId: \"\",\n      triggerElement: s,\n      contentId: \"\",\n      modal: r,\n      dir: u\n    }), (d, c) => (b(), S(o(so), {\n      open: o(l),\n      \"onUpdate:open\": c[0] || (c[0] = (f) => et(l) ? l.value = f : null),\n      dir: o(u),\n      modal: o(r)\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\", \"modal\"]));\n  }\n}), dh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = fs(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.triggerElement = l;\n    }), e.triggerId || (e.triggerId = ge(void 0, \"radix-vue-dropdown-menu-trigger\")), (s, r) => (b(), S(o(Qa), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), {\n          id: o(e).triggerId,\n          ref: o(n),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          \"as-child\": t.asChild,\n          as: s.as,\n          \"aria-haspopup\": \"menu\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(e).open.value ? o(e).contentId : void 0,\n          \"data-disabled\": s.disabled ? \"\" : void 0,\n          disabled: s.disabled,\n          \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n          onClick: r[0] || (r[0] = async (i) => {\n            var u;\n            !s.disabled && i.button === 0 && i.ctrlKey === !1 && ((u = o(e)) == null || u.onOpenToggle(), await oe(), o(e).open.value && i.preventDefault());\n          }),\n          onKeydown: r[1] || (r[1] = ie(\n            (i) => {\n              s.disabled || ([\"Enter\", \" \"].includes(i.key) && o(e).onOpenToggle(), i.key === \"ArrowDown\" && o(e).onOpenChange(!0), [\"Enter\", \" \", \"ArrowDown\"].includes(i.key) && i.preventDefault());\n            },\n            [\"enter\", \"space\", \"arrow-down\"]\n          ))\n        }, {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as-child\", \"as\", \"aria-expanded\", \"aria-controls\", \"data-disabled\", \"disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), ch = /* @__PURE__ */ x({\n  __name: \"DropdownMenuPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(vo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    R();\n    const s = fs(), r = T(!1);\n    function i(u) {\n      u.defaultPrevented || (r.value || setTimeout(() => {\n        var d;\n        (d = s.triggerElement.value) == null || d.focus();\n      }, 0), r.value = !1, u.preventDefault());\n    }\n    return s.contentId || (s.contentId = ge(void 0, \"radix-vue-dropdown-menu-content\")), (u, d) => {\n      var c;\n      return b(), S(o(fo), k(o(l), {\n        id: o(s).contentId,\n        \"aria-labelledby\": (c = o(s)) == null ? void 0 : c.triggerId,\n        style: {\n          \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        },\n        onCloseAutoFocus: i,\n        onInteractOutside: d[0] || (d[0] = (f) => {\n          var m;\n          if (f.defaultPrevented) return;\n          const v = f.detail.originalEvent, p = v.button === 0 && v.ctrlKey === !0, g = v.button === 2 || p;\n          (!o(s).modal.value || g) && (r.value = !0), (m = o(s).triggerElement.value) != null && m.contains(f.target) && f.preventDefault();\n        })\n      }), {\n        default: y(() => [\n          w(u.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"aria-labelledby\"]);\n    };\n  }\n}), ph = /* @__PURE__ */ x({\n  __name: \"DropdownMenuArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(lo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), vh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(xa), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), mh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(tn), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(yo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), yh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(co), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), gh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(uo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(po), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ch = /* @__PURE__ */ x({\n  __name: \"DropdownMenuRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(mo), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), wh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    return R(), (s, r) => (b(), S(o(ho), W(U(o(l))), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), _h = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"open\", t, {\n      passive: e.open === void 0,\n      defaultValue: e.defaultOpen ?? !1\n    });\n    return R(), (s, r) => (b(), S(o(go), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => et(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), xh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    return R(), (s, r) => (b(), S(o(bo), k(o(l), { style: {\n      \"--radix-dropdown-menu-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-dropdown-menu-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-dropdown-menu-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-dropdown-menu-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-dropdown-menu-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sh = /* @__PURE__ */ x({\n  __name: \"DropdownMenuSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Co), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fc = [\"value\", \"name\", \"disabled\", \"required\"], [ta, pc] = te(\"EditableRoot\"), Eh = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"EditableRoot\",\n  props: {\n    defaultValue: {},\n    modelValue: {},\n    placeholder: { default: \"Enter text...\" },\n    dir: {},\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean },\n    activationMode: { default: \"focus\" },\n    selectOnFocus: { type: Boolean, default: !1 },\n    submitMode: { default: \"blur\" },\n    startWithEditMode: { type: Boolean },\n    maxLength: {},\n    autoResize: { type: Boolean, default: !1 },\n    id: {},\n    name: {},\n    required: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"submit\", \"update:state\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, {\n      id: s,\n      name: r,\n      defaultValue: i,\n      startWithEditMode: u,\n      placeholder: d,\n      maxLength: c,\n      disabled: f,\n      dir: v,\n      submitMode: p,\n      activationMode: g,\n      selectOnFocus: m,\n      readonly: _,\n      autoResize: C,\n      required: $\n    } = ae(n), h = T(), E = we(v), P = T(u.value ?? !1), D = ne(n, \"modelValue\", l, {\n      defaultValue: i.value ?? \"\",\n      passive: n.modelValue === void 0\n    }), { primitiveElement: I, currentElement: M } = Re(), V = at(M), A = B(() => typeof d.value == \"string\" ? { edit: d.value, preview: d.value } : d.value), F = T(D.value);\n    ee(() => D.value, () => {\n      F.value = D.value;\n    }, { immediate: !0, deep: !0 });\n    function j() {\n      P.value = !1, l(\"update:state\", \"cancel\");\n    }\n    function H() {\n      P.value = !0, F.value = D.value, l(\"update:state\", \"edit\");\n    }\n    function Q() {\n      D.value = F.value, P.value = !1, l(\"update:state\", \"submit\"), l(\"submit\", D.value);\n    }\n    function G() {\n      P.value && (p.value === \"blur\" || p.value === \"both\" ? Q() : j());\n    }\n    const J = Ul(() => G(), M), z = Gl(() => G(), M), K = B(() => D.value === \"\");\n    return t({\n      /** Function to submit the value of the editable */\n      submit: Q,\n      /** Function to cancel the value of the editable */\n      cancel: j,\n      /** Function to set the editable in edit mode */\n      edit: H\n    }), pc({\n      id: s,\n      name: r,\n      disabled: f,\n      isEditing: P,\n      maxLength: c,\n      modelValue: D,\n      inputValue: F,\n      placeholder: A,\n      edit: H,\n      cancel: j,\n      submit: Q,\n      activationMode: g,\n      submitMode: p,\n      selectOnFocus: m,\n      inputRef: h,\n      startWithEditMode: u,\n      isEmpty: K,\n      readonly: _,\n      autoResize: C\n    }), (L, N) => (b(), ve(_e, null, [\n      q(o(O), k(L.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: I,\n        as: L.as,\n        \"as-child\": L.asChild,\n        dir: o(E),\n        \"data-dismissable-layer\": \"\",\n        onFocusCapture: o(z).onFocusCapture,\n        onBlurCapture: o(z).onBlurCapture,\n        onPointerdownCapture: o(J).onPointerDownCapture\n      }), {\n        default: y(() => [\n          w(L.$slots, \"default\", {\n            modelValue: o(D),\n            isEditing: P.value,\n            isEmpty: K.value,\n            submit: Q,\n            cancel: j,\n            edit: H\n          })\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"dir\", \"onFocusCapture\", \"onBlurCapture\", \"onPointerdownCapture\"]),\n      o(V) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(D),\n        name: o(r),\n        disabled: o(f),\n        required: o($),\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, fc)) : ce(\"\", !0)\n    ], 64));\n  }\n}), Ph = /* @__PURE__ */ x({\n  __name: \"EditableArea\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = ta();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"data-placeholder-shown\": o(e).isEditing.value ? void 0 : \"\",\n      \"data-focus\": o(e).isEditing.value ? \"\" : void 0,\n      \"data-focused\": o(e).isEditing.value ? \"\" : void 0,\n      \"data-empty\": o(e).isEmpty.value ? \"\" : void 0,\n      \"data-readonly\": o(e).readonly.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      style: o(e).autoResize.value ? { display: \"inline-grid\" } : void 0\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-placeholder-shown\", \"data-focus\", \"data-focused\", \"data-empty\", \"data-readonly\", \"data-disabled\", \"style\"]));\n  }\n}), Dh = /* @__PURE__ */ x({\n  __name: \"EditableInput\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = nt(), n = ta(), l = B(() => n.disabled.value), s = B(() => {\n      var d;\n      return (d = n.placeholder.value) == null ? void 0 : d.edit;\n    }), { primitiveElement: r, currentElement: i } = Re();\n    le(() => {\n      var d, c;\n      n.inputRef.value = i.value, n.startWithEditMode.value && ((d = n.inputRef.value) == null || d.focus({ preventScroll: !0 }), n.selectOnFocus.value && ((c = n.inputRef.value) == null || c.select()));\n    }), ee(n.isEditing, (d) => {\n      d && oe(() => {\n        var c, f;\n        (c = n.inputRef.value) == null || c.focus({ preventScroll: !0 }), n.selectOnFocus.value && ((f = n.inputRef.value) == null || f.select());\n      });\n    });\n    function u(d) {\n      (n.submitMode.value === \"enter\" || n.submitMode.value === \"both\") && d.key === e.ENTER && !d.shiftKey && !d.metaKey && n.submit();\n    }\n    return (d, c) => (b(), S(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: r\n    }, t, {\n      value: o(n).inputValue.value,\n      placeholder: s.value,\n      disabled: l.value,\n      maxlength: o(n).maxLength.value,\n      \"data-disabled\": l.value ? \"\" : void 0,\n      \"data-readonly\": o(n).readonly.value ? \"\" : void 0,\n      readonly: o(n).readonly.value,\n      \"aria-label\": \"editable input\",\n      hidden: o(n).autoResize.value ? void 0 : !o(n).isEditing.value,\n      style: o(n).autoResize.value ? { all: \"unset\", gridArea: \"1 / 1 / auto / auto\", visibility: o(n).isEditing.value ? void 0 : \"hidden\" } : void 0,\n      onInput: c[0] || (c[0] = (f) => o(n).inputValue.value = f.target.value),\n      onKeydown: [\n        ie(u, [\"enter\", \"space\"]),\n        ie(o(n).cancel, [\"esc\"])\n      ]\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"value\", \"placeholder\", \"disabled\", \"maxlength\", \"data-disabled\", \"data-readonly\", \"readonly\", \"hidden\", \"style\", \"onKeydown\"]));\n  }\n}), $h = /* @__PURE__ */ x({\n  __name: \"EditablePreview\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = ta(), n = B(() => {\n      var r;\n      return (r = e.placeholder.value) == null ? void 0 : r.preview;\n    });\n    function l() {\n      e.activationMode.value === \"focus\" && e.edit();\n    }\n    function s() {\n      e.activationMode.value === \"dblclick\" && e.edit();\n    }\n    return (r, i) => (b(), S(o(O), k(t, {\n      tabindex: \"0\",\n      \"data-placeholder-shown\": o(e).isEditing.value ? void 0 : \"\",\n      hidden: o(e).autoResize.value ? void 0 : o(e).isEditing.value,\n      style: o(e).autoResize.value ? {\n        whiteSpace: \"pre\",\n        userSelect: \"none\",\n        gridArea: \"1 / 1 / auto / auto\",\n        visibility: o(e).isEditing.value ? \"hidden\" : void 0,\n        overflow: \"hidden\",\n        textOverflow: \"ellipsis\"\n      } : void 0,\n      onFocusin: l,\n      onDblclick: s\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\", {}, () => [\n          ye(De(o(e).modelValue.value || n.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-placeholder-shown\", \"hidden\", \"style\"]));\n  }\n}), Bh = /* @__PURE__ */ x({\n  __name: \"EditableSubmitTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ta();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"submit\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? void 0 : \"\",\n      onClick: o(e).submit\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          ye(\"Submit\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), Ih = /* @__PURE__ */ x({\n  __name: \"EditableCancelTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ta();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"cancel\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? void 0 : \"\",\n      onClick: o(e).cancel\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          ye(\"Cancel\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), Th = /* @__PURE__ */ x({\n  __name: \"EditableEditTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = ta();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"edit\",\n      \"aria-disabled\": o(e).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      disabled: o(e).disabled.value,\n      type: n.as === \"button\" ? \"button\" : void 0,\n      hidden: o(e).isEditing.value ? \"\" : void 0,\n      onClick: o(e).edit\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          ye(\"Edit\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-disabled\", \"data-disabled\", \"disabled\", \"type\", \"hidden\", \"onClick\"]));\n  }\n}), [xo, vc] = te(\"HoverCardRoot\"), Rh = /* @__PURE__ */ x({\n  __name: \"HoverCardRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    openDelay: { default: 700 },\n    closeDelay: { default: 300 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { openDelay: l, closeDelay: s } = ae(e);\n    R();\n    const r = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), i = T(0), u = T(0), d = T(!1), c = T(!1), f = T(!1), v = T();\n    function p() {\n      clearTimeout(u.value), i.value = window.setTimeout(() => r.value = !0, l.value);\n    }\n    function g() {\n      clearTimeout(i.value), !d.value && !c.value && (u.value = window.setTimeout(() => r.value = !1, s.value));\n    }\n    function m() {\n      r.value = !1;\n    }\n    return vc({\n      open: r,\n      onOpenChange(_) {\n        r.value = _;\n      },\n      onOpen: p,\n      onClose: g,\n      onDismiss: m,\n      hasSelectionRef: d,\n      isPointerDownOnContentRef: c,\n      isPointerInTransitRef: f,\n      triggerElement: v\n    }), (_, C) => (b(), S(o(kt), null, {\n      default: y(() => [\n        w(_.$slots, \"default\", { open: o(r) })\n      ]),\n      _: 3\n    }));\n  }\n});\nfunction An(a) {\n  return (t) => t.pointerType === \"touch\" ? void 0 : a();\n}\nfunction mc(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nconst Ah = /* @__PURE__ */ x({\n  __name: \"HoverCardTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = R(), n = xo();\n    n.triggerElement = e;\n    function l() {\n      setTimeout(() => {\n        !n.isPointerInTransitRef.value && !n.open.value && n.onClose();\n      }, 0);\n    }\n    return (s, r) => (b(), S(o(Mt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(t),\n          \"as-child\": s.asChild,\n          as: s.as,\n          \"data-state\": o(n).open.value ? \"open\" : \"closed\",\n          \"data-grace-area-trigger\": \"\",\n          onPointerenter: r[0] || (r[0] = (i) => o(An)(o(n).onOpen)(i)),\n          onPointerleave: r[1] || (r[1] = (i) => o(An)(l)(i)),\n          onFocus: r[2] || (r[2] = (i) => o(n).onOpen()),\n          onBlur: r[3] || (r[3] = (i) => o(n).onClose())\n        }, {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Oh = /* @__PURE__ */ x({\n  __name: \"HoverCardPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), hc = /* @__PURE__ */ x({\n  __name: \"HoverCardContentImpl\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Ot(e), { forwardRef: s, currentElement: r } = R(), i = xo(), { isPointerInTransit: u, onPointerExit: d } = Fl(i.triggerElement, r);\n    mi(i.isPointerInTransitRef, u, { direction: \"rtl\" }), d(() => {\n      i.onClose();\n    });\n    const c = T(!1);\n    let f;\n    Ce((p) => {\n      if (c.value) {\n        const g = document.body;\n        f = g.style.userSelect || g.style.webkitUserSelect, g.style.userSelect = \"none\", g.style.webkitUserSelect = \"none\", p(() => {\n          g.style.userSelect = f, g.style.webkitUserSelect = f;\n        });\n      }\n    });\n    function v() {\n      c.value = !1, i.isPointerDownOnContentRef.value = !1, oe(() => {\n        var g;\n        ((g = document.getSelection()) == null ? void 0 : g.toString()) !== \"\" && (i.hasSelectionRef.value = !0);\n      });\n    }\n    return le(() => {\n      r.value && (document.addEventListener(\"pointerup\", v), mc(r.value).forEach((g) => g.setAttribute(\"tabindex\", \"-1\")));\n    }), Be(() => {\n      document.removeEventListener(\"pointerup\", v), i.hasSelectionRef.value = !1, i.isPointerDownOnContentRef.value = !1;\n    }), (p, g) => (b(), S(o(Ct), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: g[1] || (g[1] = (m) => n(\"escapeKeyDown\", m)),\n      onPointerDownOutside: g[2] || (g[2] = (m) => n(\"pointerDownOutside\", m)),\n      onFocusOutside: g[3] || (g[3] = ue((m) => n(\"focusOutside\", m), [\"prevent\"])),\n      onDismiss: o(i).onDismiss\n    }, {\n      default: y(() => [\n        q(o(It), k({ ...o(l), ...p.$attrs }, {\n          ref: o(s),\n          \"data-state\": o(i).open.value ? \"open\" : \"closed\",\n          style: {\n            userSelect: c.value ? \"text\" : void 0,\n            // Safari requires prefix\n            WebkitUserSelect: c.value ? \"text\" : void 0,\n            // re-namespace exposed content custom properties\n            \"--radix-hover-card-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n            \"--radix-hover-card-content-available-width\": \"var(--radix-popper-available-width)\",\n            \"--radix-hover-card-content-available-height\": \"var(--radix-popper-available-height)\",\n            \"--radix-hover-card-trigger-width\": \"var(--radix-popper-anchor-width)\",\n            \"--radix-hover-card-trigger-height\": \"var(--radix-popper-anchor-height)\"\n          },\n          onPointerdown: g[0] || (g[0] = (m) => {\n            m.currentTarget.contains(m.target) && (c.value = !0), o(i).hasSelectionRef.value = !1, o(i).isPointerDownOnContentRef.value = !0;\n          })\n        }), {\n          default: y(() => [\n            w(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"onDismiss\"]));\n  }\n}), kh = /* @__PURE__ */ x({\n  __name: \"HoverCardContent\",\n  props: {\n    forceMount: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t), { forwardRef: s } = R(), r = xo();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(r).open.value\n    }, {\n      default: y(() => [\n        q(hc, k(o(l), {\n          ref: o(s),\n          onPointerenter: u[0] || (u[0] = (d) => o(An)(o(r).onOpen)(d))\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Mh = /* @__PURE__ */ x({\n  __name: \"HoverCardArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Zt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vh = /* @__PURE__ */ x({\n  __name: \"Label\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"label\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, {\n      onMousedown: n[0] || (n[0] = (l) => {\n        !l.defaultPrevented && l.detail > 1 && l.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction yc(a) {\n  return a == null ? void 0 : a.querySelector(\"[data-state=checked]\");\n}\nfunction gc(a, t, e) {\n  return a === void 0 ? !1 : Array.isArray(a) ? a.some((n) => Gt(n, t, e)) : Gt(a, t, e);\n}\nfunction Gt(a, t, e) {\n  return a === void 0 || t === void 0 ? !1 : typeof a == \"string\" ? a === t : typeof e == \"function\" ? e(a, t) : typeof e == \"string\" ? (a == null ? void 0 : a[e]) === (t == null ? void 0 : t[e]) : Qe(a, t);\n}\nconst [an, bc] = te(\"ListboxRoot\"), Fh = /* @__PURE__ */ x({\n  __name: \"ListboxRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    multiple: { type: Boolean },\n    orientation: { default: \"vertical\" },\n    dir: {},\n    disabled: { type: Boolean },\n    selectionBehavior: { default: \"toggle\" },\n    highlightOnHover: { type: Boolean },\n    by: {},\n    name: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"highlight\", \"entryFocus\", \"leave\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { multiple: l, highlightOnHover: s, orientation: r, disabled: i, selectionBehavior: u, dir: d } = ae(e), { getItems: c } = Ca(), { handleTypeaheadSearch: f } = ba(), { primitiveElement: v, currentElement: p } = Re(), g = nt(), m = we(d), _ = at(p), C = T(), $ = T(!1), h = T(!0), E = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? (l.value ? [] : void 0),\n      passive: e.modelValue === void 0,\n      deep: !0\n    });\n    function P(N) {\n      if ($.value = !0, Array.isArray(E.value)) {\n        const Z = E.value.findIndex((Y) => Gt(Y, N, e.by));\n        if (e.selectionBehavior === \"toggle\") {\n          const Y = [...E.value];\n          Z === -1 ? Y.push(N) : Y.splice(Z, 1), E.value = Y;\n        } else\n          E.value = [N], C.value = N;\n      } else\n        e.selectionBehavior === \"toggle\" && Gt(E.value, N, e.by) ? E.value = void 0 : E.value = N;\n      setTimeout(() => {\n        $.value = !1;\n      }, 1);\n    }\n    const D = T(null), I = T(null), M = T(!1), V = ua(), A = ua();\n    function F() {\n      return c().map((N) => N.ref).filter((N) => N.dataset.disabled !== \"\");\n    }\n    function j(N) {\n      if (!N)\n        return;\n      D.value = N, D.value.focus(), D.value.scrollIntoView({ block: \"nearest\" });\n      const Z = c().find((Y) => Y.ref === N);\n      n(\"highlight\", Z);\n    }\n    function H(N) {\n      D.value && D.value.click();\n    }\n    function Q(N) {\n      if ($.value = !0, M.value)\n        A.trigger(N);\n      else {\n        const Z = N.altKey || N.ctrlKey || N.metaKey;\n        if (Z && N.key === \"a\" && l.value) {\n          const Y = c(), re = Y.map((X) => X.value);\n          E.value = [...re], N.preventDefault(), j(Y[Y.length - 1].ref);\n        } else if (!Z) {\n          const Y = f(N.key, F());\n          Y && j(Y);\n        }\n      }\n      setTimeout(() => {\n        $.value = !1;\n      }, 1);\n    }\n    function G(N) {\n      const Z = D.value;\n      Z != null && Z.isConnected && (I.value = Z), D.value = null, n(\"leave\", N);\n    }\n    function J(N) {\n      var Y, re;\n      const Z = new CustomEvent(\"listbox.entryFocus\", { bubbles: !1, cancelable: !0 });\n      if ((Y = N.currentTarget) == null || Y.dispatchEvent(Z), n(\"entryFocus\", Z), !Z.defaultPrevented)\n        if (I.value)\n          j(I.value);\n        else {\n          const X = (re = F()) == null ? void 0 : re[0];\n          j(X);\n        }\n    }\n    function z(N) {\n      const Z = os(N, r.value, m.value);\n      if (!Z)\n        return;\n      let Y = F();\n      if (D.value) {\n        if (Z === \"last\")\n          Y.reverse();\n        else if (Z === \"prev\" || Z === \"next\") {\n          Z === \"prev\" && Y.reverse();\n          const re = Y.indexOf(D.value);\n          Y = Y.slice(re + 1);\n        }\n        K(N, Y[0]);\n      }\n      if (Y.length) {\n        const re = !D.value && Z === \"prev\" ? Y.length - 1 : 0;\n        j(Y[re]);\n      }\n      if (M.value)\n        return A.trigger(N);\n    }\n    function K(N, Z) {\n      var re;\n      if (!(M.value || e.selectionBehavior !== \"replace\" || !l.value || !Array.isArray(E.value) || (N.altKey || N.ctrlKey || N.metaKey) && !N.shiftKey) && N.shiftKey) {\n        const X = c().filter((xe) => xe.ref.dataset.disabled !== \"\");\n        let se = (re = X.find((xe) => xe.ref === Z)) == null ? void 0 : re.value;\n        if (N.key === g.END ? se = X[X.length - 1].value : N.key === g.HOME && (se = X[0].value), !se || !C.value)\n          return;\n        const fe = Bt(X.map((xe) => xe.value), C.value, se);\n        E.value = fe;\n      }\n    }\n    async function L(N) {\n      if (M.value)\n        V.trigger(N);\n      else {\n        await oe();\n        const Y = F().find((re) => re.dataset.state === \"checked\");\n        Y && j(Y);\n      }\n    }\n    return ee(E, () => {\n      $.value || oe(() => {\n        L();\n      });\n    }, { immediate: !0, deep: !0 }), bc({\n      modelValue: E,\n      // @ts-expect-error ignoring\n      onValueChange: P,\n      multiple: l,\n      orientation: r,\n      dir: m,\n      disabled: i,\n      highlightOnHover: s,\n      highlightedElement: D,\n      isVirtual: M,\n      virtualFocusHook: V,\n      virtualKeydownHook: A,\n      by: e.by,\n      firstValue: C,\n      selectionBehavior: u,\n      focusable: h,\n      onLeave: G,\n      onEnter: J,\n      onChangeHighlight: j,\n      onKeydownEnter: H,\n      onKeydownNavigation: z,\n      onKeydownTypeAhead: Q\n    }), (N, Z) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: v,\n      as: N.as,\n      \"as-child\": N.asChild,\n      dir: o(m),\n      \"data-disabled\": o(i) ? \"\" : void 0,\n      onPointerleave: G,\n      onFocusout: Z[0] || (Z[0] = async (Y) => {\n        const re = Y.relatedTarget || Y.target;\n        await oe(), D.value && o(p) && !o(p).contains(re) && G(Y);\n      })\n    }, {\n      default: y(() => [\n        w(N.$slots, \"default\", { modelValue: o(E) }),\n        o(_) && e.name ? (b(), S(o(no), {\n          key: 0,\n          name: e.name,\n          value: o(E)\n        }, null, 8, [\"name\", \"value\"])) : ce(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"dir\", \"data-disabled\"]));\n  }\n}), Nh = /* @__PURE__ */ x({\n  __name: \"ListboxContent\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = an(), e = Tt(!1, 10);\n    return (n, l) => (b(), S(o(wa), null, {\n      default: y(() => [\n        q(o(O), {\n          role: \"listbox\",\n          as: n.as,\n          \"as-child\": n.asChild,\n          tabindex: o(t).focusable.value ? o(t).highlightedElement.value ? \"-1\" : \"0\" : void 0,\n          \"aria-orientation\": o(t).orientation.value,\n          \"aria-multiselectable\": !!o(t).multiple.value,\n          \"data-orientation\": o(t).orientation.value,\n          onMousedown: l[0] || (l[0] = ue((s) => e.value = !0, [\"left\"])),\n          onFocus: l[1] || (l[1] = (s) => {\n            o(e) || o(t).onEnter(s);\n          }),\n          onKeydown: [\n            l[2] || (l[2] = ie(ue((s) => {\n              o(t).focusable.value && o(t).onKeydownNavigation(s);\n            }, [\"prevent\"]), [\"down\", \"up\", \"left\", \"right\", \"home\", \"end\"])),\n            ie(o(t).onKeydownEnter, [\"enter\"]),\n            o(t).onKeydownTypeAhead\n          ]\n        }, {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"tabindex\", \"aria-orientation\", \"aria-multiselectable\", \"data-orientation\", \"onKeydown\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Lh = /* @__PURE__ */ x({\n  __name: \"ListboxFilter\",\n  props: {\n    modelValue: {},\n    autoFocus: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t, {\n      defaultValue: \"\",\n      passive: e.modelValue === void 0\n    }), s = an();\n    s.focusable.value = !1;\n    const { primitiveElement: r, currentElement: i } = Re();\n    return le(() => {\n      setTimeout(() => {\n        var u;\n        e.autoFocus && ((u = i.value) == null || u.focus());\n      }, 1);\n    }), (u, d) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: r,\n      as: u.as,\n      \"as-child\": u.asChild,\n      value: o(l),\n      disabled: o(s).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(s).disabled.value ? \"\" : void 0,\n      type: \"text\",\n      onKeydown: [\n        ie(ue(o(s).onKeydownNavigation, [\"prevent\"]), [\"down\", \"up\", \"home\", \"end\"]),\n        ie(o(s).onKeydownEnter, [\"enter\"])\n      ],\n      onInput: d[0] || (d[0] = (c) => {\n        l.value = c.target.value;\n      })\n    }, {\n      default: y(() => [\n        w(u.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"value\", \"disabled\", \"data-disabled\", \"onKeydown\"]));\n  }\n}), Cc = \"listbox.select\", [wc, _c] = te(\"ListboxItem\"), zh = /* @__PURE__ */ x({\n  __name: \"ListboxItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = ge(void 0, \"radix-vue-listbox-item\"), i = an(), u = B(() => s.value === i.highlightedElement.value), d = B(() => gc(i.modelValue.value, e.value, i.by)), c = B(() => i.disabled.value || e.disabled);\n    async function f(p) {\n      n(\"select\", p), !(p != null && p.defaultPrevented) && !c.value && p && (i.onValueChange(e.value), i.onChangeHighlight(p.target));\n    }\n    function v(p) {\n      const g = { originalEvent: p, value: e.value };\n      jt(Cc, f, g);\n    }\n    return _c({\n      isSelected: d\n    }), (p, g) => (b(), S(o(Qt), { value: p.value }, {\n      default: y(() => [\n        q(o(O), {\n          id: o(r),\n          ref: o(l),\n          role: \"option\",\n          tabindex: o(i).focusable.value ? u.value ? \"0\" : \"-1\" : void 0,\n          \"aria-selected\": d.value,\n          as: p.as,\n          \"as-child\": p.asChild,\n          disabled: c.value ? \"\" : void 0,\n          \"data-disabled\": c.value ? \"\" : void 0,\n          \"data-highlighted\": u.value ? \"\" : void 0,\n          \"data-state\": d.value ? \"checked\" : \"unchecked\",\n          onClick: v,\n          onKeydown: ie(ue(v, [\"prevent\"]), [\"space\"]),\n          onPointermove: g[0] || (g[0] = (m) => {\n            o(i).highlightOnHover.value ? o(i).onChangeHighlight(o(s)) : o(i).focusable.value || o(i).onChangeHighlight(o(s));\n          })\n        }, {\n          default: y(() => [\n            w(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"tabindex\", \"aria-selected\", \"as\", \"as-child\", \"disabled\", \"data-disabled\", \"data-highlighted\", \"data-state\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), Kh = /* @__PURE__ */ x({\n  __name: \"ListboxItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = wc();\n    return (n, l) => o(e).isSelected.value ? (b(), S(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"true\"\n    }, t), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n});\nfunction oa(a, t, e) {\n  let n = e.initialDeps ?? [], l;\n  return () => {\n    var s, r, i, u;\n    let d;\n    e.key && ((s = e.debug) != null && s.call(e)) && (d = Date.now());\n    const c = a();\n    if (!(c.length !== n.length || c.some((p, g) => n[g] !== p)))\n      return l;\n    n = c;\n    let v;\n    if (e.key && ((r = e.debug) != null && r.call(e)) && (v = Date.now()), l = t(...c), e.key && ((i = e.debug) != null && i.call(e))) {\n      const p = Math.round((Date.now() - d) * 100) / 100, g = Math.round((Date.now() - v) * 100) / 100, m = g / 16, _ = (C, $) => {\n        for (C = String(C); C.length < $; )\n          C = \" \" + C;\n        return C;\n      };\n      console.info(\n        `%câ± ${_(g, 5)} /${_(p, 5)} ms`,\n        `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(\n          0,\n          Math.min(120 - 120 * m, 120)\n        )}deg 100% 31%);`,\n        e == null ? void 0 : e.key\n      );\n    }\n    return (u = e == null ? void 0 : e.onChange) == null || u.call(e, l), l;\n  };\n}\nfunction En(a, t) {\n  if (a === void 0)\n    throw new Error(\"Unexpected undefined\");\n  return a;\n}\nconst xc = (a, t) => Math.abs(a - t) < 1, Sc = (a, t, e) => {\n  let n;\n  return function(...l) {\n    a.clearTimeout(n), n = a.setTimeout(() => t.apply(this, l), e);\n  };\n}, Ec = (a) => a, Pc = (a) => {\n  const t = Math.max(a.startIndex - a.overscan, 0), e = Math.min(a.endIndex + a.overscan, a.count - 1), n = [];\n  for (let l = t; l <= e; l++)\n    n.push(l);\n  return n;\n}, Dc = (a, t) => {\n  const e = a.scrollElement;\n  if (!e)\n    return;\n  const n = a.targetWindow;\n  if (!n)\n    return;\n  const l = (r) => {\n    const { width: i, height: u } = r;\n    t({ width: Math.round(i), height: Math.round(u) });\n  };\n  if (l(e.getBoundingClientRect()), !n.ResizeObserver)\n    return () => {\n    };\n  const s = new n.ResizeObserver((r) => {\n    const i = r[0];\n    if (i != null && i.borderBoxSize) {\n      const u = i.borderBoxSize[0];\n      if (u) {\n        l({ width: u.inlineSize, height: u.blockSize });\n        return;\n      }\n    }\n    l(e.getBoundingClientRect());\n  });\n  return s.observe(e, { box: \"border-box\" }), () => {\n    s.unobserve(e);\n  };\n}, Jo = {\n  passive: !0\n}, $c = typeof window > \"u\" ? !0 : \"onscrollend\" in window, Bc = (a, t) => {\n  const e = a.scrollElement;\n  if (!e)\n    return;\n  const n = a.targetWindow;\n  if (!n)\n    return;\n  let l = 0;\n  const s = $c ? () => {\n  } : Sc(\n    n,\n    () => {\n      t(l, !1);\n    },\n    a.options.isScrollingResetDelay\n  ), r = (d) => () => {\n    l = e[a.options.horizontal ? \"scrollLeft\" : \"scrollTop\"], s(), t(l, d);\n  }, i = r(!0), u = r(!1);\n  return u(), e.addEventListener(\"scroll\", i, Jo), e.addEventListener(\"scrollend\", u, Jo), () => {\n    e.removeEventListener(\"scroll\", i), e.removeEventListener(\"scrollend\", u);\n  };\n}, Ic = (a, t, e) => {\n  if (t != null && t.borderBoxSize) {\n    const n = t.borderBoxSize[0];\n    if (n)\n      return Math.round(\n        n[e.options.horizontal ? \"inlineSize\" : \"blockSize\"]\n      );\n  }\n  return Math.round(\n    a.getBoundingClientRect()[e.options.horizontal ? \"width\" : \"height\"]\n  );\n}, Tc = (a, {\n  adjustments: t = 0,\n  behavior: e\n}, n) => {\n  var l, s;\n  const r = a + t;\n  (s = (l = n.scrollElement) == null ? void 0 : l.scrollTo) == null || s.call(l, {\n    [n.options.horizontal ? \"left\" : \"top\"]: r,\n    behavior: e\n  });\n};\nclass Rc {\n  constructor(t) {\n    this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = /* @__PURE__ */ new Map(), this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = /* @__PURE__ */ new Map(), this.observer = /* @__PURE__ */ (() => {\n      let e = null;\n      const n = () => e || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : e = new this.targetWindow.ResizeObserver((l) => {\n        l.forEach((s) => {\n          this._measureElement(s.target, s);\n        });\n      }));\n      return {\n        disconnect: () => {\n          var l;\n          return (l = n()) == null ? void 0 : l.disconnect();\n        },\n        observe: (l) => {\n          var s;\n          return (s = n()) == null ? void 0 : s.observe(l, { box: \"border-box\" });\n        },\n        unobserve: (l) => {\n          var s;\n          return (s = n()) == null ? void 0 : s.unobserve(l);\n        }\n      };\n    })(), this.range = null, this.setOptions = (e) => {\n      Object.entries(e).forEach(([n, l]) => {\n        typeof l > \"u\" && delete e[n];\n      }), this.options = {\n        debug: !1,\n        initialOffset: 0,\n        overscan: 1,\n        paddingStart: 0,\n        paddingEnd: 0,\n        scrollPaddingStart: 0,\n        scrollPaddingEnd: 0,\n        horizontal: !1,\n        getItemKey: Ec,\n        rangeExtractor: Pc,\n        onChange: () => {\n        },\n        measureElement: Ic,\n        initialRect: { width: 0, height: 0 },\n        scrollMargin: 0,\n        gap: 0,\n        indexAttribute: \"data-index\",\n        initialMeasurementsCache: [],\n        lanes: 1,\n        isScrollingResetDelay: 150,\n        enabled: !0,\n        ...e\n      };\n    }, this.notify = (e, n) => {\n      var l, s;\n      const { startIndex: r, endIndex: i } = this.range ?? {\n        startIndex: void 0,\n        endIndex: void 0\n      }, u = this.calculateRange();\n      (e || r !== (u == null ? void 0 : u.startIndex) || i !== (u == null ? void 0 : u.endIndex)) && ((s = (l = this.options).onChange) == null || s.call(l, this, n));\n    }, this.cleanup = () => {\n      this.unsubs.filter(Boolean).forEach((e) => e()), this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.observer.disconnect(), this.elementsCache.clear();\n    }, this._didMount = () => () => {\n      this.cleanup();\n    }, this._willUpdate = () => {\n      var e;\n      const n = this.options.enabled ? this.options.getScrollElement() : null;\n      if (this.scrollElement !== n) {\n        if (this.cleanup(), !n) {\n          this.notify(!1, !1);\n          return;\n        }\n        this.scrollElement = n, this.scrollElement && \"ownerDocument\" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((e = this.scrollElement) == null ? void 0 : e.window) ?? null, this._scrollToOffset(this.getScrollOffset(), {\n          adjustments: void 0,\n          behavior: void 0\n        }), this.unsubs.push(\n          this.options.observeElementRect(this, (l) => {\n            this.scrollRect = l, this.notify(!1, !1);\n          })\n        ), this.unsubs.push(\n          this.options.observeElementOffset(this, (l, s) => {\n            this.scrollAdjustments = 0, this.scrollDirection = s ? this.getScrollOffset() < l ? \"forward\" : \"backward\" : null, this.scrollOffset = l;\n            const r = this.isScrolling;\n            this.isScrolling = s, this.notify(r !== s, s);\n          })\n        );\n      }\n    }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? \"width\" : \"height\"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == \"function\" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (e, n) => {\n      const l = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();\n      for (let r = n - 1; r >= 0; r--) {\n        const i = e[r];\n        if (l.has(i.lane))\n          continue;\n        const u = s.get(\n          i.lane\n        );\n        if (u == null || i.end > u.end ? s.set(i.lane, i) : i.end < u.end && l.set(i.lane, !0), l.size === this.options.lanes)\n          break;\n      }\n      return s.size === this.options.lanes ? Array.from(s.values()).sort((r, i) => r.end === i.end ? r.index - i.index : r.end - i.end)[0] : void 0;\n    }, this.getMeasurementOptions = oa(\n      () => [\n        this.options.count,\n        this.options.paddingStart,\n        this.options.scrollMargin,\n        this.options.getItemKey,\n        this.options.enabled\n      ],\n      (e, n, l, s, r) => (this.pendingMeasuredCacheIndexes = [], {\n        count: e,\n        paddingStart: n,\n        scrollMargin: l,\n        getItemKey: s,\n        enabled: r\n      }),\n      {\n        key: !1\n      }\n    ), this.getMeasurements = oa(\n      () => [this.getMeasurementOptions(), this.itemSizeCache],\n      ({ count: e, paddingStart: n, scrollMargin: l, getItemKey: s, enabled: r }, i) => {\n        var u;\n        if (!r)\n          return this.measurementsCache = [], this.itemSizeCache.clear(), [];\n        this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach((f) => {\n          this.itemSizeCache.set(f.key, f.size);\n        }));\n        const d = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n        this.pendingMeasuredCacheIndexes = [];\n        const c = this.measurementsCache.slice(0, d);\n        for (let f = d; f < e; f++) {\n          let v = (u = this.measurementsCache[f]) == null ? void 0 : u.measureElement;\n          v || (v = (E) => {\n            const P = s(f), D = this.elementsCache.get(P);\n            if (!E) {\n              D && (this.observer.unobserve(D), this.elementsCache.delete(P));\n              return;\n            }\n            D !== E && (D && this.observer.unobserve(D), this.observer.observe(E), this.elementsCache.set(P, E)), E.isConnected && this.resizeItem(\n              f,\n              this.options.measureElement(E, void 0, this)\n            );\n          });\n          const p = s(f), g = this.options.lanes === 1 ? c[f - 1] : this.getFurthestMeasurement(c, f), m = g ? g.end + this.options.gap : n + l, _ = i.get(p), C = typeof _ == \"number\" ? _ : this.options.estimateSize(f), $ = m + C, h = g ? g.lane : f % this.options.lanes;\n          c[f] = {\n            index: f,\n            start: m,\n            size: C,\n            end: $,\n            key: p,\n            lane: h,\n            measureElement: v\n          };\n        }\n        return this.measurementsCache = c, c;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getMeasurements\",\n        debug: () => this.options.debug\n      }\n    ), this.calculateRange = oa(\n      () => [this.getMeasurements(), this.getSize(), this.getScrollOffset()],\n      (e, n, l) => this.range = e.length > 0 && n > 0 ? Ac({\n        measurements: e,\n        outerSize: n,\n        scrollOffset: l\n      }) : null,\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"calculateRange\",\n        debug: () => this.options.debug\n      }\n    ), this.getIndexes = oa(\n      () => [\n        this.options.rangeExtractor,\n        this.calculateRange(),\n        this.options.overscan,\n        this.options.count\n      ],\n      (e, n, l, s) => n === null ? [] : e({\n        startIndex: n.startIndex,\n        endIndex: n.endIndex,\n        overscan: l,\n        count: s\n      }),\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    ), this.indexFromElement = (e) => {\n      const n = this.options.indexAttribute, l = e.getAttribute(n);\n      return l ? parseInt(l, 10) : (console.warn(\n        `Missing attribute name '${n}={index}' on measured element.`\n      ), -1);\n    }, this._measureElement = (e, n) => {\n      const l = this.indexFromElement(e), s = this.getMeasurements()[l];\n      if (!s || !e.isConnected) {\n        this.elementsCache.forEach((i, u) => {\n          i === e && (this.observer.unobserve(e), this.elementsCache.delete(u));\n        });\n        return;\n      }\n      const r = this.elementsCache.get(s.key);\n      r !== e && (r && this.observer.unobserve(r), this.observer.observe(e), this.elementsCache.set(s.key, e)), this.resizeItem(l, this.options.measureElement(e, n, this));\n    }, this.resizeItem = (e, n) => {\n      const l = this.getMeasurements()[e];\n      if (!l)\n        return;\n      const s = this.itemSizeCache.get(l.key) ?? l.size, r = n - s;\n      r !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(l, r, this) : l.start < this.getScrollOffset() + this.scrollAdjustments) && (process.env.NODE_ENV !== \"production\" && this.options.debug && console.info(\"correction\", r), this._scrollToOffset(this.getScrollOffset(), {\n        adjustments: this.scrollAdjustments += r,\n        behavior: void 0\n      })), this.pendingMeasuredCacheIndexes.push(l.index), this.itemSizeCache = new Map(this.itemSizeCache.set(l.key, n)), this.notify(!0, !1));\n    }, this.measureElement = (e) => {\n      e && this._measureElement(e, void 0);\n    }, this.getVirtualItems = oa(\n      () => [this.getIndexes(), this.getMeasurements()],\n      (e, n) => {\n        const l = [];\n        for (let s = 0, r = e.length; s < r; s++) {\n          const i = e[s], u = n[i];\n          l.push(u);\n        }\n        return l;\n      },\n      {\n        key: process.env.NODE_ENV !== \"production\" && \"getIndexes\",\n        debug: () => this.options.debug\n      }\n    ), this.getVirtualItemForOffset = (e) => {\n      const n = this.getMeasurements();\n      if (n.length !== 0)\n        return En(\n          n[ps(\n            0,\n            n.length - 1,\n            (l) => En(n[l]).start,\n            e\n          )]\n        );\n    }, this.getOffsetForAlignment = (e, n) => {\n      const l = this.getSize(), s = this.getScrollOffset();\n      n === \"auto\" && (e <= s ? n = \"start\" : e >= s + l ? n = \"end\" : n = \"start\"), n === \"start\" ? e = e : n === \"end\" ? e = e - l : n === \"center\" && (e = e - l / 2);\n      const r = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\", u = (this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[r] : this.scrollElement[r] : 0) - l;\n      return Math.max(Math.min(u, e), 0);\n    }, this.getOffsetForIndex = (e, n = \"auto\") => {\n      e = Math.max(0, Math.min(e, this.options.count - 1));\n      const l = this.getMeasurements()[e];\n      if (!l)\n        return;\n      const s = this.getSize(), r = this.getScrollOffset();\n      if (n === \"auto\")\n        if (l.end >= r + s - this.options.scrollPaddingEnd)\n          n = \"end\";\n        else if (l.start <= r + this.options.scrollPaddingStart)\n          n = \"start\";\n        else\n          return [r, n];\n      const i = n === \"end\" ? l.end + this.options.scrollPaddingEnd : l.start - this.options.scrollPaddingStart;\n      return [this.getOffsetForAlignment(i, n), n];\n    }, this.isDynamicMode = () => this.elementsCache.size > 0, this.cancelScrollToIndex = () => {\n      this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null);\n    }, this.scrollToOffset = (e, { align: n = \"start\", behavior: l } = {}) => {\n      this.cancelScrollToIndex(), l === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      ), this._scrollToOffset(this.getOffsetForAlignment(e, n), {\n        adjustments: void 0,\n        behavior: l\n      });\n    }, this.scrollToIndex = (e, { align: n = \"auto\", behavior: l } = {}) => {\n      e = Math.max(0, Math.min(e, this.options.count - 1)), this.cancelScrollToIndex(), l === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      );\n      const s = this.getOffsetForIndex(e, n);\n      if (!s) return;\n      const [r, i] = s;\n      this._scrollToOffset(r, { adjustments: void 0, behavior: l }), l !== \"smooth\" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => {\n        if (this.scrollToIndexTimeoutId = null, this.elementsCache.has(\n          this.options.getItemKey(e)\n        )) {\n          const [d] = En(\n            this.getOffsetForIndex(e, i)\n          );\n          xc(d, this.getScrollOffset()) || this.scrollToIndex(e, { align: i, behavior: l });\n        } else\n          this.scrollToIndex(e, { align: i, behavior: l });\n      }));\n    }, this.scrollBy = (e, { behavior: n } = {}) => {\n      this.cancelScrollToIndex(), n === \"smooth\" && this.isDynamicMode() && console.warn(\n        \"The `smooth` scroll behavior is not fully supported with dynamic size.\"\n      ), this._scrollToOffset(this.getScrollOffset() + e, {\n        adjustments: void 0,\n        behavior: n\n      });\n    }, this.getTotalSize = () => {\n      var e;\n      const n = this.getMeasurements();\n      let l;\n      return n.length === 0 ? l = this.options.paddingStart : l = this.options.lanes === 1 ? ((e = n[n.length - 1]) == null ? void 0 : e.end) ?? 0 : Math.max(\n        ...n.slice(-this.options.lanes).map((s) => s.end)\n      ), l - this.options.scrollMargin + this.options.paddingEnd;\n    }, this._scrollToOffset = (e, {\n      adjustments: n,\n      behavior: l\n    }) => {\n      this.options.scrollToFn(e, { behavior: l, adjustments: n }, this);\n    }, this.measure = () => {\n      var e, n;\n      this.itemSizeCache = /* @__PURE__ */ new Map(), (n = (e = this.options).onChange) == null || n.call(e, this, !1);\n    }, this.setOptions(t);\n  }\n}\nconst ps = (a, t, e, n) => {\n  for (; a <= t; ) {\n    const l = (a + t) / 2 | 0, s = e(l);\n    if (s < n)\n      a = l + 1;\n    else if (s > n)\n      t = l - 1;\n    else\n      return l;\n  }\n  return a > 0 ? a - 1 : 0;\n};\nfunction Ac({\n  measurements: a,\n  outerSize: t,\n  scrollOffset: e\n}) {\n  const n = a.length - 1, s = ps(0, n, (i) => a[i].start, e);\n  let r = s;\n  for (; r < n && a[r].end < e + t; )\n    r++;\n  return { startIndex: s, endIndex: r };\n}\nfunction Oc(a) {\n  const t = new Rc(o(a)), e = Fn(t), n = t._didMount();\n  return ee(\n    () => o(a).getScrollElement(),\n    (l) => {\n      l && t._willUpdate();\n    },\n    {\n      immediate: !0\n    }\n  ), ee(\n    () => o(a),\n    (l) => {\n      t.setOptions({\n        ...l,\n        onChange: (s, r) => {\n          var i;\n          Lo(e), (i = l.onChange) == null || i.call(l, s, r);\n        }\n      }), t._willUpdate(), Lo(e);\n    },\n    {\n      immediate: !0\n    }\n  ), fl(n), e;\n}\nfunction vs(a) {\n  return Oc(\n    B(() => ({\n      observeElementRect: Dc,\n      observeElementOffset: Bc,\n      scrollToFn: Tc,\n      ...o(a)\n    }))\n  );\n}\nconst Hh = /* @__PURE__ */ x({\n  __name: \"ListboxVirtualizer\",\n  props: {\n    options: {},\n    estimateSize: {},\n    textContent: { type: Function }\n  },\n  setup(a) {\n    const t = a, e = Ua(), n = an(), l = kl(), { getItems: s } = ea();\n    n.isVirtual.value = !0;\n    const r = B(() => {\n      const v = l.value;\n      if (v) {\n        const p = window.getComputedStyle(v);\n        return {\n          start: Number.parseFloat(p.paddingBlockStart || p.paddingTop),\n          end: Number.parseFloat(p.paddingBlockEnd || p.paddingBottom)\n        };\n      } else\n        return { start: 0, end: 0 };\n    }), i = vs(\n      {\n        get scrollPaddingStart() {\n          return r.value.start;\n        },\n        get scrollPaddingEnd() {\n          return r.value.end;\n        },\n        get count() {\n          return t.options.length;\n        },\n        get horizontal() {\n          return n.orientation.value === \"horizontal\";\n        },\n        estimateSize() {\n          return t.estimateSize ?? 28;\n        },\n        getScrollElement() {\n          return l.value;\n        },\n        overscan: 12\n      }\n    ), u = B(() => i.value.getVirtualItems().map((v) => ({\n      item: v,\n      is: Ln(e.default({\n        option: t.options[v.index],\n        virtualizer: i.value,\n        virtualItem: v\n      })[0], {\n        key: `${v.key}`,\n        \"data-index\": v.index,\n        \"aria-setsize\": t.options.length,\n        \"aria-posinset\": v.index + 1,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          transform: `translateY(${v.start}px)`,\n          overflowAnchor: \"none\"\n        }\n      })\n    })));\n    n.virtualFocusHook.on((v) => {\n      const p = t.options.findIndex((g) => Array.isArray(n.modelValue.value) ? Gt(g, n.modelValue.value[0], n.by) : Gt(g, n.modelValue.value, n.by));\n      p !== -1 && (v == null || v.preventDefault(), i.value.scrollToIndex(p, { align: \"start\" }), requestAnimationFrame(() => {\n        const g = yc(l.value);\n        g && v && (g == null || g.focus());\n      }));\n    });\n    const d = Tt(\"\", 1e3), c = B(() => {\n      const v = (p) => t.textContent ? t.textContent(p) : p.toString().toLowerCase();\n      return t.options.map((p, g) => ({\n        index: g,\n        textContent: v(p)\n      }));\n    });\n    function f(v, p) {\n      var C, $, h, E;\n      if (!((C = n.firstValue) != null && C.value) || !n.multiple.value || !Array.isArray(n.modelValue.value))\n        return;\n      const m = ($ = s().filter((P) => P.ref.dataset.disabled !== \"\").find((P) => P.ref === n.highlightedElement.value)) == null ? void 0 : $.value;\n      if (!m)\n        return;\n      let _ = null;\n      switch (p) {\n        case \"prev\":\n        case \"next\": {\n          _ = Bt(t.options, n.firstValue.value, m);\n          break;\n        }\n        case \"first\": {\n          _ = Bt(t.options, n.firstValue.value, (h = t.options) == null ? void 0 : h[0]);\n          break;\n        }\n        case \"last\": {\n          _ = Bt(t.options, n.firstValue.value, (E = t.options) == null ? void 0 : E[t.options.length - 1]);\n          break;\n        }\n      }\n      n.modelValue.value = _;\n    }\n    return n.virtualKeydownHook.on((v) => {\n      var _;\n      const p = v.altKey || v.ctrlKey || v.metaKey;\n      if (v.key === \"Tab\" && !p)\n        return;\n      let m = en[v.key];\n      if (p && v.key === \"a\" && n.multiple.value ? (v.preventDefault(), n.modelValue.value = [...t.options], m = \"last\") : v.shiftKey && m && f(v, m), [\"first\", \"last\"].includes(m)) {\n        v.preventDefault();\n        const C = m === \"first\" ? 0 : t.options.length - 1;\n        i.value.scrollToIndex(C), requestAnimationFrame(() => {\n          const $ = s(), h = m === \"first\" ? $[0] : $[$.length - 1];\n          n.onChangeHighlight(h.ref);\n        });\n      } else if (!m && !p) {\n        d.value += v.key;\n        const C = Number((_ = me()) == null ? void 0 : _.getAttribute(\"data-index\")), $ = c.value[C].textContent, h = c.value.map((D) => D.textContent), E = Zn(h, d.value, $), P = c.value.find((D) => D.textContent === E);\n        P && (i.value.scrollToIndex(P.index, { align: \"start\" }), requestAnimationFrame(() => {\n          const D = l.value.querySelector(`[data-index=\"${P.index}\"]`);\n          D instanceof HTMLElement && n.onChangeHighlight(D);\n        }));\n      }\n    }), (v, p) => (b(), ve(\"div\", {\n      \"data-radix-vue-virtualizer\": \"\",\n      style: Me({\n        position: \"relative\",\n        width: \"100%\",\n        height: `${o(i).getTotalSize()}px`\n      })\n    }, [\n      (b(!0), ve(_e, null, ma(u.value, ({ is: g, item: m }) => (b(), S(Xe(g), {\n        key: m.index\n      }))), 128))\n    ], 4));\n  }\n}), [kc, Mc] = te(\"ListboxGroup\"), Wh = /* @__PURE__ */ x({\n  __name: \"ListboxGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = ge(void 0, \"radix-vue-listbox-group\");\n    return Mc({ id: e }), (n, l) => (b(), S(o(O), k({ role: \"group\" }, t, { \"aria-labelledby\": o(e) }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), jh = /* @__PURE__ */ x({\n  __name: \"ListboxGroupLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = kc({ id: \"\" });\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), [nn, Vc] = te(\"MenubarRoot\"), Uh = /* @__PURE__ */ x({\n  __name: \"MenubarRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    dir: {},\n    loop: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), { createCollection: r } = Fe(\"menubar\");\n    r(s);\n    const i = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), u = T(null), { dir: d, loop: c } = ae(e), f = we(d);\n    return Vc({\n      modelValue: i,\n      dir: f,\n      loop: c,\n      onMenuOpen: (v) => {\n        i.value = v, u.value = v;\n      },\n      onMenuClose: () => {\n        i.value = \"\";\n      },\n      onMenuToggle: (v) => {\n        i.value = i.value ? \"\" : v, u.value = v;\n      }\n    }), (v, p) => (b(), S(o(Ft), {\n      \"current-tab-stop-id\": u.value,\n      \"onUpdate:currentTabStopId\": p[0] || (p[0] = (g) => u.value = g),\n      orientation: \"horizontal\",\n      loop: o(c),\n      dir: o(f),\n      \"as-child\": \"\"\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(l),\n          role: \"menubar\"\n        }, {\n          default: y(() => [\n            w(v.$slots, \"default\", { modelValue: o(i) })\n          ]),\n          _: 3\n        }, 512)\n      ]),\n      _: 3\n    }, 8, [\"current-tab-stop-id\", \"loop\", \"dir\"]));\n  }\n}), [So, Fc] = te(\"MenubarMenu\"), Gh = /* @__PURE__ */ x({\n  __name: \"MenubarMenu\",\n  props: {\n    value: {}\n  },\n  setup(a) {\n    const e = ge(a.value), n = nn();\n    R();\n    const l = T(), s = T(!1), r = B(() => n.modelValue.value === e);\n    return ee(r, () => {\n      r.value || (s.value = !1);\n    }), Fc({\n      value: e,\n      triggerElement: l,\n      triggerId: e,\n      contentId: \"\",\n      wasKeyboardTriggerOpenRef: s\n    }), (i, u) => (b(), S(o(so), {\n      open: r.value,\n      modal: !1,\n      dir: o(n).dir.value,\n      \"onUpdate:open\": u[0] || (u[0] = (d) => {\n        d || o(n).onMenuClose();\n      })\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"open\", \"dir\"]));\n  }\n}), qh = /* @__PURE__ */ x({\n  __name: \"MenubarTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = nn(), e = So(), { forwardRef: n, currentElement: l } = R(), s = T(!1), r = B(() => t.modelValue.value === e.value);\n    return le(() => {\n      e.triggerElement = l;\n    }), (i, u) => (b(), S(o(Nt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      \"tab-stop-id\": o(e).value\n    }, {\n      default: y(() => [\n        q(o(Qa), { \"as-child\": \"\" }, {\n          default: y(() => [\n            q(o(O), {\n              id: o(e).triggerId,\n              ref: o(n),\n              as: i.as,\n              type: i.as === \"button\" ? \"button\" : void 0,\n              role: \"menuitem\",\n              \"aria-haspopup\": \"menu\",\n              \"aria-expanded\": r.value,\n              \"aria-controls\": r.value ? o(e).contentId : void 0,\n              \"data-highlighted\": s.value ? \"\" : void 0,\n              \"data-state\": r.value ? \"open\" : \"closed\",\n              \"data-disabled\": i.disabled ? \"\" : void 0,\n              disabled: i.disabled,\n              \"data-value\": o(e).value,\n              \"data-radix-vue-collection-item\": \"\",\n              onPointerdown: u[0] || (u[0] = (d) => {\n                !i.disabled && d.button === 0 && d.ctrlKey === !1 && (o(t).onMenuOpen(o(e).value), r.value || d.preventDefault());\n              }),\n              onPointerenter: u[1] || (u[1] = () => {\n                var c;\n                !!o(t).modelValue.value && !r.value && (o(t).onMenuOpen(o(e).value), (c = o(l)) == null || c.focus());\n              }),\n              onKeydown: u[2] || (u[2] = ie((d) => {\n                i.disabled || ([\"Enter\", \" \"].includes(d.key) && o(t).onMenuToggle(o(e).value), d.key === \"ArrowDown\" && o(t).onMenuOpen(o(e).value), [\"Enter\", \" \", \"ArrowDown\"].includes(d.key) && (o(e).wasKeyboardTriggerOpenRef.value = !0, d.preventDefault()));\n              }, [\"enter\", \"space\", \"arrow-down\"])),\n              onFocus: u[3] || (u[3] = (d) => s.value = !0),\n              onBlur: u[4] || (u[4] = (d) => s.value = !1)\n            }, {\n              default: y(() => [\n                w(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 8, [\"id\", \"as\", \"type\", \"aria-expanded\", \"aria-controls\", \"data-highlighted\", \"data-state\", \"data-disabled\", \"disabled\", \"data-value\"])\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"tab-stop-id\"]));\n  }\n}), Yh = /* @__PURE__ */ x({\n  __name: \"MenubarPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(vo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Xh = /* @__PURE__ */ x({\n  __name: \"MenubarContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    R();\n    const s = nn(), r = So();\n    r.contentId || (r.contentId = ge(void 0, \"radix-vue-menubar-content\"));\n    const { injectCollection: i } = Fe(\"menubar\"), u = i(), d = T(!1);\n    function c(f) {\n      const p = f.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ), m = (s.dir.value === \"rtl\" ? \"ArrowRight\" : \"ArrowLeft\") === f.key;\n      if (!m && p)\n        return;\n      let C = u.value.map((E) => E.dataset.value);\n      m && C.reverse();\n      const $ = C.indexOf(r.value);\n      C = s.loop.value ? Xn(C, $ + 1) : C.slice($ + 1);\n      const [h] = C;\n      h && s.onMenuOpen(h);\n    }\n    return (f, v) => (b(), S(o(fo), k(o(l), {\n      id: o(r).contentId,\n      \"data-radix-menubar-content\": \"\",\n      \"aria-labelledby\": o(r).triggerId,\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onCloseAutoFocus: v[0] || (v[0] = (p) => {\n        var m;\n        !!!o(s).modelValue.value && !d.value && ((m = o(r).triggerElement.value) == null || m.focus()), d.value = !1, p.preventDefault();\n      }),\n      onFocusOutside: v[1] || (v[1] = (p) => {\n        const g = p.target;\n        o(u).some((_) => _.contains(g)) && p.preventDefault();\n      }),\n      onInteractOutside: v[2] || (v[2] = (p) => {\n        d.value = !0;\n      }),\n      onEntryFocus: v[3] || (v[3] = (p) => {\n        o(r).wasKeyboardTriggerOpenRef.value || p.preventDefault();\n      }),\n      onKeydown: ie(c, [\"arrow-right\", \"arrow-left\"])\n    }), {\n      default: y(() => [\n        w(f.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\"]));\n  }\n}), Zh = /* @__PURE__ */ x({\n  __name: \"MenubarArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(lo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Jh = /* @__PURE__ */ x({\n  __name: \"MenubarItem\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(xa), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Qh = /* @__PURE__ */ x({\n  __name: \"MenubarGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(tn), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ey = /* @__PURE__ */ x({\n  __name: \"MenubarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(yo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ty = /* @__PURE__ */ x({\n  __name: \"MenubarCheckboxItem\",\n  props: {\n    checked: { type: [Boolean, String] },\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\", \"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(co), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ay = /* @__PURE__ */ x({\n  __name: \"MenubarItemIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(uo), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ny = /* @__PURE__ */ x({\n  __name: \"MenubarLabel\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(po), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), oy = /* @__PURE__ */ x({\n  __name: \"MenubarRadioGroup\",\n  props: {\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Te(t);\n    return R(), (s, r) => (b(), S(o(mo), W(U({ ...e, ...o(l) })), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ly = /* @__PURE__ */ x({\n  __name: \"MenubarRadioItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    return R(), (s, r) => (b(), S(o(ho), W(U(o(l))), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), sy = /* @__PURE__ */ x({\n  __name: \"MenubarSub\",\n  props: {\n    defaultOpen: { type: Boolean },\n    open: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen ?? !1,\n      passive: e.open === void 0\n    });\n    return (s, r) => (b(), S(o(go), {\n      open: o(l),\n      \"onUpdate:open\": r[0] || (r[0] = (i) => et(l) ? l.value = i : null)\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\", { open: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), ry = /* @__PURE__ */ x({\n  __name: \"MenubarSubContent\",\n  props: {\n    forceMount: { type: Boolean },\n    loop: { type: Boolean },\n    sideOffset: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"entryFocus\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const l = Se(a, t);\n    R();\n    const { injectCollection: s } = Fe(\"menubar\"), r = nn(), i = So(), u = s();\n    function d(c) {\n      if (c.target.hasAttribute(\n        \"data-radix-menubar-subtrigger\"\n      ))\n        return;\n      let p = u.value.map((_) => _.dataset.value);\n      const g = p.indexOf(i.value);\n      p = r.loop.value ? Xn(p, g + 1) : p.slice(g + 1);\n      const [m] = p;\n      m && r.onMenuOpen(m);\n    }\n    return (c, f) => (b(), S(o(bo), k(o(l), {\n      \"data-radix-menubar-content\": \"\",\n      style: {\n        \"--radix-menubar-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-menubar-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-menubar-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-menubar-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-menubar-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      },\n      onKeydown: ie(d, [\"arrow-right\"])\n    }), {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), iy = /* @__PURE__ */ x({\n  __name: \"MenubarSubTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Co), k(t, { \"data-radix-menubar-subtrigger\": \"\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [_t, ms] = te([\"NavigationMenuRoot\", \"NavigationMenuSub\"], \"NavigationMenuContext\"), uy = /* @__PURE__ */ x({\n  __name: \"NavigationMenuRoot\",\n  props: {\n    modelValue: { default: void 0 },\n    defaultValue: {},\n    dir: {},\n    orientation: { default: \"horizontal\" },\n    delayDuration: { default: 200 },\n    skipDelayDuration: { default: 300 },\n    disableClickTrigger: { type: Boolean, default: !1 },\n    disableHoverTrigger: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), s = T(\"\"), { forwardRef: r, currentElement: i } = R(), u = T(), d = T(), { createCollection: c } = Fe(\"nav\");\n    c(u);\n    const { delayDuration: f, skipDelayDuration: v, dir: p, disableClickTrigger: g, disableHoverTrigger: m } = ae(e), _ = we(p), C = Tt(!1, v), $ = B(() => l.value !== \"\" || C.value ? 150 : f.value), h = jn((E) => {\n      typeof E == \"string\" && (s.value = l.value, l.value = E);\n    }, $);\n    return ms({\n      isRootMenu: !0,\n      modelValue: l,\n      previousValue: s,\n      baseId: ge(void 0, \"radix-navigation-menu\"),\n      disableClickTrigger: g,\n      disableHoverTrigger: m,\n      dir: _,\n      orientation: e.orientation,\n      rootNavigationMenu: i,\n      indicatorTrack: u,\n      onIndicatorTrackChange: (E) => {\n        u.value = E;\n      },\n      viewport: d,\n      onViewportChange: (E) => {\n        d.value = E;\n      },\n      onTriggerEnter: (E) => {\n        h(E);\n      },\n      onTriggerLeave: () => {\n        C.value = !0, h(\"\");\n      },\n      onContentEnter: () => {\n        h();\n      },\n      onContentLeave: () => {\n        h(\"\");\n      },\n      onItemSelect: (E) => {\n        s.value = l.value, l.value = E;\n      },\n      onItemDismiss: () => {\n        s.value = l.value, l.value = \"\";\n      }\n    }), (E, P) => (b(), S(o(O), {\n      ref: o(r),\n      \"aria-label\": \"Main\",\n      as: E.as,\n      \"as-child\": E.asChild,\n      \"data-orientation\": E.orientation,\n      dir: o(_),\n      \"data-radix-navigation-menu\": \"\"\n    }, {\n      default: y(() => [\n        w(E.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-orientation\", \"dir\"]));\n  }\n});\nfunction on(a) {\n  return a ? \"open\" : \"closed\";\n}\nfunction hs(a, t) {\n  return `${a}-trigger-${t}`;\n}\nfunction Eo(a, t) {\n  return `${a}-content-${t}`;\n}\nconst Nc = \"navigationMenu.linkSelect\", Va = \"navigationMenu.rootContentDismiss\";\nfunction On(a) {\n  const t = [], e = document.createTreeWalker(a, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (n) => {\n      const l = n.tagName === \"INPUT\" && n.type === \"hidden\";\n      return n.disabled || n.hidden || l ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  for (; e.nextNode(); ) t.push(e.currentNode);\n  return t;\n}\nfunction ys(a) {\n  const t = me();\n  return a.some((e) => e === t ? !0 : (e.focus(), me() !== t));\n}\nfunction Lc(a) {\n  return a.forEach((t) => {\n    t.dataset.tabindex = t.getAttribute(\"tabindex\") || \"\", t.setAttribute(\"tabindex\", \"-1\");\n  }), () => {\n    a.forEach((t) => {\n      const e = t.dataset.tabindex;\n      t.setAttribute(\"tabindex\", e);\n    });\n  };\n}\nfunction gs(a) {\n  return (t) => t.pointerType === \"mouse\" ? a(t) : void 0;\n}\nconst [Po, zc] = te(\"NavigationMenuItem\"), dy = /* @__PURE__ */ x({\n  __name: \"NavigationMenuItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const { injectCollection: e } = Fe(\"nav\"), n = e(), l = _t(), s = ge(t.value), r = T(), i = T(), u = Eo(l.baseId, s);\n    let d = () => ({});\n    const c = T(!1);\n    async function f(m = \"start\") {\n      const _ = document.getElementById(u);\n      if (_) {\n        d();\n        const C = On(_);\n        C.length && ys(m === \"start\" ? C : C.reverse());\n      }\n    }\n    function v() {\n      const m = document.getElementById(u);\n      if (m) {\n        const _ = On(m);\n        _.length && (d = Lc(_));\n      }\n    }\n    zc({\n      value: s,\n      contentId: u,\n      triggerRef: r,\n      focusProxyRef: i,\n      wasEscapeCloseRef: c,\n      onEntryKeyDown: f,\n      onFocusProxyEnter: f,\n      onContentFocusOutside: v,\n      onRootContentClose: v\n    });\n    function p() {\n      var m;\n      l.onItemDismiss(), (m = r.value) == null || m.focus();\n    }\n    function g(m) {\n      const _ = me();\n      if (m.keyCode === 32 || m.key === \"Enter\")\n        if (l.modelValue.value === s) {\n          p(), m.preventDefault();\n          return;\n        } else {\n          m.target.click(), m.preventDefault();\n          return;\n        }\n      const C = n.value.filter(\n        (h) => {\n          var E;\n          return (E = h.parentElement) == null ? void 0 : E.hasAttribute(\"data-menu-item\");\n        }\n      );\n      if (!C.includes(_))\n        return;\n      const $ = At(m, _, void 0, {\n        itemsArray: C,\n        loop: !1\n      });\n      $ && ($ == null || $.focus()), m.preventDefault(), m.stopPropagation();\n    }\n    return (m, _) => (b(), S(o(O), {\n      \"as-child\": m.asChild,\n      as: m.as,\n      \"data-menu-item\": \"\",\n      onKeydown: ie(g, [\"up\", \"down\", \"left\", \"right\", \"home\", \"end\", \"space\"])\n    }, {\n      default: y(() => [\n        w(m.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\"]));\n  }\n}), Kc = /* @__PURE__ */ x({\n  __name: \"NavigationMenuContentImpl\",\n  props: {\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { injectCollection: l } = Fe(\"nav\"), s = l(), { forwardRef: r, currentElement: i } = R(), u = _t(), d = Po(), c = hs(u.baseId, d.value), f = Eo(u.baseId, d.value), v = T(null), p = B(() => {\n      const E = s.value.map((A) => A.id.split(\"trigger-\")[1]);\n      u.dir.value === \"rtl\" && E.reverse();\n      const P = E.indexOf(u.modelValue.value), D = E.indexOf(u.previousValue.value), I = d.value === u.modelValue.value, M = D === E.indexOf(d.value);\n      if (!I && !M)\n        return v.value;\n      const V = (() => {\n        if (P !== D) {\n          if (I && D !== -1)\n            return P > D ? \"from-end\" : \"from-start\";\n          if (M && P !== -1)\n            return P > D ? \"to-start\" : \"to-end\";\n        }\n        return null;\n      })();\n      return v.value = V, V;\n    });\n    function g(h) {\n      var E, P;\n      if (n(\"focusOutside\", h), n(\"interactOutside\", h), !h.defaultPrevented) {\n        d.onContentFocusOutside();\n        const D = h.target;\n        (P = (E = u.rootNavigationMenu) == null ? void 0 : E.value) != null && P.contains(D) && h.preventDefault();\n      }\n    }\n    function m(h) {\n      var E;\n      if (n(\"pointerDownOutside\", h), !h.defaultPrevented) {\n        const P = h.target, D = s.value.some(\n          (M) => M.contains(P)\n        ), I = u.isRootMenu && ((E = u.viewport.value) == null ? void 0 : E.contains(P));\n        (D || I || !u.isRootMenu) && h.preventDefault();\n      }\n    }\n    Ce((h) => {\n      const E = i.value;\n      if (u.isRootMenu && E) {\n        const P = () => {\n          var D;\n          u.onItemDismiss(), d.onRootContentClose(), E.contains(me()) && ((D = d.triggerRef.value) == null || D.focus());\n        };\n        E.addEventListener(Va, P), h(\n          () => E.removeEventListener(Va, P)\n        );\n      }\n    });\n    function _(h) {\n      var E, P;\n      n(\"escapeKeyDown\", h), h.defaultPrevented || (u.onItemDismiss(), (P = (E = d.triggerRef) == null ? void 0 : E.value) == null || P.focus(), d.wasEscapeCloseRef.value = !0);\n    }\n    function C(h) {\n      var M;\n      if (h.target.closest(\"[data-radix-navigation-menu]\") !== u.rootNavigationMenu.value)\n        return;\n      const E = h.altKey || h.ctrlKey || h.metaKey, P = h.key === \"Tab\" && !E, D = On(h.currentTarget);\n      if (P) {\n        const V = me(), A = D.findIndex(\n          (H) => H === V\n        ), j = h.shiftKey ? D.slice(0, A).reverse() : D.slice(A + 1, D.length);\n        if (ys(j))\n          h.preventDefault();\n        else {\n          (M = d.focusProxyRef.value) == null || M.focus();\n          return;\n        }\n      }\n      const I = At(\n        h,\n        me(),\n        void 0,\n        { itemsArray: D, loop: !1, enableIgnoredElement: !0 }\n      );\n      I == null || I.focus();\n    }\n    function $() {\n      var E;\n      const h = new Event(Va, {\n        bubbles: !0,\n        cancelable: !0\n      });\n      (E = i.value) == null || E.dispatchEvent(h);\n    }\n    return (h, E) => (b(), S(o(Ct), k({\n      id: o(f),\n      ref: o(r),\n      \"aria-labelledby\": o(c),\n      \"data-motion\": p.value,\n      \"data-state\": o(on)(o(u).modelValue.value === o(d).value),\n      \"data-orientation\": o(u).orientation\n    }, e, {\n      onKeydown: C,\n      onEscapeKeyDown: _,\n      onPointerDownOutside: m,\n      onFocusOutside: g,\n      onDismiss: $\n    }), {\n      default: y(() => [\n        w(h.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"aria-labelledby\", \"data-motion\", \"data-state\", \"data-orientation\"]));\n  }\n}), cy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuContent\",\n  props: {\n    forceMount: { type: Boolean },\n    disableOutsidePointerEvents: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Te(n), { forwardRef: s } = R(), r = Ga(), i = _t(), u = Po(), d = B(() => u.value === i.modelValue.value), c = B(() => i.viewport.value && !i.modelValue.value && i.previousValue.value ? i.previousValue.value === u.value : !1);\n    return (f, v) => o(r) ? (b(), S(qt, {\n      key: 0,\n      to: o(i).viewport.value,\n      disabled: !o(i).viewport.value\n    }, [\n      q(o(Pe), {\n        present: f.forceMount || d.value || c.value\n      }, {\n        default: y(() => [\n          q(Kc, k({\n            ref: o(s),\n            \"data-state\": o(on)(d.value),\n            style: {\n              pointerEvents: !d.value && o(i).isRootMenu ? \"none\" : void 0\n            }\n          }, { ...f.$attrs, ...e, ...o(l) }, {\n            onPointerenter: v[0] || (v[0] = (p) => o(i).onContentEnter(o(u).value)),\n            onPointerleave: v[1] || (v[1] = (p) => o(gs)(() => o(i).onContentLeave())(p)),\n            onPointerDownOutside: v[2] || (v[2] = (p) => n(\"pointerDownOutside\", p)),\n            onFocusOutside: v[3] || (v[3] = (p) => n(\"focusOutside\", p)),\n            onInteractOutside: v[4] || (v[4] = (p) => n(\"interactOutside\", p))\n          }), {\n            default: y(() => [\n              w(f.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"data-state\", \"style\"])\n        ]),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\", \"disabled\"])) : ce(\"\", !0);\n  }\n}), fy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), { injectCollection: n } = Fe(\"nav\"), l = n(), s = _t(), r = T(), i = B(() => s.orientation === \"horizontal\"), u = B(() => !!s.modelValue.value), d = T();\n    function c() {\n      d.value && (r.value = {\n        size: i.value ? d.value.offsetWidth : d.value.offsetHeight,\n        offset: i.value ? d.value.offsetLeft : d.value.offsetTop\n      });\n    }\n    return Ce(() => {\n      if (!s.modelValue.value) {\n        r.value = void 0;\n        return;\n      }\n      const f = l.value;\n      d.value = f.find(\n        (v) => v.id.includes(s.modelValue.value)\n      ), c();\n    }), tt(d, c), tt(s.indicatorTrack, c), (f, v) => o(s).indicatorTrack.value ? (b(), S(qt, {\n      key: 0,\n      to: o(s).indicatorTrack.value\n    }, [\n      q(o(Pe), {\n        present: f.forceMount || u.value\n      }, {\n        default: y(() => {\n          var p, g, m, _;\n          return [\n            q(o(O), k({\n              ref: o(e),\n              \"aria-hidden\": \"true\",\n              \"data-state\": u.value ? \"visible\" : \"hidden\",\n              \"data-orientation\": o(s).orientation,\n              \"as-child\": t.asChild,\n              as: f.as,\n              style: {\n                position: \"absolute\",\n                ...i.value ? {\n                  left: 0,\n                  width: `${(p = r.value) == null ? void 0 : p.size}px`,\n                  transform: `translateX(${(g = r.value) == null ? void 0 : g.offset}px)`\n                } : {\n                  top: 0,\n                  height: `${(m = r.value) == null ? void 0 : m.size}px`,\n                  transform: `translateY(${(_ = r.value) == null ? void 0 : _.offset}px)`\n                }\n              }\n            }, f.$attrs), {\n              default: y(() => [\n                w(f.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"data-state\", \"data-orientation\", \"as-child\", \"as\", \"style\"])\n          ];\n        }),\n        _: 3\n      }, 8, [\"present\"])\n    ], 8, [\"to\"])) : ce(\"\", !0);\n  }\n}), py = /* @__PURE__ */ x({\n  __name: \"NavigationMenuLink\",\n  props: {\n    active: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  emits: [\"select\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    async function l(s) {\n      var i;\n      const r = new CustomEvent(Nc, {\n        bubbles: !0,\n        cancelable: !0,\n        detail: {\n          originalEvent: s\n        }\n      });\n      if (n(\"select\", r), !r.defaultPrevented && !s.metaKey) {\n        const u = new CustomEvent(\n          Va,\n          {\n            bubbles: !0,\n            cancelable: !0\n          }\n        );\n        (i = s.target) == null || i.dispatchEvent(u);\n      }\n    }\n    return (s, r) => (b(), S(o(O), {\n      as: s.as,\n      \"data-active\": s.active ? \"\" : void 0,\n      \"aria-current\": s.active ? \"page\" : void 0,\n      \"as-child\": e.asChild,\n      \"data-radix-vue-collection-item\": \"\",\n      onClick: l\n    }, {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"data-active\", \"aria-current\", \"as-child\"]));\n  }\n}), vy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuList\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  setup(a) {\n    const t = a, e = _t(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.onIndicatorTrackChange(l.value);\n    }), (s, r) => (b(), S(o(O), {\n      ref: o(n),\n      style: { position: \"relative\" }\n    }, {\n      default: y(() => [\n        q(o(O), k(s.$attrs, {\n          \"as-child\": t.asChild,\n          as: s.as,\n          \"data-orientation\": o(e).orientation\n        }), {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as-child\", \"as\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 512));\n  }\n}), my = /* @__PURE__ */ x({\n  __name: \"NavigationMenuSub\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"modelValue\", t, {\n      defaultValue: e.defaultValue ?? \"\",\n      passive: e.modelValue === void 0\n    }), s = T(\"\"), r = _t(), { forwardRef: i, currentElement: u } = R(), d = T(), c = T(), { createCollection: f } = Fe(\"nav\");\n    return f(d), ms({\n      ...r,\n      isRootMenu: !1,\n      modelValue: l,\n      previousValue: s,\n      orientation: e.orientation,\n      rootNavigationMenu: u,\n      indicatorTrack: d,\n      onIndicatorTrackChange: (v) => {\n        d.value = v;\n      },\n      viewport: c,\n      onViewportChange: (v) => {\n        c.value = v;\n      },\n      onTriggerEnter: (v) => {\n        l.value = v;\n      },\n      onTriggerLeave: () => {\n      },\n      onContentEnter: () => {\n      },\n      onContentLeave: () => {\n      },\n      onItemSelect: (v) => {\n        l.value = v;\n      },\n      onItemDismiss: () => {\n        l.value = \"\";\n      }\n    }), (v, p) => (b(), S(o(O), {\n      ref: o(i),\n      \"data-orientation\": v.orientation,\n      \"as-child\": e.asChild,\n      as: v.as,\n      \"data-radix-navigation-menu\": \"\"\n    }, {\n      default: y(() => [\n        w(v.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), Hc = [\"aria-owns\"], hy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = _t(), n = Po(), { forwardRef: l, currentElement: s } = R(), r = T(\"\"), i = T(\"\"), u = Tt(!1, 300), d = T(!1), c = B(() => n.value === e.modelValue.value);\n    le(() => {\n      n.triggerRef = s, r.value = hs(e.baseId, n.value), i.value = Eo(e.baseId, n.value);\n    });\n    function f() {\n      e.disableHoverTrigger.value || (d.value = !1, n.wasEscapeCloseRef.value = !1);\n    }\n    function v($) {\n      if (!e.disableHoverTrigger.value && $.pointerType === \"mouse\") {\n        if (t.disabled || d.value || n.wasEscapeCloseRef.value || u.value)\n          return;\n        e.onTriggerEnter(n.value), u.value = !0;\n      }\n    }\n    function p($) {\n      if (!e.disableHoverTrigger.value && $.pointerType === \"mouse\") {\n        if (t.disabled)\n          return;\n        e.onTriggerLeave(), u.value = !1;\n      }\n    }\n    function g($) {\n      $.pointerType === \"mouse\" && e.disableClickTrigger.value || u.value || (c.value ? e.onItemSelect(\"\") : e.onItemSelect(n.value), d.value = c.value);\n    }\n    function m($) {\n      const E = { horizontal: \"ArrowDown\", vertical: e.dir.value === \"rtl\" ? \"ArrowLeft\" : \"ArrowRight\" }[e.orientation];\n      c.value && $.key === E && (n.onEntryKeyDown(), $.preventDefault(), $.stopPropagation());\n    }\n    function _($) {\n      n.focusProxyRef.value = $e($);\n    }\n    function C($) {\n      const h = document.getElementById(n.contentId), E = $.relatedTarget, P = E === s.value, D = h == null ? void 0 : h.contains(E);\n      (P || !D) && n.onFocusProxyEnter(P ? \"start\" : \"end\");\n    }\n    return ($, h) => (b(), ve(_e, null, [\n      q(o(O), k({\n        id: r.value,\n        ref: o(l),\n        disabled: $.disabled,\n        \"data-disabled\": $.disabled ? \"\" : void 0,\n        \"data-state\": o(on)(c.value),\n        \"aria-expanded\": c.value,\n        \"aria-controls\": i.value,\n        \"as-child\": t.asChild,\n        as: $.as\n      }, $.$attrs, {\n        \"data-radix-vue-collection-item\": \"\",\n        onPointerenter: f,\n        onPointermove: v,\n        onPointerleave: p,\n        onClick: g,\n        onKeydown: m\n      }), {\n        default: y(() => [\n          w($.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\", \"disabled\", \"data-disabled\", \"data-state\", \"aria-expanded\", \"aria-controls\", \"as-child\", \"as\"]),\n      c.value ? (b(), ve(_e, { key: 0 }, [\n        q(o(Jt), {\n          ref: _,\n          \"aria-hidden\": \"true\",\n          tabindex: 0,\n          onFocus: C\n        }),\n        o(e).viewport ? (b(), ve(\"span\", {\n          key: 0,\n          \"aria-owns\": i.value\n        }, null, 8, Hc)) : ce(\"\", !0)\n      ], 64)) : ce(\"\", !0)\n    ], 64));\n  }\n}), yy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NavigationMenuViewport\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = R(), n = _t(), l = T(), s = B(() => !!n.modelValue.value), r = B(() => n.modelValue.value);\n    ee(e, () => {\n      e.value && n.onViewportChange(e.value);\n    });\n    const i = T();\n    return ee([r, s], async () => {\n      var d, c;\n      if (await oe(), !e.value)\n        return;\n      const u = (c = (d = e.value.querySelector(\"[data-state=open]\")) == null ? void 0 : d.children) == null ? void 0 : c[0];\n      i.value = u;\n    }, { immediate: !0 }), tt(i, () => {\n      i.value && (l.value = {\n        width: i.value.offsetWidth,\n        height: i.value.offsetHeight\n      });\n    }), (u, d) => (b(), S(o(Pe), {\n      present: u.forceMount || s.value\n    }, {\n      default: y(() => {\n        var c, f;\n        return [\n          q(o(O), k(u.$attrs, {\n            ref: o(t),\n            as: u.as,\n            \"as-child\": u.asChild,\n            \"data-state\": o(on)(s.value),\n            \"data-orientation\": o(n).orientation,\n            style: {\n              // Prevent interaction when animating out\n              pointerEvents: !s.value && o(n).isRootMenu ? \"none\" : void 0,\n              \"--radix-navigation-menu-viewport-width\": l.value ? `${(c = l.value) == null ? void 0 : c.width}px` : void 0,\n              \"--radix-navigation-menu-viewport-height\": l.value ? `${(f = l.value) == null ? void 0 : f.height}px` : void 0\n            },\n            onPointerenter: d[0] || (d[0] = (v) => o(n).onContentEnter(o(n).modelValue.value)),\n            onPointerleave: d[1] || (d[1] = (v) => o(gs)(() => o(n).onContentLeave())(v))\n          }), {\n            default: y(() => [\n              w(u.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16, [\"as\", \"as-child\", \"data-state\", \"data-orientation\", \"style\"])\n        ];\n      }),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction bs(a) {\n  const { disabled: t } = a, e = T(), n = ua(), l = () => window.clearTimeout(e.value), s = (v) => {\n    l(), !t.value && (n.trigger(), e.value = window.setTimeout(() => {\n      s(60);\n    }, v));\n  }, r = () => {\n    s(400);\n  }, i = () => {\n    l();\n  }, u = T(!1), d = B(() => $e(a.target)), c = (v) => {\n    v.button !== 0 || u.value || (v.preventDefault(), u.value = !0, r());\n  }, f = () => {\n    u.value = !1, i();\n  };\n  return Je && (He(d || window, \"pointerdown\", c), He(window, \"pointerup\", f), He(window, \"pointercancel\", f)), {\n    isPressed: u,\n    onTrigger: n.on\n  };\n}\nfunction Qo(a, t = T({})) {\n  return $l(() => new Kr(a.value, t.value));\n}\nfunction Wc(a, t = T({})) {\n  return $l(() => new Hr(a.value, t.value));\n}\nfunction el(a, t, e) {\n  let n = a === \"+\" ? t + e : t - e;\n  if (t % 1 !== 0 || e % 1 !== 0) {\n    const l = t.toString().split(\".\"), s = e.toString().split(\".\"), r = l[1] && l[1].length || 0, i = s[1] && s[1].length || 0, u = 10 ** Math.max(r, i);\n    t = Math.round(t * u), e = Math.round(e * u), n = a === \"+\" ? t + e : t - e, n /= u;\n  }\n  return n;\n}\nconst jc = [\"value\", \"name\", \"disabled\", \"required\"], [Do, Uc] = te(\"NumberFieldRoot\"), gy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"NumberFieldRoot\",\n  props: {\n    defaultValue: { default: void 0 },\n    modelValue: {},\n    min: {},\n    max: {},\n    step: { default: 1 },\n    formatOptions: {},\n    locale: { default: \"en-US\" },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l, min: s, max: r, step: i, locale: u, formatOptions: d, id: c } = ae(e), f = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { primitiveElement: v, currentElement: p } = Re(), g = at(p), m = T(), _ = B(\n      () => H(f.value) === s.value || (s.value && !isNaN(f.value) ? el(\"-\", f.value, i.value) < s.value : !1)\n    ), C = B(\n      () => H(f.value) === r.value || (r.value && !isNaN(f.value) ? el(\"+\", f.value, i.value) > r.value : !1)\n    );\n    function $(G, J = 1) {\n      var K;\n      const z = I.parse(((K = m.value) == null ? void 0 : K.value) ?? \"\");\n      e.disabled || (isNaN(z) ? f.value = s.value ?? 0 : G === \"increase\" ? f.value = H(z + (i.value ?? 1) * J) : f.value = H(z - (i.value ?? 1) * J));\n    }\n    function h(G = 1) {\n      $(\"increase\", G);\n    }\n    function E(G = 1) {\n      $(\"decrease\", G);\n    }\n    function P(G) {\n      G === \"min\" && s.value !== void 0 ? f.value = H(s.value) : G === \"max\" && r.value !== void 0 && (f.value = H(r.value));\n    }\n    const D = Qo(u, d), I = Wc(u, d), M = B(() => D.resolvedOptions().maximumFractionDigits > 0 ? \"decimal\" : \"numeric\"), V = Qo(u, d), A = B(() => isNaN(f.value) ? \"\" : V.format(f.value));\n    function F(G) {\n      return I.isValidPartialNumber(G, s.value, r.value);\n    }\n    function j(G) {\n      m.value && (m.value.value = G);\n    }\n    function H(G) {\n      let J;\n      return i.value === void 0 || isNaN(i.value) ? J = Ut(G, s.value, r.value) : J = Wr(G, s.value, r.value, i.value), J = I.parse(D.format(J)), J;\n    }\n    function Q(G) {\n      const J = I.parse(G);\n      return f.value = H(J), G.length ? (isNaN(J), j(A.value)) : j(G);\n    }\n    return Uc({\n      modelValue: f,\n      handleDecrease: E,\n      handleIncrease: h,\n      handleMinMaxValue: P,\n      inputMode: M,\n      inputEl: m,\n      onInputElement: (G) => m.value = G,\n      textValue: A,\n      validate: F,\n      applyInputValue: Q,\n      disabled: l,\n      max: r,\n      min: s,\n      isDecreaseDisabled: _,\n      isIncreaseDisabled: C,\n      id: c\n    }), (G, J) => (b(), ve(_e, null, [\n      q(o(O), k(G.$attrs, {\n        ref_key: \"primitiveElement\",\n        ref: v,\n        role: \"group\",\n        as: G.as,\n        \"as-child\": G.asChild,\n        \"data-disabled\": o(l) ? \"\" : void 0\n      }), {\n        default: y(() => [\n          w(G.$slots, \"default\", {\n            modelValue: o(f),\n            textValue: A.value\n          })\n        ]),\n        _: 3\n      }, 16, [\"as\", \"as-child\", \"data-disabled\"]),\n      o(g) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(f),\n        name: e.name,\n        disabled: e.disabled,\n        required: e.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, jc)) : ce(\"\", !0)\n    ], 64));\n  }\n}), by = /* @__PURE__ */ x({\n  __name: \"NumberFieldInput\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, { primitiveElement: e, currentElement: n } = Re(), l = Do();\n    function s(u) {\n      u.target === me() && (Math.abs(u.deltaY) <= Math.abs(u.deltaX) || (u.preventDefault(), u.deltaY > 0 ? l.handleIncrease() : u.deltaY < 0 && l.handleDecrease()));\n    }\n    le(() => {\n      l.onInputElement(n.value);\n    });\n    const r = T(l.textValue.value);\n    ee(() => l.textValue.value, () => {\n      r.value = l.textValue.value;\n    }, { immediate: !0, deep: !0 });\n    function i() {\n      requestAnimationFrame(() => {\n        r.value = l.textValue.value;\n      });\n    }\n    return (u, d) => (b(), S(o(O), k(t, {\n      id: o(l).id.value,\n      ref_key: \"primitiveElement\",\n      ref: e,\n      value: r.value,\n      role: \"spinbutton\",\n      type: \"text\",\n      tabindex: \"0\",\n      inputmode: o(l).inputMode.value,\n      disabled: o(l).disabled.value ? \"\" : void 0,\n      \"data-disabled\": o(l).disabled.value ? \"\" : void 0,\n      autocomplete: \"off\",\n      autocorrect: \"off\",\n      spellcheck: \"false\",\n      \"aria-roledescription\": \"Number field\",\n      \"aria-valuenow\": o(l).modelValue.value,\n      \"aria-valuemin\": o(l).min.value,\n      \"aria-valuemax\": o(l).max.value,\n      onKeydown: [\n        d[0] || (d[0] = ie(ue((c) => o(l).handleIncrease(), [\"prevent\"]), [\"up\"])),\n        d[1] || (d[1] = ie(ue((c) => o(l).handleDecrease(), [\"prevent\"]), [\"down\"])),\n        d[2] || (d[2] = ie(ue((c) => o(l).handleIncrease(10), [\"prevent\"]), [\"page-up\"])),\n        d[3] || (d[3] = ie(ue((c) => o(l).handleDecrease(10), [\"prevent\"]), [\"page-down\"])),\n        d[4] || (d[4] = ie(ue((c) => o(l).handleMinMaxValue(\"min\"), [\"prevent\"]), [\"home\"])),\n        d[5] || (d[5] = ie(ue((c) => o(l).handleMinMaxValue(\"max\"), [\"prevent\"]), [\"end\"])),\n        d[8] || (d[8] = ie((c) => {\n          var f;\n          return o(l).applyInputValue((f = c.target) == null ? void 0 : f.value);\n        }, [\"enter\"]))\n      ],\n      onWheel: s,\n      onBeforeinput: d[6] || (d[6] = (c) => {\n        const f = c.target;\n        let v = f.value.slice(0, f.selectionStart ?? void 0) + (c.data ?? \"\") + f.value.slice(f.selectionEnd ?? void 0);\n        o(l).validate(v) || c.preventDefault();\n      }),\n      onInput: d[7] || (d[7] = (c) => {\n        const f = c.target;\n        r.value = f.value;\n      }),\n      onChange: i,\n      onBlur: d[9] || (d[9] = (c) => {\n        var f;\n        return o(l).applyInputValue((f = c.target) == null ? void 0 : f.value);\n      })\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\", \"value\", \"inputmode\", \"disabled\", \"data-disabled\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\"]));\n  }\n}), Cy = /* @__PURE__ */ x({\n  __name: \"NumberFieldIncrement\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Do(), n = B(() => {\n      var u;\n      return ((u = e.disabled) == null ? void 0 : u.value) || t.disabled || e.isIncreaseDisabled.value;\n    }), { primitiveElement: l, currentElement: s } = Re(), { isPressed: r, onTrigger: i } = bs({ target: s, disabled: n });\n    return i(() => {\n      e.handleIncrease();\n    }), (u, d) => (b(), S(o(O), k(t, {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      tabindex: \"-1\",\n      \"aria-label\": \"Increase\",\n      type: u.as === \"button\" ? \"button\" : void 0,\n      style: {\n        userSelect: o(r) ? \"none\" : void 0\n      },\n      disabled: n.value ? \"\" : void 0,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"data-pressed\": o(r) ? \"true\" : void 0,\n      onContextmenu: d[0] || (d[0] = ue(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"style\", \"disabled\", \"data-disabled\", \"data-pressed\"]));\n  }\n}), wy = /* @__PURE__ */ x({\n  __name: \"NumberFieldDecrement\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Do(), n = B(() => {\n      var u;\n      return ((u = e.disabled) == null ? void 0 : u.value) || t.disabled || e.isDecreaseDisabled.value;\n    }), { primitiveElement: l, currentElement: s } = Re(), { isPressed: r, onTrigger: i } = bs({ target: s, disabled: n });\n    return i(() => {\n      e.handleDecrease();\n    }), (u, d) => (b(), S(o(O), k(t, {\n      ref_key: \"primitiveElement\",\n      ref: l,\n      tabindex: \"-1\",\n      \"aria-label\": \"Decrease\",\n      type: u.as === \"button\" ? \"button\" : void 0,\n      style: {\n        userSelect: o(r) ? \"none\" : void 0\n      },\n      disabled: n.value ? \"\" : void 0,\n      \"data-disabled\": n.value ? \"\" : void 0,\n      \"data-pressed\": o(r) ? \"true\" : void 0,\n      onContextmenu: d[0] || (d[0] = ue(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"style\", \"disabled\", \"data-disabled\", \"data-pressed\"]));\n  }\n}), [aa, Gc] = te(\"PaginationRoot\"), _y = /* @__PURE__ */ x({\n  __name: \"PaginationRoot\",\n  props: {\n    page: {},\n    defaultPage: { default: 1 },\n    itemsPerPage: { default: 10 },\n    total: { default: 0 },\n    siblingCount: { default: 2 },\n    disabled: { type: Boolean },\n    showEdges: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"nav\" }\n  },\n  emits: [\"update:page\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { siblingCount: l, disabled: s, showEdges: r } = ae(e);\n    R();\n    const i = ne(e, \"page\", n, {\n      defaultValue: e.defaultPage,\n      passive: e.page === void 0\n    }), u = B(() => Math.max(1, Math.ceil(e.total / e.itemsPerPage)));\n    return Gc({\n      page: i,\n      onPageChange(d) {\n        i.value = d;\n      },\n      pageCount: u,\n      siblingCount: l,\n      disabled: s,\n      showEdges: r\n    }), (d, c) => (b(), S(o(O), {\n      as: d.as,\n      \"as-child\": d.asChild\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\", {\n          page: o(i),\n          pageCount: u.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), xy = /* @__PURE__ */ x({\n  __name: \"PaginationEllipsis\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), k(t, { \"data-type\": \"ellipsis\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\", {}, () => [\n          ye(\"â€¦\")\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Sy = /* @__PURE__ */ x({\n  __name: \"PaginationFirst\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = aa();\n    R();\n    const n = B(() => e.page.value === 1 || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"First Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(1))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"First page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), Ey = /* @__PURE__ */ x({\n  __name: \"PaginationLast\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = aa();\n    R();\n    const n = B(() => e.page.value === e.pageCount.value || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Last Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(o(e).pageCount.value))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"Last page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n});\nfunction dt(a, t) {\n  const e = t - a + 1;\n  return Array.from({ length: e }, (n, l) => l + a);\n}\nfunction qc(a) {\n  return a.map((t) => typeof t == \"number\" ? { type: \"page\", value: t } : { type: \"ellipsis\" });\n}\nconst Ta = \"ellipsis\";\nfunction Yc(a, t, e, n) {\n  const s = t, r = Math.max(a - e, 1), i = Math.min(a + e, s);\n  if (n) {\n    const d = Math.min(2 * e + 5, t) - 2, c = r > 3 && Math.abs(s - d - 1 + 1) > 2 && Math.abs(r - 1) > 2, f = i < s - 2 && Math.abs(s - d) > 2 && Math.abs(s - i) > 2;\n    if (!c && f)\n      return [...dt(1, d), Ta, s];\n    if (c && !f) {\n      const p = dt(s - d + 1, s);\n      return [1, Ta, ...p];\n    }\n    if (c && f) {\n      const p = dt(r, i);\n      return [1, Ta, ...p, Ta, s];\n    }\n    return dt(1, s);\n  } else {\n    const u = e * 2 + 1;\n    return t < u ? dt(1, s) : a <= e + 1 ? dt(1, u) : t - a <= e ? dt(t - u + 1, s) : dt(r, i);\n  }\n}\nconst Py = /* @__PURE__ */ x({\n  __name: \"PaginationList\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = aa(), n = B(() => qc(\n      Yc(\n        e.page.value,\n        e.pageCount.value,\n        e.siblingCount.value,\n        e.showEdges.value\n      )\n    ));\n    return (l, s) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(l.$slots, \"default\", { items: n.value })\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Dy = /* @__PURE__ */ x({\n  __name: \"PaginationListItem\",\n  props: {\n    value: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = aa(), n = B(() => e.page.value === t.value), l = B(() => e.disabled.value);\n    return (s, r) => (b(), S(o(O), k(t, {\n      \"data-type\": \"page\",\n      \"aria-label\": `Page ${s.value}`,\n      \"aria-current\": n.value ? \"page\" : void 0,\n      \"data-selected\": n.value ? \"true\" : void 0,\n      disabled: l.value,\n      type: s.as === \"button\" ? \"button\" : void 0,\n      onClick: r[0] || (r[0] = (i) => !l.value && o(e).onPageChange(s.value))\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\", {}, () => [\n          ye(De(s.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-current\", \"data-selected\", \"disabled\", \"type\"]));\n  }\n}), $y = /* @__PURE__ */ x({\n  __name: \"PaginationNext\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = aa(), n = B(() => e.page.value === e.pageCount.value || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Next Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(o(e).page.value + 1))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), By = /* @__PURE__ */ x({\n  __name: \"PaginationPrev\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = aa(), n = B(() => e.page.value === 1 || e.disabled.value);\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Previous Page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      disabled: n.value,\n      onClick: s[0] || (s[0] = (r) => !n.value && o(e).onPageChange(o(e).page.value - 1))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"disabled\"]));\n  }\n}), Xc = [\"id\", \"value\", \"name\", \"disabled\", \"required\"], [Zc, Jc] = te(\"PinInputRoot\"), Iy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"PinInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    placeholder: { default: \"\" },\n    mask: { type: Boolean },\n    otp: { type: Boolean },\n    type: { default: \"text\" },\n    dir: {},\n    name: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    id: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"complete\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { mask: l, otp: s, placeholder: r, type: i, disabled: u, dir: d } = ae(e), { forwardRef: c } = R(), f = we(d), v = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? [],\n      passive: e.modelValue === void 0\n    }), p = T(/* @__PURE__ */ new Set());\n    function g(_) {\n      p.value.add(_);\n    }\n    const m = B(() => v.value.filter((C) => !!C).length === p.value.size);\n    return ee(v, () => {\n      m.value && n(\"complete\", v.value);\n    }, { deep: !0 }), Jc({\n      modelValue: v,\n      mask: l,\n      otp: s,\n      placeholder: r,\n      type: i,\n      dir: f,\n      disabled: u,\n      isCompleted: m,\n      inputElements: p,\n      onInputElementChange: g\n    }), (_, C) => (b(), ve(_e, null, [\n      q(o(O), k(_.$attrs, {\n        ref: o(c),\n        dir: o(f),\n        \"data-complete\": m.value ? \"\" : void 0,\n        \"data-disabled\": o(u) ? \"\" : void 0\n      }), {\n        default: y(() => [\n          w(_.$slots, \"default\", { modelValue: o(v) })\n        ]),\n        _: 3\n      }, 16, [\"dir\", \"data-complete\", \"data-disabled\"]),\n      Ye(\"input\", {\n        id: _.id,\n        type: \"text\",\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        value: o(v).join(\"\"),\n        name: _.name,\n        disabled: o(u),\n        required: _.required,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        },\n        onFocus: C[0] || (C[0] = ($) => {\n          var h, E;\n          return (E = (h = Array.from(p.value)) == null ? void 0 : h[0]) == null ? void 0 : E.focus();\n        })\n      }, null, 40, Xc)\n    ], 64));\n  }\n}), Ty = /* @__PURE__ */ x({\n  __name: \"PinInputInput\",\n  props: {\n    index: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = Zc(), n = B(() => Array.from(e.inputElements.value)), l = B(() => e.modelValue.value[t.index]), s = B(() => t.disabled || e.disabled.value), r = B(() => e.otp.value), i = B(() => e.type.value === \"number\"), u = B(() => e.mask.value), { primitiveElement: d, currentElement: c } = Re();\n    function f(D) {\n      var V;\n      const I = D.target;\n      if ((((V = D.data) == null ? void 0 : V.length) ?? 0) > 1) {\n        h(I.value);\n        return;\n      }\n      if (i.value && !/^\\d*$/.test(I.value)) {\n        I.value = I.value.replace(/\\D/g, \"\");\n        return;\n      }\n      I.value = I.value.slice(-1), P(t.index, I.value);\n      const M = n.value[t.index + 1];\n      M && M.focus();\n    }\n    function v() {\n      const D = c.value;\n      oe(() => {\n        D && !D.value && (D.placeholder = e.placeholder.value);\n      });\n    }\n    function p(D) {\n      At(D, me(), void 0, {\n        itemsArray: n.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: \"horizontal\",\n        dir: e.dir.value\n      });\n    }\n    function g(D) {\n      if (D.preventDefault(), D.target.value)\n        P(t.index, \"\");\n      else {\n        const V = n.value[t.index - 1];\n        V && (V.focus(), P(t.index - 1, \"\"));\n      }\n    }\n    function m(D) {\n      D.key === \"Delete\" && (D.preventDefault(), P(t.index, \"\"));\n    }\n    function _(D) {\n      const I = D.target;\n      I.setSelectionRange(1, 1), I.value || (I.placeholder = \"\");\n    }\n    function C(D) {\n      v();\n    }\n    function $(D) {\n      D.preventDefault();\n      const I = D.clipboardData;\n      if (!I)\n        return;\n      const M = I.getData(\"text\");\n      h(M);\n    }\n    function h(D) {\n      var A;\n      const I = [...e.modelValue.value], M = D.length >= n.value.length ? 0 : t.index, V = Math.min(M + D.length, n.value.length);\n      for (let F = M; F < V; F++) {\n        const j = n.value[F], H = D[F - M];\n        i.value && !/^\\d*$/.test(H) || (I[F] = H, j.focus());\n      }\n      e.modelValue.value = I, (A = n.value[V]) == null || A.focus();\n    }\n    function E(D) {\n      let I = D.length - 1;\n      for (; I >= 0 && D[I] === \"\"; )\n        D.pop(), I--;\n      return D;\n    }\n    function P(D, I) {\n      const M = [...e.modelValue.value];\n      M[D] = I, e.modelValue.value = E(M);\n    }\n    return ee(l, () => {\n      l.value || v();\n    }), le(() => {\n      e.onInputElementChange(c.value);\n    }), Be(() => {\n      var D;\n      (D = e.inputElements) == null || D.value.delete(c.value);\n    }), (D, I) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: d,\n      autocapitalize: \"none\",\n      as: D.as,\n      \"as-child\": D.asChild,\n      autocomplete: r.value ? \"one-time-code\" : \"false\",\n      type: u.value ? \"password\" : \"text\",\n      inputmode: i.value ? \"numeric\" : \"text\",\n      pattern: i.value ? \"[0-9]*\" : void 0,\n      placeholder: o(e).placeholder.value,\n      value: l.value,\n      disabled: s.value,\n      \"data-disabled\": s.value ? \"\" : void 0,\n      \"data-complete\": o(e).isCompleted.value ? \"\" : void 0,\n      \"aria-label\": `pin input ${D.index + 1} of ${n.value.length}`,\n      onInput: I[0] || (I[0] = (M) => f(M)),\n      onKeydown: [\n        ie(p, [\"left\", \"right\", \"up\", \"down\", \"home\", \"end\"]),\n        ie(g, [\"backspace\"]),\n        ie(m, [\"delete\"])\n      ],\n      onFocus: _,\n      onBlur: C,\n      onPaste: $\n    }, {\n      default: y(() => [\n        w(D.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"autocomplete\", \"type\", \"inputmode\", \"pattern\", \"placeholder\", \"value\", \"disabled\", \"data-disabled\", \"data-complete\", \"aria-label\"]));\n  }\n}), [Lt, Qc] = te(\"PopoverRoot\"), Cs = /* @__PURE__ */ x({\n  __name: \"PopoverRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    modal: { type: Boolean, default: !1 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { modal: l } = ae(e), s = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = T(), i = T(!1);\n    return Qc({\n      contentId: \"\",\n      modal: l,\n      open: s,\n      onOpenChange: (u) => {\n        s.value = u;\n      },\n      onOpenToggle: () => {\n        s.value = !s.value;\n      },\n      triggerElement: r,\n      hasCustomAnchor: i\n    }), (u, d) => (b(), S(o(kt), null, {\n      default: y(() => [\n        w(u.$slots, \"default\", { open: o(s) })\n      ]),\n      _: 3\n    }));\n  }\n}), ws = /* @__PURE__ */ x({\n  __name: \"PopoverTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = Lt(), { forwardRef: n, currentElement: l } = R();\n    return le(() => {\n      e.triggerElement.value = l.value;\n    }), (s, r) => (b(), S(Xe(o(e).hasCustomAnchor.value ? o(O) : o(Mt)), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(n),\n          type: s.as === \"button\" ? \"button\" : void 0,\n          \"aria-haspopup\": \"dialog\",\n          \"aria-expanded\": o(e).open.value,\n          \"aria-controls\": o(e).contentId,\n          \"data-state\": o(e).open.value ? \"open\" : \"closed\",\n          as: s.as,\n          \"as-child\": t.asChild,\n          onClick: o(e).onOpenToggle\n        }, {\n          default: y(() => [\n            w(s.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"type\", \"aria-expanded\", \"aria-controls\", \"data-state\", \"as\", \"as-child\", \"onClick\"])\n      ]),\n      _: 3\n    }));\n  }\n}), _s = /* @__PURE__ */ x({\n  __name: \"PopoverPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xs = /* @__PURE__ */ x({\n  __name: \"PopoverContentImpl\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Ot(e), { forwardRef: s } = R(), r = Lt();\n    return Yn(), (i, u) => (b(), S(o(Za), {\n      \"as-child\": \"\",\n      loop: \"\",\n      trapped: i.trapFocus,\n      onMountAutoFocus: u[5] || (u[5] = (d) => n(\"openAutoFocus\", d)),\n      onUnmountAutoFocus: u[6] || (u[6] = (d) => n(\"closeAutoFocus\", d))\n    }, {\n      default: y(() => [\n        q(o(Ct), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": i.disableOutsidePointerEvents,\n          onPointerDownOutside: u[0] || (u[0] = (d) => n(\"pointerDownOutside\", d)),\n          onInteractOutside: u[1] || (u[1] = (d) => n(\"interactOutside\", d)),\n          onEscapeKeyDown: u[2] || (u[2] = (d) => n(\"escapeKeyDown\", d)),\n          onFocusOutside: u[3] || (u[3] = (d) => n(\"focusOutside\", d)),\n          onDismiss: u[4] || (u[4] = (d) => o(r).onOpenChange(!1))\n        }, {\n          default: y(() => [\n            q(o(It), k(o(l), {\n              id: o(r).contentId,\n              ref: o(s),\n              \"data-state\": o(r).open.value ? \"open\" : \"closed\",\n              role: \"dialog\",\n              style: {\n                \"--radix-popover-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n                \"--radix-popover-content-available-width\": \"var(--radix-popper-available-width)\",\n                \"--radix-popover-content-available-height\": \"var(--radix-popper-available-height)\",\n                \"--radix-popover-trigger-width\": \"var(--radix-popper-anchor-width)\",\n                \"--radix-popover-trigger-height\": \"var(--radix-popper-anchor-height)\"\n              }\n            }), {\n              default: y(() => [\n                w(i.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\"])\n          ]),\n          _: 3\n        }, 8, [\"disable-outside-pointer-events\"])\n      ]),\n      _: 3\n    }, 8, [\"trapped\"]));\n  }\n}), ef = /* @__PURE__ */ x({\n  __name: \"PopoverContentModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Lt(), s = T(!1);\n    ya(!0);\n    const r = Se(e, n), { forwardRef: i, currentElement: u } = R();\n    return ga(u), (d, c) => (b(), S(xs, k(o(r), {\n      ref: o(i),\n      \"trap-focus\": o(l).open.value,\n      \"disable-outside-pointer-events\": \"\",\n      onCloseAutoFocus: c[0] || (c[0] = ue(\n        (f) => {\n          var v;\n          n(\"closeAutoFocus\", f), s.value || (v = o(l).triggerElement.value) == null || v.focus();\n        },\n        [\"prevent\"]\n      )),\n      onPointerDownOutside: c[1] || (c[1] = (f) => {\n        n(\"pointerDownOutside\", f);\n        const v = f.detail.originalEvent, p = v.button === 0 && v.ctrlKey === !0, g = v.button === 2 || p;\n        s.value = g;\n      }),\n      onFocusOutside: c[2] || (c[2] = ue(() => {\n      }, [\"prevent\"]))\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"trap-focus\"]));\n  }\n}), tf = /* @__PURE__ */ x({\n  __name: \"PopoverContentNonModal\",\n  props: {\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Lt(), s = T(!1), r = T(!1), i = Se(e, n);\n    return (u, d) => (b(), S(xs, k(o(i), {\n      \"trap-focus\": !1,\n      \"disable-outside-pointer-events\": !1,\n      onCloseAutoFocus: d[0] || (d[0] = (c) => {\n        var f;\n        n(\"closeAutoFocus\", c), c.defaultPrevented || (s.value || (f = o(l).triggerElement.value) == null || f.focus(), c.preventDefault()), s.value = !1, r.value = !1;\n      }),\n      onInteractOutside: d[1] || (d[1] = async (c) => {\n        var p;\n        n(\"interactOutside\", c), c.defaultPrevented || (s.value = !0, c.detail.originalEvent.type === \"pointerdown\" && (r.value = !0));\n        const f = c.target;\n        ((p = o(l).triggerElement.value) == null ? void 0 : p.contains(f)) && c.preventDefault(), c.detail.originalEvent.type === \"focusin\" && r.value && c.preventDefault();\n      })\n    }), {\n      default: y(() => [\n        w(u.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ss = /* @__PURE__ */ x({\n  __name: \"PopoverContent\",\n  props: {\n    forceMount: { type: Boolean },\n    trapFocus: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    disableOutsidePointerEvents: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\", \"focusOutside\", \"interactOutside\", \"openAutoFocus\", \"closeAutoFocus\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Lt(), s = Se(e, n), { forwardRef: r } = R();\n    return l.contentId || (l.contentId = ge(void 0, \"radix-vue-popover-content\")), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        o(l).modal.value ? (b(), S(ef, k({ key: 0 }, o(s), { ref: o(r) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)) : (b(), S(tf, k({ key: 1 }, o(s), { ref: o(r) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Es = /* @__PURE__ */ x({\n  __name: \"PopoverArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Zt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ps = /* @__PURE__ */ x({\n  __name: \"PopoverClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Lt();\n    return (n, l) => (b(), S(o(O), {\n      type: n.as === \"button\" ? \"button\" : void 0,\n      as: n.as,\n      \"as-child\": t.asChild,\n      onClick: l[0] || (l[0] = (s) => o(e).onOpenChange(!1))\n    }, {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\"]));\n  }\n}), Ds = /* @__PURE__ */ x({\n  __name: \"PopoverAnchor\",\n  props: {\n    element: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Lt();\n    return gl(() => {\n      e.hasCustomAnchor.value = !0;\n    }), Be(() => {\n      e.hasCustomAnchor.value = !1;\n    }), (n, l) => (b(), S(o(Mt), W(U(t)), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), ca = 100, [af, nf] = te(\"ProgressRoot\"), $o = (a) => typeof a == \"number\";\nfunction of(a, t) {\n  return ht(a) || $o(a) && !Number.isNaN(a) && a <= t && a >= 0 ? a : (console.error(`Invalid prop \\`value\\` of value \\`${a}\\` supplied to \\`ProgressRoot\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${ca} if no \\`max\\` prop is set)\n  - \\`null\\`  or \\`undefined\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`), null);\n}\nfunction lf(a) {\n  return $o(a) && !Number.isNaN(a) && a > 0 ? a : (console.error(\n    `Invalid prop \\`max\\` of value \\`${a}\\` supplied to \\`ProgressRoot\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${ca}\\`.`\n  ), ca);\n}\nconst Ry = /* @__PURE__ */ x({\n  __name: \"ProgressRoot\",\n  props: {\n    modelValue: {},\n    max: { default: ca },\n    getValueLabel: { type: Function, default: (a, t) => `${Math.round(a / t * ca)}%` },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"update:max\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"modelValue\", n, {\n      passive: e.modelValue === void 0\n    }), s = ne(e, \"max\", n, {\n      passive: e.max === void 0\n    });\n    ee(\n      () => l.value,\n      async (i) => {\n        const u = of(i, e.max);\n        u !== i && (await oe(), l.value = u);\n      },\n      { immediate: !0 }\n    ), ee(\n      () => e.max,\n      (i) => {\n        const u = lf(e.max);\n        u !== i && (s.value = u);\n      },\n      { immediate: !0 }\n    );\n    const r = B(() => ht(l.value) ? \"indeterminate\" : l.value === s.value ? \"complete\" : \"loading\");\n    return nf({\n      modelValue: l,\n      max: s,\n      progressState: r\n    }), (i, u) => (b(), S(o(O), {\n      \"as-child\": i.asChild,\n      as: i.as,\n      \"aria-valuemax\": o(s),\n      \"aria-valuemin\": 0,\n      \"aria-valuenow\": $o(o(l)) ? o(l) : void 0,\n      \"aria-valuetext\": i.getValueLabel(o(l), o(s)),\n      \"aria-label\": i.getValueLabel(o(l), o(s)),\n      role: \"progressbar\",\n      \"data-state\": r.value,\n      \"data-value\": o(l) ?? void 0,\n      \"data-max\": o(s)\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\", { modelValue: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\", \"aria-label\", \"data-state\", \"data-value\", \"data-max\"]));\n  }\n}), Ay = /* @__PURE__ */ x({\n  __name: \"ProgressIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = af();\n    return R(), (n, l) => {\n      var s;\n      return b(), S(o(O), k(t, {\n        \"data-state\": o(e).progressState.value,\n        \"data-value\": ((s = o(e).modelValue) == null ? void 0 : s.value) ?? void 0,\n        \"data-max\": o(e).max.value\n      }), {\n        default: y(() => [\n          w(n.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"data-state\", \"data-value\", \"data-max\"]);\n    };\n  }\n}), [sf, rf] = te(\"RadioGroupRoot\"), Oy = /* @__PURE__ */ x({\n  __name: \"RadioGroupRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    disabled: { type: Boolean, default: !1 },\n    name: {},\n    required: { type: Boolean, default: !1 },\n    orientation: { default: void 0 },\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l } = R(), s = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), { disabled: r, loop: i, orientation: u, name: d, required: c, dir: f } = ae(e), v = we(f);\n    return rf({\n      modelValue: s,\n      changeModelValue: (p) => {\n        s.value = p;\n      },\n      disabled: r,\n      loop: i,\n      orientation: u,\n      name: d == null ? void 0 : d.value,\n      required: c\n    }), (p, g) => (b(), S(o(Ft), {\n      \"as-child\": \"\",\n      orientation: o(u),\n      dir: o(v),\n      loop: o(i)\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(l),\n          role: \"radiogroup\",\n          \"data-disabled\": o(r) ? \"\" : void 0,\n          \"as-child\": p.asChild,\n          as: p.as,\n          required: o(c),\n          \"aria-orientation\": o(u),\n          \"aria-required\": o(c),\n          dir: o(v),\n          name: o(d)\n        }, {\n          default: y(() => [\n            w(p.$slots, \"default\", { modelValue: o(s) })\n          ]),\n          _: 3\n        }, 8, [\"data-disabled\", \"as-child\", \"as\", \"required\", \"aria-orientation\", \"aria-required\", \"dir\", \"name\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), uf = [\"value\", \"checked\", \"name\", \"disabled\", \"required\"], df = /* @__PURE__ */ x({\n  __name: \"Radio\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, l = ne(e, \"checked\", t, {\n      passive: e.checked === void 0\n    }), { value: s } = ae(e), { forwardRef: r, currentElement: i } = R(), u = at(i), d = B(() => {\n      var f;\n      return e.id && i.value ? ((f = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : f.innerText) ?? e.value : void 0;\n    });\n    function c(f) {\n      l.value = !0, u.value && f.stopPropagation();\n    }\n    return (f, v) => (b(), S(o(O), k(f.$attrs, {\n      id: f.id,\n      ref: o(r),\n      role: \"radio\",\n      type: f.as === \"button\" ? \"button\" : void 0,\n      as: f.as,\n      \"aria-checked\": o(l),\n      \"aria-label\": d.value,\n      \"as-child\": f.asChild,\n      disabled: f.disabled ? \"\" : void 0,\n      \"data-state\": o(l) ? \"checked\" : \"unchecked\",\n      \"data-disabled\": f.disabled ? \"\" : void 0,\n      value: o(s),\n      required: f.required,\n      name: f.name,\n      onClick: ue(c, [\"stop\"])\n    }), {\n      default: y(() => [\n        w(f.$slots, \"default\", { checked: o(l) }),\n        o(u) ? (b(), ve(\"input\", {\n          key: 0,\n          type: \"radio\",\n          tabindex: \"-1\",\n          \"aria-hidden\": \"true\",\n          value: o(s),\n          checked: !!o(l),\n          name: f.name,\n          disabled: f.disabled,\n          required: f.required,\n          style: {\n            transform: \"translateX(-100%)\",\n            position: \"absolute\",\n            pointerEvents: \"none\",\n            opacity: 0,\n            margin: 0\n          }\n        }, null, 8, uf)) : ce(\"\", !0)\n      ]),\n      _: 3\n    }, 16, [\"id\", \"type\", \"as\", \"aria-checked\", \"aria-label\", \"as-child\", \"disabled\", \"data-state\", \"data-disabled\", \"value\", \"required\", \"name\"]));\n  }\n}), [cf, ff] = te(\"RadioGroupItem\"), ky = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"RadioGroupItem\",\n  props: {\n    id: {},\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    required: { type: Boolean },\n    name: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e, currentElement: n } = R(), l = sf(), s = B(() => l.disabled.value || t.disabled), r = B(() => l.required.value || t.required), i = B(() => {\n      var f;\n      return ((f = l.modelValue) == null ? void 0 : f.value) === t.value;\n    });\n    ff({ disabled: s, checked: i });\n    const u = T(!1), d = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\n    He(\"keydown\", (f) => {\n      d.includes(f.key) && (u.value = !0);\n    }), He(\"keyup\", () => {\n      u.value = !1;\n    });\n    function c() {\n      setTimeout(() => {\n        var f;\n        u.value && ((f = n.value) == null || f.click());\n      }, 0);\n    }\n    return (f, v) => (b(), S(o(Nt), {\n      checked: i.value,\n      disabled: s.value,\n      \"as-child\": \"\",\n      focusable: !s.value,\n      active: i.value\n    }, {\n      default: y(() => [\n        q(df, k({ ...f.$attrs, ...t }, {\n          ref: o(e),\n          checked: i.value,\n          required: r.value,\n          disabled: s.value,\n          \"onUpdate:checked\": v[0] || (v[0] = (p) => o(l).changeModelValue(f.value)),\n          onKeydown: v[1] || (v[1] = ie(ue(() => {\n          }, [\"prevent\"]), [\"enter\"])),\n          onFocus: c\n        }), {\n          default: y(() => [\n            w(f.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"checked\", \"required\", \"disabled\"])\n      ]),\n      _: 3\n    }, 8, [\"checked\", \"disabled\", \"focusable\", \"active\"]));\n  }\n}), My = /* @__PURE__ */ x({\n  __name: \"RadioGroupIndicator\",\n  props: {\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t } = R(), e = cf();\n    return (n, l) => (b(), S(o(Pe), {\n      present: n.forceMount || o(e).checked.value\n    }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(t),\n          \"data-state\": o(e).checked.value ? \"checked\" : \"unchecked\",\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          \"as-child\": n.asChild,\n          as: n.as\n        }, n.$attrs), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n});\nfunction pf(a) {\n  const t = B(() => a.start.value ? !!a.isDateDisabled(a.start.value) : !1), e = B(() => a.end.value ? !!a.isDateDisabled(a.end.value) : !1), n = B(\n    () => t.value || e.value ? !1 : !!(a.start.value && a.end.value && Ke(a.end.value, a.start.value))\n  ), l = (c) => a.start.value ? Oe(a.start.value, c) : !1, s = (c) => a.end.value ? Oe(a.end.value, c) : !1, r = (c) => a.start.value && Oe(a.start.value, c) || a.end.value && Oe(a.end.value, c) ? !0 : a.end.value && a.start.value ? Rr(c, a.start.value, a.end.value) : !1, i = B(() => {\n    if (a.start.value && a.end.value || !a.start.value || !a.focusedValue.value)\n      return null;\n    const c = Ke(a.start.value, a.focusedValue.value), f = c ? a.start.value : a.focusedValue.value, v = c ? a.focusedValue.value : a.start.value;\n    return Oe(f, v) ? {\n      start: f,\n      end: v\n    } : _l(f, v, a.isDateUnavailable, a.isDateDisabled) ? {\n      start: f,\n      end: v\n    } : null;\n  });\n  return {\n    isInvalid: n,\n    isSelected: r,\n    highlightedRange: i,\n    isSelectionStart: l,\n    isSelectionEnd: s,\n    isHighlightedStart: (c) => !i.value || !i.value.start ? !1 : Oe(i.value.start, c),\n    isHighlightedEnd: (c) => !i.value || !i.value.end ? !1 : Oe(i.value.end, c)\n  };\n}\nconst vf = { style: { border: \"0px\", clip: \"rect(0px, 0px, 0px, 0px)\", \"clip-path\": \"inset(50%)\", height: \"1px\", margin: \"-1px\", overflow: \"hidden\", padding: \"0px\", position: \"absolute\", \"white-space\": \"nowrap\", width: \"1px\" } }, mf = {\n  role: \"heading\",\n  \"aria-level\": \"2\"\n}, [na, hf] = te(\"RangeCalendarRoot\"), yf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarRoot\",\n  props: {\n    defaultPlaceholder: {},\n    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },\n    modelValue: {},\n    placeholder: { default: void 0 },\n    pagedNavigation: { type: Boolean, default: !1 },\n    preventDeselect: { type: Boolean, default: !1 },\n    weekStartsOn: { default: 0 },\n    weekdayFormat: { default: \"narrow\" },\n    calendarLabel: {},\n    fixedWeeks: { type: Boolean, default: !1 },\n    maxValue: {},\n    minValue: {},\n    locale: { default: \"en\" },\n    numberOfMonths: { default: 1 },\n    disabled: { type: Boolean, default: !1 },\n    readonly: { type: Boolean, default: !1 },\n    initialFocus: { type: Boolean, default: !1 },\n    isDateDisabled: { type: Function, default: void 0 },\n    isDateUnavailable: { type: Function, default: void 0 },\n    dir: {},\n    nextPage: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  emits: [\"update:modelValue\", \"update:placeholder\", \"update:startValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, {\n      disabled: l,\n      readonly: s,\n      initialFocus: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: f,\n      preventDeselect: v,\n      isDateUnavailable: p,\n      isDateDisabled: g,\n      calendarLabel: m,\n      maxValue: _,\n      minValue: C,\n      locale: $,\n      dir: h,\n      nextPage: E,\n      prevPage: P\n    } = ae(e), { primitiveElement: D, currentElement: I } = Re(), M = we(h), V = T(), A = T(), F = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue ?? { start: void 0, end: void 0 },\n      passive: e.modelValue === void 0\n    }), j = Yt({\n      defaultPlaceholder: e.placeholder,\n      defaultValue: F.value.start,\n      locale: e.locale\n    }), H = T(F.value.start), Q = T(F.value.end), G = ne(e, \"placeholder\", n, {\n      defaultValue: e.defaultPlaceholder ?? j.copy(),\n      passive: e.placeholder === void 0\n    });\n    function J(he) {\n      G.value = he.copy();\n    }\n    const {\n      fullCalendarLabel: z,\n      headingValue: K,\n      isDateDisabled: L,\n      isDateUnavailable: N,\n      isNextButtonDisabled: Z,\n      isPrevButtonDisabled: Y,\n      grid: re,\n      weekdays: X,\n      isOutsideVisibleView: se,\n      nextPage: fe,\n      prevPage: xe,\n      formatter: Ee\n    } = Jl({\n      locale: $,\n      placeholder: G,\n      weekStartsOn: u,\n      fixedWeeks: c,\n      numberOfMonths: f,\n      minValue: C,\n      maxValue: _,\n      disabled: l,\n      weekdayFormat: d,\n      pagedNavigation: i,\n      isDateDisabled: g.value,\n      isDateUnavailable: p.value,\n      calendarLabel: m,\n      nextPage: E,\n      prevPage: P\n    }), {\n      isInvalid: be,\n      isSelected: de,\n      highlightedRange: Ie,\n      isSelectionStart: Ae,\n      isSelectionEnd: We,\n      isHighlightedStart: Et,\n      isHighlightedEnd: yr\n    } = pf({\n      start: H,\n      end: Q,\n      isDateDisabled: L,\n      isDateUnavailable: N,\n      focusedValue: A\n    });\n    return ee(F, (he) => {\n      var Ne, Ve, Ea, Fo;\n      (!he || !he.start || H.value && !ke(he.start, H.value)) && (H.value = (Ve = (Ne = he == null ? void 0 : he.start) == null ? void 0 : Ne.copy) == null ? void 0 : Ve.call(Ne)), (!he || !he.end || Q.value && !ke(he.end, Q.value)) && (Q.value = (Fo = (Ea = he == null ? void 0 : he.end) == null ? void 0 : Ea.copy) == null ? void 0 : Fo.call(Ea));\n    }), ee(H, (he) => {\n      he && !ke(he, G.value) && J(he), n(\"update:startValue\", he);\n    }), ee([H, Q], ([he, Ne]) => {\n      const Ve = F.value;\n      if (!(Ve && Ve.start && Ve.end && he && Ne && ke(Ve.start, he) && ke(Ve.end, Ne)))\n        if (he && Ne) {\n          if (Ve.start && Ve.end && ke(Ve.start, he) && ke(Ve.end, Ne))\n            return;\n          Ke(Ne, he) ? F.value = {\n            start: Ne.copy(),\n            end: he.copy()\n          } : F.value = {\n            start: he.copy(),\n            end: Ne.copy()\n          };\n        } else Ve.start && Ve.end && (F.value = {\n          start: he == null ? void 0 : he.copy(),\n          end: void 0\n        });\n    }), hf({\n      isDateUnavailable: N,\n      startValue: H,\n      endValue: Q,\n      formatter: Ee,\n      modelValue: F,\n      placeholder: G,\n      disabled: l,\n      initialFocus: r,\n      pagedNavigation: i,\n      weekStartsOn: u,\n      weekdayFormat: d,\n      fixedWeeks: c,\n      numberOfMonths: f,\n      readonly: s,\n      preventDeselect: v,\n      fullCalendarLabel: z,\n      headingValue: K,\n      isInvalid: be,\n      isDateDisabled: L,\n      highlightedRange: Ie,\n      focusedValue: A,\n      lastPressedDateValue: V,\n      isSelected: de,\n      isSelectionEnd: We,\n      isSelectionStart: Ae,\n      isNextButtonDisabled: Z,\n      isPrevButtonDisabled: Y,\n      isOutsideVisibleView: se,\n      nextPage: fe,\n      prevPage: xe,\n      parentElement: I,\n      onPlaceholderChange: J,\n      locale: $,\n      dir: M,\n      isHighlightedStart: Et,\n      isHighlightedEnd: yr\n    }), le(() => {\n      r.value && Pl(I.value);\n    }), (he, Ne) => (b(), S(o(O), {\n      ref_key: \"primitiveElement\",\n      ref: D,\n      as: he.as,\n      \"as-child\": he.asChild,\n      role: \"application\",\n      \"aria-label\": o(z),\n      \"data-readonly\": o(s) ? \"\" : void 0,\n      \"data-disabled\": o(l) ? \"\" : void 0,\n      \"data-invalid\": o(be) ? \"\" : void 0,\n      dir: o(M)\n    }, {\n      default: y(() => [\n        Ye(\"div\", vf, [\n          Ye(\"div\", mf, De(o(z)), 1)\n        ]),\n        w(he.$slots, \"default\", {\n          date: o(G),\n          grid: o(re),\n          weekDays: o(X),\n          weekStartsOn: o(u),\n          locale: o($),\n          fixedWeeks: o(c)\n        })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-label\", \"data-readonly\", \"data-disabled\", \"data-invalid\", \"dir\"]));\n  }\n}), gf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarHeader\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), bf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarHeading\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = na();\n    return (n, l) => (b(), S(o(O), k(t, {\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {\n          headingValue: o(e).headingValue.value\n        }, () => [\n          ye(De(o(e).headingValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"data-disabled\"]));\n  }\n}), Cf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGrid\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"table\" }\n  },\n  setup(a) {\n    const t = a, e = na(), n = B(() => e.disabled.value ? !0 : void 0), l = B(() => e.readonly.value ? !0 : void 0);\n    return (s, r) => (b(), S(o(O), k(t, {\n      tabindex: \"-1\",\n      role: \"grid\",\n      \"aria-readonly\": l.value,\n      \"aria-disabled\": n.value,\n      \"data-readonly\": l.value && \"\",\n      \"data-disabled\": n.value && \"\"\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-readonly\", \"aria-disabled\", \"data-readonly\", \"data-disabled\"]));\n  }\n}), wf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarCell\",\n  props: {\n    date: {},\n    asChild: { type: Boolean },\n    as: { default: \"td\" }\n  },\n  setup(a) {\n    const t = na();\n    return (e, n) => {\n      var l, s;\n      return b(), S(o(O), {\n        as: e.as,\n        \"as-child\": e.asChild,\n        role: \"gridcell\",\n        \"aria-selected\": o(t).isSelected(e.date) ? !0 : void 0,\n        \"aria-disabled\": o(t).isDateDisabled(e.date) || ((s = (l = o(t)).isDateUnavailable) == null ? void 0 : s.call(l, e.date)),\n        \"data-disabled\": o(t).isDateDisabled(e.date) ? \"\" : void 0\n      }, {\n        default: y(() => [\n          w(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"as\", \"as-child\", \"aria-selected\", \"aria-disabled\", \"data-disabled\"]);\n    };\n  }\n}), _f = /* @__PURE__ */ x({\n  __name: \"RangeCalendarHeadCell\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"th\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), xf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarNext\",\n  props: {\n    step: {},\n    nextPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isNextButtonDisabled(t.step, t.nextPage)), n = na();\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Next page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).nextPage(t.step, t.nextPage))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"Next page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Sf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarPrev\",\n  props: {\n    step: {},\n    prevPage: {},\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = B(() => n.disabled.value || n.isPrevButtonDisabled(t.step, t.prevPage)), n = na();\n    return (l, s) => (b(), S(o(O), k(t, {\n      \"aria-label\": \"Previous page\",\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"aria-disabled\": e.value || void 0,\n      \"data-disabled\": e.value || void 0,\n      disabled: e.value,\n      onClick: s[0] || (s[0] = (r) => o(n).prevPage(t.step, t.prevPage))\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\", {}, () => [\n          ye(\"Prev page\")\n        ])\n      ]),\n      _: 3\n    }, 16, [\"type\", \"aria-disabled\", \"data-disabled\", \"disabled\"]));\n  }\n}), Ef = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGridHead\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"thead\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k(t, { \"aria-hidden\": \"true\" }), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Pf = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGridBody\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tbody\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Df = /* @__PURE__ */ x({\n  __name: \"RangeCalendarGridRow\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"tr\" }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), $f = /* @__PURE__ */ x({\n  __name: \"RangeCalendarCellTrigger\",\n  props: {\n    day: {},\n    month: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = na(), n = nt(), { primitiveElement: l, currentElement: s } = Re(), r = B(() => e.formatter.custom(ze(t.day), {\n      weekday: \"long\",\n      month: \"long\",\n      day: \"numeric\",\n      year: \"numeric\"\n    })), i = B(() => e.isDateDisabled(t.day)), u = B(() => {\n      var V;\n      return (V = e.isDateUnavailable) == null ? void 0 : V.call(e, t.day);\n    }), d = B(() => e.isSelected(t.day)), c = B(() => e.isSelectionStart(t.day)), f = B(() => e.isSelectionEnd(t.day)), v = B(() => e.isHighlightedStart(t.day)), p = B(() => e.isHighlightedEnd(t.day)), g = B(() => e.highlightedRange.value ? Ar(t.day, e.highlightedRange.value.start, e.highlightedRange.value.end) : !1), m = \"[data-radix-vue-calendar-cell-trigger]:not([data-disabled]):not([data-outside-view]):not([data-outside-visible-view])\", _ = B(() => bl(t.day, Hn())), C = B(() => !Cl(t.day, t.month)), $ = B(\n      () => e.isOutsideVisibleView(t.day)\n    ), h = B(() => t.day.day.toLocaleString(e.locale.value)), E = B(() => !e.disabled.value && Oe(t.day, e.placeholder.value));\n    function P(V, A) {\n      var F;\n      if (!e.readonly.value && !(e.isDateDisabled(A) || (F = e.isDateUnavailable) != null && F.call(e, A))) {\n        if (e.lastPressedDateValue.value = A.copy(), e.startValue.value && e.highlightedRange.value === null) {\n          if (Oe(A, e.startValue.value) && !e.preventDeselect.value && !e.endValue.value) {\n            e.startValue.value = void 0, e.onPlaceholderChange(A);\n            return;\n          } else if (!e.endValue.value) {\n            V.preventDefault(), e.lastPressedDateValue.value && Oe(e.lastPressedDateValue.value, A) && (e.startValue.value = A.copy());\n            return;\n          }\n        }\n        if (e.startValue.value && e.endValue.value && Oe(e.endValue.value, A) && !e.preventDeselect.value) {\n          e.startValue.value = void 0, e.endValue.value = void 0, e.onPlaceholderChange(A);\n          return;\n        }\n        e.startValue.value ? e.endValue.value ? e.endValue.value && e.startValue.value && (e.endValue.value = void 0, e.startValue.value = A.copy()) : e.endValue.value = A.copy() : e.startValue.value = A.copy();\n      }\n    }\n    function D(V) {\n      P(V, t.day);\n    }\n    function I() {\n      var V;\n      e.isDateDisabled(t.day) || (V = e.isDateUnavailable) != null && V.call(e, t.day) || (e.focusedValue.value = t.day.copy());\n    }\n    function M(V) {\n      V.preventDefault(), V.stopPropagation();\n      const A = e.parentElement.value, F = A ? Array.from(A.querySelectorAll(m)) : [];\n      let H = F.indexOf(s.value);\n      const Q = 7, G = e.dir.value === \"rtl\" ? -1 : 1;\n      switch (V.code) {\n        case n.ARROW_RIGHT:\n          H += G;\n          break;\n        case n.ARROW_LEFT:\n          H -= G;\n          break;\n        case n.ARROW_UP:\n          H -= Q;\n          break;\n        case n.ARROW_DOWN:\n          H += Q;\n          break;\n        case n.ENTER:\n        case n.SPACE_CODE:\n          P(V, t.day);\n          return;\n        default:\n          return;\n      }\n      if (H >= 0 && H < F.length) {\n        F[H].focus();\n        return;\n      }\n      if (H < 0) {\n        if (e.isPrevButtonDisabled(\"month\"))\n          return;\n        e.prevPage(), oe(() => {\n          const J = A ? Array.from(A.querySelectorAll(m)) : [];\n          if (!e.pagedNavigation.value) {\n            const z = Ze(e.placeholder.value);\n            J[z - Math.abs(H)].focus();\n            return;\n          }\n          J[J.length - Math.abs(H)].focus();\n        });\n        return;\n      }\n      if (H >= F.length) {\n        if (e.isNextButtonDisabled(\"month\"))\n          return;\n        e.nextPage(), oe(() => {\n          const J = A ? Array.from(A.querySelectorAll(m)) : [];\n          if (!e.pagedNavigation.value) {\n            const z = Ze(e.placeholder.value.add({ months: e.numberOfMonths.value - 1 }));\n            J[J.length - z + H - F.length].focus();\n            return;\n          }\n          J[H - F.length].focus();\n        });\n      }\n    }\n    return (V, A) => (b(), S(o(O), k({\n      ref_key: \"primitiveElement\",\n      ref: l\n    }, t, {\n      role: \"button\",\n      \"aria-label\": r.value,\n      \"data-radix-vue-calendar-cell-trigger\": \"\",\n      \"aria-selected\": d.value ? !0 : void 0,\n      \"aria-disabled\": i.value || u.value ? !0 : void 0,\n      \"data-highlighted\": g.value ? \"\" : void 0,\n      \"data-selection-start\": c.value ? !0 : void 0,\n      \"data-selection-end\": f.value ? !0 : void 0,\n      \"data-highlighted-start\": v.value ? !0 : void 0,\n      \"data-highlighted-end\": p.value ? !0 : void 0,\n      \"data-selected\": d.value ? !0 : void 0,\n      \"data-outside-visible-view\": $.value ? \"\" : void 0,\n      \"data-value\": V.day.toString(),\n      \"data-disabled\": i.value ? \"\" : void 0,\n      \"data-unavailable\": u.value ? \"\" : void 0,\n      \"data-today\": _.value ? \"\" : void 0,\n      \"data-outside-view\": C.value ? \"\" : void 0,\n      \"data-focused\": E.value ? \"\" : void 0,\n      tabindex: E.value ? 0 : C.value || i.value ? void 0 : -1,\n      onClick: D,\n      onFocusin: I,\n      onMouseenter: I,\n      onKeydown: ie(M, [\"up\", \"down\", \"left\", \"right\", \"enter\", \"space\"])\n    }), {\n      default: y(() => [\n        w(V.$slots, \"default\", { dayValue: h.value }, () => [\n          ye(De(h.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"aria-label\", \"aria-selected\", \"aria-disabled\", \"data-highlighted\", \"data-selection-start\", \"data-selection-end\", \"data-highlighted-start\", \"data-highlighted-end\", \"data-selected\", \"data-outside-visible-view\", \"data-value\", \"data-disabled\", \"data-unavailable\", \"data-today\", \"data-outside-view\", \"data-focused\", \"tabindex\"]));\n  }\n}), [Ue, Bf] = te(\"ScrollAreaRoot\"), Vy = /* @__PURE__ */ x({\n  __name: \"ScrollAreaRoot\",\n  props: {\n    type: { default: \"hover\" },\n    dir: {},\n    scrollHideDelay: { default: 600 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, n = T(0), l = T(0), s = T(), r = T(), i = T(), u = T(), d = T(!1), c = T(!1), { type: f, dir: v, scrollHideDelay: p } = ae(e), g = we(v);\n    function m() {\n      var h;\n      (h = s.value) == null || h.scrollTo({\n        top: 0\n      });\n    }\n    function _() {\n      var h;\n      (h = s.value) == null || h.scrollTo({\n        top: 0,\n        left: 0\n      });\n    }\n    t({\n      /** Viewport element within ScrollArea */\n      viewport: s,\n      /** Scroll viewport to top */\n      scrollTop: m,\n      /** Scroll viewport to top-left */\n      scrollTopLeft: _\n    });\n    const { forwardRef: C, currentElement: $ } = R();\n    return Bf({\n      type: f,\n      dir: g,\n      scrollHideDelay: p,\n      scrollArea: $,\n      viewport: s,\n      onViewportChange: (h) => {\n        s.value = h || void 0;\n      },\n      content: r,\n      onContentChange: (h) => {\n        r.value = h;\n      },\n      scrollbarX: i,\n      scrollbarXEnabled: d,\n      scrollbarY: u,\n      scrollbarYEnabled: c,\n      onScrollbarXChange: (h) => {\n        i.value = h || void 0;\n      },\n      onScrollbarYChange: (h) => {\n        u.value = h || void 0;\n      },\n      onScrollbarXEnabledChange: (h) => {\n        d.value = h;\n      },\n      onScrollbarYEnabledChange: (h) => {\n        c.value = h;\n      },\n      onCornerWidthChange: (h) => {\n        n.value = h;\n      },\n      onCornerHeightChange: (h) => {\n        l.value = h;\n      }\n    }), (h, E) => (b(), S(o(O), {\n      ref: o(C),\n      \"as-child\": e.asChild,\n      as: h.as,\n      dir: o(g),\n      style: Me({\n        position: \"relative\",\n        // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n        \"--radix-scroll-area-corner-width\": `${n.value}px`,\n        \"--radix-scroll-area-corner-height\": `${l.value}px`\n      })\n    }, {\n      default: y(() => [\n        w(h.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"dir\", \"style\"]));\n  }\n}), Fy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a, { expose: t }) {\n    const e = a, { nonce: n } = ae(e), l = Ja(n), s = Ue(), r = T();\n    le(() => {\n      s.onViewportChange(r.value), s.onContentChange(u.value);\n    }), t({\n      viewportElement: r\n    });\n    const { forwardRef: i, currentElement: u } = R();\n    return (d, c) => (b(), ve(_e, null, [\n      Ye(\"div\", k({\n        ref_key: \"viewportElement\",\n        ref: r,\n        \"data-radix-scroll-area-viewport\": \"\",\n        style: {\n          /**\n           * We don't support `visible` because the intention is to have at least one scrollbar\n           * if this component is used and `visible` will behave like `auto` in that case\n           * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description\n           *\n           * We don't handle `auto` because the intention is for the native implementation\n           * to be hidden if using this component. We just want to ensure the node is scrollable\n           * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n           * the browser from having to work out whether to render native scrollbars or not,\n           * we tell it to with the intention of hiding them in CSS.\n           */\n          overflowX: o(s).scrollbarXEnabled.value ? \"scroll\" : \"hidden\",\n          overflowY: o(s).scrollbarYEnabled.value ? \"scroll\" : \"hidden\"\n        }\n      }, d.$attrs, { tabindex: 0 }), [\n        q(o(O), {\n          ref: o(i),\n          style: Me({\n            /**\n             * When horizontal scrollbar is visible: this element should be at least\n             * as wide as its children for size calculations to work correctly.\n             *\n             * When horizontal scrollbar is NOT visible: this element's width should\n             * be constrained by the parent container to enable `text-overflow: ellipsis`\n             */\n            minWidth: o(s).scrollbarXEnabled.value ? \"fit-content\" : void 0\n          }),\n          \"as-child\": e.asChild,\n          as: d.as\n        }, {\n          default: y(() => [\n            w(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"style\", \"as-child\", \"as\"])\n      ], 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          ye(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-scroll-area-viewport] { scrollbar-width:none; -ms-overflow-style:none; -webkit-overflow-scrolling:touch; } [data-radix-scroll-area-viewport]::-webkit-scrollbar { display:none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n});\nfunction $s(a, t) {\n  return (e) => {\n    if (a[0] === a[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (a[1] - a[0]);\n    return t[0] + n * (e - a[0]);\n  };\n}\nfunction ln(a) {\n  const t = Bs(a.viewport, a.content), e = a.scrollbar.paddingStart + a.scrollbar.paddingEnd, n = (a.scrollbar.size - e) * t;\n  return Math.max(n, 18);\n}\nfunction Bs(a, t) {\n  const e = a / t;\n  return Number.isNaN(e) ? 0 : e;\n}\nfunction If(a, t = () => {\n}) {\n  let e = { left: a.scrollLeft, top: a.scrollTop }, n = 0;\n  return function l() {\n    const s = { left: a.scrollLeft, top: a.scrollTop }, r = e.left !== s.left, i = e.top !== s.top;\n    (r || i) && t(), e = s, n = window.requestAnimationFrame(l);\n  }(), () => window.cancelAnimationFrame(n);\n}\nfunction tl(a, t, e = \"ltr\") {\n  const n = ln(t), l = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - l, r = t.content - t.viewport, i = s - n, u = e === \"ltr\" ? [0, r] : [r * -1, 0], d = Ut(\n    a,\n    u[0],\n    u[1]\n  );\n  return $s([0, r], [0, i])(d);\n}\nfunction Ra(a) {\n  return a ? Number.parseInt(a, 10) : 0;\n}\nfunction Tf(a, t, e, n = \"ltr\") {\n  const l = ln(e), s = l / 2, r = t || s, i = l - r, u = e.scrollbar.paddingStart + r, d = e.scrollbar.size - e.scrollbar.paddingEnd - i, c = e.content - e.viewport, f = n === \"ltr\" ? [0, c] : [c * -1, 0];\n  return $s(\n    [u, d],\n    f\n  )(a);\n}\nfunction al(a, t) {\n  return a > 0 && a < t;\n}\nconst Is = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarImpl\",\n  props: {\n    isHorizontal: { type: Boolean }\n  },\n  emits: [\"onDragScroll\", \"onWheelScroll\", \"onThumbPointerDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = Ue(), s = sn(), r = rn(), { forwardRef: i, currentElement: u } = R(), d = T(\"\"), c = T();\n    function f(C) {\n      var $, h;\n      if (c.value) {\n        const E = C.clientX - (($ = c.value) == null ? void 0 : $.left), P = C.clientY - ((h = c.value) == null ? void 0 : h.top);\n        n(\"onDragScroll\", { x: E, y: P });\n      }\n    }\n    function v(C) {\n      C.button === 0 && (C.target.setPointerCapture(C.pointerId), c.value = u.value.getBoundingClientRect(), d.value = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = \"none\", l.viewport && (l.viewport.value.style.scrollBehavior = \"auto\"), f(C));\n    }\n    function p(C) {\n      f(C);\n    }\n    function g(C) {\n      const $ = C.target;\n      $.hasPointerCapture(C.pointerId) && $.releasePointerCapture(C.pointerId), document.body.style.webkitUserSelect = d.value, l.viewport && (l.viewport.value.style.scrollBehavior = \"\"), c.value = void 0;\n    }\n    function m(C) {\n      var P;\n      const $ = C.target, h = (P = u.value) == null ? void 0 : P.contains($), E = s.sizes.value.content - s.sizes.value.viewport;\n      h && s.handleWheelScroll(C, E);\n    }\n    le(() => {\n      document.addEventListener(\"wheel\", m, { passive: !1 });\n    }), Be(() => {\n      document.removeEventListener(\"wheel\", m);\n    });\n    function _() {\n      var C, $, h, E, P;\n      u.value && (e.isHorizontal ? s.handleSizeChange({\n        content: ((C = l.viewport.value) == null ? void 0 : C.scrollWidth) ?? 0,\n        viewport: (($ = l.viewport.value) == null ? void 0 : $.offsetWidth) ?? 0,\n        scrollbar: {\n          size: u.value.clientWidth ?? 0,\n          paddingStart: Ra(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Ra(getComputedStyle(u.value).paddingRight)\n        }\n      }) : s.handleSizeChange({\n        content: ((h = l.viewport.value) == null ? void 0 : h.scrollHeight) ?? 0,\n        viewport: ((E = l.viewport.value) == null ? void 0 : E.offsetHeight) ?? 0,\n        scrollbar: {\n          size: ((P = u.value) == null ? void 0 : P.clientHeight) ?? 0,\n          paddingStart: Ra(getComputedStyle(u.value).paddingLeft),\n          paddingEnd: Ra(getComputedStyle(u.value).paddingRight)\n        }\n      }));\n    }\n    return tt(u, _), tt(l.content, _), (C, $) => (b(), S(o(O), {\n      ref: o(i),\n      style: { position: \"absolute\" },\n      \"data-scrollbarimpl\": \"\",\n      as: o(r).as.value,\n      \"as-child\": o(r).asChild.value,\n      onPointerdown: v,\n      onPointermove: p,\n      onPointerup: g\n    }, {\n      default: y(() => [\n        w(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Rf = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarX\",\n  setup(a) {\n    const t = Ue(), e = sn(), { forwardRef: n, currentElement: l } = R();\n    le(() => {\n      l.value && t.onScrollbarXChange(l.value);\n    });\n    const s = B(() => e.sizes.value);\n    return (r, i) => (b(), S(Is, {\n      ref: o(n),\n      \"is-horizontal\": !0,\n      \"data-orientation\": \"horizontal\",\n      style: Me({\n        bottom: 0,\n        left: o(t).dir.value === \"rtl\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        right: o(t).dir.value === \"ltr\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n        \"--radix-scroll-area-thumb-width\": s.value ? `${o(ln)(s.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.x))\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), Af = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarY\",\n  setup(a) {\n    const t = Ue(), e = sn(), { forwardRef: n, currentElement: l } = R();\n    le(() => {\n      l.value && t.onScrollbarYChange(l.value);\n    });\n    const s = B(() => e.sizes.value);\n    return (r, i) => (b(), S(Is, {\n      ref: o(n),\n      \"is-horizontal\": !1,\n      \"data-orientation\": \"vertical\",\n      style: Me({\n        top: 0,\n        right: o(t).dir.value === \"ltr\" ? 0 : void 0,\n        left: o(t).dir.value === \"rtl\" ? 0 : void 0,\n        bottom: \"var(--radix-scroll-area-corner-height)\",\n        \"--radix-scroll-area-thumb-height\": s.value ? `${o(ln)(s.value)}px` : void 0\n      }),\n      onOnDragScroll: i[0] || (i[0] = (u) => o(e).onDragScroll(u.y))\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n}), [sn, Of] = te(\"ScrollAreaScrollbarVisible\"), Bo = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarVisible\",\n  setup(a) {\n    const t = Ue(), e = rn(), { forwardRef: n } = R(), l = T({\n      content: 0,\n      viewport: 0,\n      scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }\n    }), s = B(() => {\n      const C = Bs(l.value.viewport, l.value.content);\n      return C > 0 && C < 1;\n    }), r = T(), i = T(0);\n    function u(C, $) {\n      if (p.value) {\n        const h = t.viewport.value.scrollLeft + C.deltaY;\n        t.viewport.value.scrollLeft = h, al(h, $) && C.preventDefault();\n      } else {\n        const h = t.viewport.value.scrollTop + C.deltaY;\n        t.viewport.value.scrollTop = h, al(h, $) && C.preventDefault();\n      }\n    }\n    function d(C, $) {\n      p.value ? i.value = $.x : i.value = $.y;\n    }\n    function c(C) {\n      i.value = 0;\n    }\n    function f(C) {\n      l.value = C;\n    }\n    function v(C, $) {\n      return Tf(\n        C,\n        i.value,\n        l.value,\n        $\n      );\n    }\n    const p = B(\n      () => e.isHorizontal.value\n    );\n    function g(C) {\n      p.value ? t.viewport.value.scrollLeft = v(\n        C,\n        t.dir.value\n      ) : t.viewport.value.scrollTop = v(C);\n    }\n    function m() {\n      if (p.value) {\n        if (t.viewport.value && r.value) {\n          const C = t.viewport.value.scrollLeft, $ = tl(\n            C,\n            l.value,\n            t.dir.value\n          );\n          r.value.style.transform = `translate3d(${$}px, 0, 0)`;\n        }\n      } else if (t.viewport.value && r.value) {\n        const C = t.viewport.value.scrollTop, $ = tl(C, l.value);\n        r.value.style.transform = `translate3d(0, ${$}px, 0)`;\n      }\n    }\n    function _(C) {\n      r.value = C;\n    }\n    return Of({\n      sizes: l,\n      hasThumb: s,\n      handleWheelScroll: u,\n      handleThumbDown: d,\n      handleThumbUp: c,\n      handleSizeChange: f,\n      onThumbPositionChange: m,\n      onThumbChange: _,\n      onDragScroll: g\n    }), (C, $) => p.value ? (b(), S(Rf, k({ key: 0 }, C.$attrs, { ref: o(n) }), {\n      default: y(() => [\n        w(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : (b(), S(Af, k({ key: 1 }, C.$attrs, { ref: o(n) }), {\n      default: y(() => [\n        w(C.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ts = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarAuto\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = Ue(), e = rn(), { forwardRef: n } = R(), l = T(!1), s = jn(() => {\n      if (t.viewport.value) {\n        const r = t.viewport.value.offsetWidth < t.viewport.value.scrollWidth, i = t.viewport.value.offsetHeight < t.viewport.value.scrollHeight;\n        l.value = e.isHorizontal.value ? r : i;\n      }\n    }, 10);\n    return le(() => s()), tt(t.viewport, s), tt(t.content, s), (r, i) => (b(), S(o(Pe), {\n      present: r.forceMount || l.value\n    }, {\n      default: y(() => [\n        q(Bo, k(r.$attrs, {\n          ref: o(n),\n          \"data-state\": l.value ? \"visible\" : \"hidden\"\n        }), {\n          default: y(() => [\n            w(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), kf = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbarHover\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = Ue(), { forwardRef: e } = R();\n    let n;\n    const l = T(!1);\n    function s() {\n      window.clearTimeout(n), l.value = !0;\n    }\n    function r() {\n      n = window.setTimeout(() => {\n        l.value = !1;\n      }, t.scrollHideDelay.value);\n    }\n    return le(() => {\n      const i = t.scrollArea.value;\n      i && (i.addEventListener(\"pointerenter\", s), i.addEventListener(\"pointerleave\", r));\n    }), Be(() => {\n      const i = t.scrollArea.value;\n      i && (window.clearTimeout(n), i.removeEventListener(\"pointerenter\", s), i.removeEventListener(\"pointerleave\", r));\n    }), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || l.value\n    }, {\n      default: y(() => [\n        q(Ts, k(i.$attrs, {\n          ref: o(e),\n          \"data-state\": l.value ? \"visible\" : \"hidden\"\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Mf = /* @__PURE__ */ x({\n  __name: \"ScrollAreaScrollbarScroll\",\n  props: {\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = Ue(), e = rn(), { forwardRef: n } = R(), { state: l, dispatch: s } = zl(\"hidden\", {\n      hidden: {\n        SCROLL: \"scrolling\"\n      },\n      scrolling: {\n        SCROLL_END: \"idle\",\n        POINTER_ENTER: \"interacting\"\n      },\n      interacting: {\n        SCROLL: \"interacting\",\n        POINTER_LEAVE: \"idle\"\n      },\n      idle: {\n        HIDE: \"hidden\",\n        SCROLL: \"scrolling\",\n        POINTER_ENTER: \"interacting\"\n      }\n    });\n    Ce((i) => {\n      if (l.value === \"idle\") {\n        const u = window.setTimeout(\n          () => s(\"HIDE\"),\n          t.scrollHideDelay.value\n        );\n        i(() => {\n          window.clearTimeout(u);\n        });\n      }\n    });\n    const r = jn(() => s(\"SCROLL_END\"), 100);\n    return Ce((i) => {\n      const u = t.viewport.value, d = e.isHorizontal.value ? \"scrollLeft\" : \"scrollTop\";\n      if (u) {\n        let c = u[d];\n        const f = () => {\n          const v = u[d];\n          c !== v && (s(\"SCROLL\"), r()), c = v;\n        };\n        u.addEventListener(\"scroll\", f), i(() => {\n          u.removeEventListener(\"scroll\", f);\n        });\n      }\n    }), (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l) !== \"hidden\"\n    }, {\n      default: y(() => [\n        q(Bo, k(i.$attrs, { ref: o(n) }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), [rn, Vf] = te(\"ScrollAreaScrollbar\"), Ny = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ScrollAreaScrollbar\",\n  props: {\n    orientation: { default: \"vertical\" },\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = Ue(), l = B(() => t.orientation === \"horizontal\");\n    ee(\n      l,\n      () => {\n        l.value ? n.onScrollbarXEnabledChange(!0) : n.onScrollbarYEnabledChange(!0);\n      },\n      { immediate: !0 }\n    ), Be(() => {\n      n.onScrollbarXEnabledChange(!1), n.onScrollbarYEnabledChange(!1);\n    });\n    const { orientation: s, forceMount: r, asChild: i, as: u } = ae(t);\n    return Vf({\n      orientation: s,\n      forceMount: r,\n      isHorizontal: l,\n      as: u,\n      asChild: i\n    }), (d, c) => o(n).type.value === \"hover\" ? (b(), S(kf, k({ key: 0 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"scroll\" ? (b(), S(Mf, k({ key: 1 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"auto\" ? (b(), S(Ts, k({ key: 2 }, d.$attrs, {\n      ref: o(e),\n      \"force-mount\": o(r)\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"force-mount\"])) : o(n).type.value === \"always\" ? (b(), S(Bo, k({ key: 3 }, d.$attrs, {\n      ref: o(e),\n      \"data-state\": \"visible\"\n    }), {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Ly = /* @__PURE__ */ x({\n  __name: \"ScrollAreaThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Ue(), n = sn();\n    function l(v) {\n      const g = v.target.getBoundingClientRect(), m = v.clientX - g.left, _ = v.clientY - g.top;\n      n.handleThumbDown(v, { x: m, y: _ });\n    }\n    function s(v) {\n      n.handleThumbUp(v);\n    }\n    const { forwardRef: r, currentElement: i } = R(), u = T(), d = B(() => e.viewport.value);\n    function c() {\n      if (!u.value) {\n        const v = If(\n          d.value,\n          n.onThumbPositionChange\n        );\n        u.value = v, n.onThumbPositionChange();\n      }\n    }\n    const f = B(() => n.sizes.value);\n    return bi(f, () => {\n      n.onThumbChange(i.value), d.value && (n.onThumbPositionChange(), d.value.addEventListener(\"scroll\", c));\n    }), Be(() => {\n      var v;\n      d.value.removeEventListener(\"scroll\", c), (v = e.viewport.value) == null || v.removeEventListener(\"scroll\", c);\n    }), (v, p) => (b(), S(o(O), {\n      ref: o(r),\n      \"data-state\": o(n).hasThumb ? \"visible\" : \"hidden\",\n      style: {\n        width: \"var(--radix-scroll-area-thumb-width)\",\n        height: \"var(--radix-scroll-area-thumb-height)\"\n      },\n      \"as-child\": t.asChild,\n      as: v.as,\n      onPointerdown: l,\n      onPointerup: s\n    }, {\n      default: y(() => [\n        w(v.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-state\", \"as-child\", \"as\"]));\n  }\n}), Ff = /* @__PURE__ */ x({\n  __name: \"ScrollAreaCornerImpl\",\n  setup(a) {\n    const t = Ue(), e = T(0), n = T(0), l = B(() => !!e.value && !!n.value);\n    function s() {\n      var u;\n      const i = ((u = t.scrollbarX.value) == null ? void 0 : u.offsetHeight) || 0;\n      t.onCornerHeightChange(i), n.value = i;\n    }\n    function r() {\n      var u;\n      const i = ((u = t.scrollbarY.value) == null ? void 0 : u.offsetWidth) || 0;\n      t.onCornerWidthChange(i), e.value = i;\n    }\n    return tt(t.scrollbarX.value, s), tt(t.scrollbarY.value, r), ee(() => t.scrollbarX.value, s), ee(() => t.scrollbarY.value, r), (i, u) => {\n      var d;\n      return l.value ? (b(), S(o(O), k({\n        key: 0,\n        style: {\n          width: `${e.value}px`,\n          height: `${n.value}px`,\n          position: \"absolute\",\n          right: o(t).dir.value === \"ltr\" ? 0 : void 0,\n          left: o(t).dir.value === \"rtl\" ? 0 : void 0,\n          bottom: 0\n        }\n      }, (d = i.$parent) == null ? void 0 : d.$props), {\n        default: y(() => [\n          w(i.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"style\"])) : ce(\"\", !0);\n    };\n  }\n}), zy = /* @__PURE__ */ x({\n  __name: \"ScrollAreaCorner\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = Ue(), l = B(\n      () => !!n.scrollbarX.value && !!n.scrollbarY.value\n    ), s = B(\n      () => n.type.value !== \"scroll\" && l.value\n    );\n    return (r, i) => s.value ? (b(), S(Ff, k({ key: 0 }, t, { ref: o(e) }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Nf = [\"default-value\"], Lf = /* @__PURE__ */ x({\n  __name: \"BubbleSelect\",\n  props: {\n    autocomplete: {},\n    autofocus: { type: Boolean },\n    disabled: { type: Boolean },\n    form: {},\n    multiple: { type: Boolean },\n    name: {},\n    required: { type: Boolean },\n    size: {},\n    value: {}\n  },\n  setup(a) {\n    const t = a, { value: e } = ae(t), n = T();\n    return (l, s) => (b(), S(o(Jt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        ja(Ye(\"select\", k({\n          ref_key: \"selectElement\",\n          ref: n\n        }, t, {\n          \"onUpdate:modelValue\": s[0] || (s[0] = (r) => et(e) ? e.value = r : null),\n          \"default-value\": o(e)\n        }), [\n          w(l.$slots, \"default\")\n        ], 16, Nf), [\n          [Er, o(e)]\n        ])\n      ]),\n      _: 3\n    }));\n  }\n}), zf = {\n  key: 0,\n  value: \"\"\n}, [xt, Rs] = te(\"SelectRoot\"), [Kf, Hf] = te(\"SelectRoot\"), Ky = /* @__PURE__ */ x({\n  __name: \"SelectRoot\",\n  props: {\n    open: { type: Boolean, default: void 0 },\n    defaultOpen: { type: Boolean },\n    defaultValue: { default: \"\" },\n    modelValue: { default: void 0 },\n    dir: {},\n    name: {},\n    autocomplete: {},\n    disabled: { type: Boolean },\n    required: { type: Boolean }\n  },\n  emits: [\"update:modelValue\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), s = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    }), r = T(), i = T(), u = T({\n      x: 0,\n      y: 0\n    }), d = T(!1), { required: c, disabled: f, dir: v } = ae(e), p = we(v);\n    Rs({\n      triggerElement: r,\n      onTriggerChange: (C) => {\n        r.value = C;\n      },\n      valueElement: i,\n      onValueElementChange: (C) => {\n        i.value = C;\n      },\n      valueElementHasChildren: d,\n      onValueElementHasChildrenChange: (C) => {\n        d.value = C;\n      },\n      contentId: \"\",\n      modelValue: l,\n      onValueChange: (C) => {\n        l.value = C;\n      },\n      open: s,\n      required: c,\n      onOpenChange: (C) => {\n        s.value = C;\n      },\n      dir: p,\n      triggerPointerDownPosRef: u,\n      disabled: f\n    });\n    const g = at(r), m = T(/* @__PURE__ */ new Set()), _ = B(() => Array.from(m.value).map((C) => {\n      var $;\n      return ($ = C.props) == null ? void 0 : $.value;\n    }).join(\";\"));\n    return Hf({\n      onNativeOptionAdd: (C) => {\n        m.value.add(C);\n      },\n      onNativeOptionRemove: (C) => {\n        m.value.delete(C);\n      }\n    }), (C, $) => (b(), S(o(kt), null, {\n      default: y(() => [\n        w(C.$slots, \"default\", {\n          modelValue: o(l),\n          open: o(s)\n        }),\n        o(g) ? (b(), S(Lf, k({ key: _.value }, C.$attrs, {\n          \"aria-hidden\": \"true\",\n          tabindex: \"-1\",\n          required: o(c),\n          name: C.name,\n          autocomplete: C.autocomplete,\n          disabled: o(f),\n          value: o(l),\n          onChange: $[0] || ($[0] = (h) => l.value = h.target.value)\n        }), {\n          default: y(() => [\n            o(l) === void 0 ? (b(), ve(\"option\", zf)) : ce(\"\", !0),\n            (b(!0), ve(_e, null, ma(Array.from(m.value), (h) => (b(), S(Xe(h), k({ ref_for: !0 }, h.props, {\n              key: h.key ?? \"\"\n            }), null, 16))), 128))\n          ]),\n          _: 1\n        }, 16, [\"required\", \"name\", \"autocomplete\", \"disabled\", \"value\"])) : ce(\"\", !0)\n      ]),\n      _: 3\n    }));\n  }\n}), Wf = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"], jf = [\" \", \"Enter\"], qe = 10;\nfunction As(a) {\n  return a === \"\" || ht(a);\n}\nconst Hy = /* @__PURE__ */ x({\n  __name: \"SelectTrigger\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = xt(), n = B(() => {\n      var p;\n      return ((p = e.disabled) == null ? void 0 : p.value) || t.disabled;\n    }), { forwardRef: l, currentElement: s } = R();\n    e.contentId || (e.contentId = ge(void 0, \"radix-vue-select-content\")), le(() => {\n      e.triggerElement = s;\n    });\n    const { injectCollection: r } = Fe(), i = r(), { search: u, handleTypeaheadSearch: d, resetTypeahead: c } = ba(i);\n    function f() {\n      n.value || (e.onOpenChange(!0), c());\n    }\n    function v(p) {\n      f(), e.triggerPointerDownPosRef.value = {\n        x: Math.round(p.pageX),\n        y: Math.round(p.pageY)\n      };\n    }\n    return (p, g) => (b(), S(o(Mt), { \"as-child\": \"\" }, {\n      default: y(() => {\n        var m, _, C, $;\n        return [\n          q(o(O), {\n            ref: o(l),\n            role: \"combobox\",\n            type: p.as === \"button\" ? \"button\" : void 0,\n            \"aria-controls\": o(e).contentId,\n            \"aria-expanded\": o(e).open.value || !1,\n            \"aria-required\": (m = o(e).required) == null ? void 0 : m.value,\n            \"aria-autocomplete\": \"none\",\n            disabled: n.value,\n            dir: (_ = o(e)) == null ? void 0 : _.dir.value,\n            \"data-state\": (C = o(e)) != null && C.open.value ? \"open\" : \"closed\",\n            \"data-disabled\": n.value ? \"\" : void 0,\n            \"data-placeholder\": o(As)(($ = o(e).modelValue) == null ? void 0 : $.value) ? \"\" : void 0,\n            \"as-child\": p.asChild,\n            as: p.as,\n            onClick: g[0] || (g[0] = (h) => {\n              var E;\n              (E = h == null ? void 0 : h.currentTarget) == null || E.focus();\n            }),\n            onPointerdown: g[1] || (g[1] = (h) => {\n              if (h.pointerType === \"touch\")\n                return h.preventDefault();\n              const E = h.target;\n              E.hasPointerCapture(h.pointerId) && E.releasePointerCapture(h.pointerId), h.button === 0 && h.ctrlKey === !1 && (v(h), h.preventDefault());\n            }),\n            onPointerup: g[2] || (g[2] = ue(\n              (h) => {\n                h.pointerType === \"touch\" && v(h);\n              },\n              [\"prevent\"]\n            )),\n            onKeydown: g[3] || (g[3] = (h) => {\n              const E = o(u) !== \"\";\n              !(h.ctrlKey || h.altKey || h.metaKey) && h.key.length === 1 && E && h.key === \" \" || (o(d)(h.key), o(Wf).includes(h.key) && (f(), h.preventDefault()));\n            })\n          }, {\n            default: y(() => [\n              w(p.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"type\", \"aria-controls\", \"aria-expanded\", \"aria-required\", \"disabled\", \"dir\", \"data-state\", \"data-disabled\", \"data-placeholder\", \"as-child\", \"as\"])\n        ];\n      }),\n      _: 3\n    }));\n  }\n}), Wy = /* @__PURE__ */ x({\n  __name: \"SelectPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Io, Uf] = te(\"SelectItemAlignedPosition\"), Gf = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectItemAlignedPosition\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"placed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { injectCollection: l } = Fe(), s = xt(), r = St(), i = l(), u = T(!1), d = T(!0), c = T(), { forwardRef: f, currentElement: v } = R(), { viewport: p, selectedItem: g, selectedItemText: m, focusSelectedItem: _ } = r;\n    function C() {\n      if (s.triggerElement.value && s.valueElement.value && c.value && v.value && (p != null && p.value) && (g != null && g.value) && (m != null && m.value)) {\n        const E = s.triggerElement.value.getBoundingClientRect(), P = v.value.getBoundingClientRect(), D = s.valueElement.value.getBoundingClientRect(), I = m.value.getBoundingClientRect();\n        if (s.dir.value !== \"rtl\") {\n          const Ee = I.left - P.left, be = D.left - Ee, de = E.left - be, Ie = E.width + de, Ae = Math.max(Ie, P.width), We = window.innerWidth - qe, Et = Ut(be, qe, Math.max(qe, We - Ae));\n          c.value.style.minWidth = `${Ie}px`, c.value.style.left = `${Et}px`;\n        } else {\n          const Ee = P.right - I.right, be = window.innerWidth - D.right - Ee, de = window.innerWidth - E.right - be, Ie = E.width + de, Ae = Math.max(Ie, P.width), We = window.innerWidth - qe, Et = Ut(\n            be,\n            qe,\n            Math.max(qe, We - Ae)\n          );\n          c.value.style.minWidth = `${Ie}px`, c.value.style.right = `${Et}px`;\n        }\n        const M = i.value, V = window.innerHeight - qe * 2, A = p.value.scrollHeight, F = window.getComputedStyle(v.value), j = Number.parseInt(\n          F.borderTopWidth,\n          10\n        ), H = Number.parseInt(F.paddingTop, 10), Q = Number.parseInt(\n          F.borderBottomWidth,\n          10\n        ), G = Number.parseInt(\n          F.paddingBottom,\n          10\n        ), J = j + H + A + G + Q, z = Math.min(\n          g.value.offsetHeight * 5,\n          J\n        ), K = window.getComputedStyle(p.value), L = Number.parseInt(K.paddingTop, 10), N = Number.parseInt(\n          K.paddingBottom,\n          10\n        ), Z = E.top + E.height / 2 - qe, Y = V - Z, re = g.value.offsetHeight / 2, X = g.value.offsetTop + re, se = j + H + X, fe = J - se;\n        if (se <= Z) {\n          const Ee = g.value === M[M.length - 1];\n          c.value.style.bottom = \"0px\";\n          const be = v.value.clientHeight - p.value.offsetTop - p.value.offsetHeight, de = Math.max(\n            Y,\n            re + (Ee ? N : 0) + be + Q\n          ), Ie = se + de;\n          c.value.style.height = `${Ie}px`;\n        } else {\n          const Ee = g.value === M[0];\n          c.value.style.top = \"0px\";\n          const de = Math.max(\n            Z,\n            j + p.value.offsetTop + (Ee ? L : 0) + re\n          ) + fe;\n          c.value.style.height = `${de}px`, p.value.scrollTop = se - Z + p.value.offsetTop;\n        }\n        c.value.style.margin = `${qe}px 0`, c.value.style.minHeight = `${z}px`, c.value.style.maxHeight = `${V}px`, n(\"placed\"), requestAnimationFrame(() => u.value = !0);\n      }\n    }\n    const $ = T(\"\");\n    le(async () => {\n      await oe(), C(), v.value && ($.value = window.getComputedStyle(v.value).zIndex);\n    });\n    function h(E) {\n      E && d.value === !0 && (C(), _ == null || _(), d.value = !1);\n    }\n    return Uf({\n      contentWrapper: c,\n      shouldExpandOnScrollRef: u,\n      onScrollButtonChange: h\n    }), (E, P) => (b(), ve(\"div\", {\n      ref_key: \"contentWrapperElement\",\n      ref: c,\n      style: Me({\n        display: \"flex\",\n        flexDirection: \"column\",\n        position: \"fixed\",\n        zIndex: $.value\n      })\n    }, [\n      q(o(O), k({\n        ref: o(f),\n        style: {\n          // When we get the height of the content, it includes borders. If we were to set\n          // the height without having `boxSizing: 'border-box'` it would be too big.\n          boxSizing: \"border-box\",\n          // We need to ensure the content doesn't get taller than the wrapper\n          maxHeight: \"100%\"\n        }\n      }, { ...E.$attrs, ...e }), {\n        default: y(() => [\n          w(E.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16)\n    ], 4));\n  }\n}), qf = /* @__PURE__ */ x({\n  __name: \"SelectPopperPosition\",\n  props: {\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: { default: qe },\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const e = Ot(a);\n    return (n, l) => (b(), S(o(It), k(o(e), { style: {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n      \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n      \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n      \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n      \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n    } }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), zt = {\n  onViewportChange: () => {\n  },\n  itemTextRefCallback: () => {\n  },\n  itemRefCallback: () => {\n  }\n}, [St, Yf] = te(\"SelectContent\"), Xf = /* @__PURE__ */ x({\n  __name: \"SelectContentImpl\",\n  props: {\n    position: { default: \"item-aligned\" },\n    bodyLock: { type: Boolean, default: !0 },\n    side: {},\n    sideOffset: {},\n    align: { default: \"start\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = xt();\n    Yn(), ya(e.bodyLock);\n    const { createCollection: s } = Fe(), r = T();\n    ga(r);\n    const i = s(r), { search: u, handleTypeaheadSearch: d } = ba(i), c = T(), f = T(), v = T(), p = T(!1), g = T(!1);\n    function m() {\n      f.value && r.value && In([f.value, r.value]);\n    }\n    ee(p, () => {\n      m();\n    });\n    const { onOpenChange: _, triggerPointerDownPosRef: C } = l;\n    Ce((P) => {\n      if (!r.value)\n        return;\n      let D = { x: 0, y: 0 };\n      const I = (V) => {\n        var A, F;\n        D = {\n          x: Math.abs(\n            Math.round(V.pageX) - (((A = C.value) == null ? void 0 : A.x) ?? 0)\n          ),\n          y: Math.abs(\n            Math.round(V.pageY) - (((F = C.value) == null ? void 0 : F.y) ?? 0)\n          )\n        };\n      }, M = (V) => {\n        var A;\n        V.pointerType !== \"touch\" && (D.x <= 10 && D.y <= 10 ? V.preventDefault() : (A = r.value) != null && A.contains(V.target) || _(!1), document.removeEventListener(\"pointermove\", I), C.value = null);\n      };\n      C.value !== null && (document.addEventListener(\"pointermove\", I), document.addEventListener(\"pointerup\", M, {\n        capture: !0,\n        once: !0\n      })), P(() => {\n        document.removeEventListener(\"pointermove\", I), document.removeEventListener(\"pointerup\", M, {\n          capture: !0\n        });\n      });\n    });\n    function $(P) {\n      const D = P.ctrlKey || P.altKey || P.metaKey;\n      if (P.key === \"Tab\" && P.preventDefault(), !D && P.key.length === 1 && d(P.key), [\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(P.key)) {\n        let I = i.value;\n        if ([\"ArrowUp\", \"End\"].includes(P.key) && (I = I.slice().reverse()), [\"ArrowUp\", \"ArrowDown\"].includes(P.key)) {\n          const M = P.target, V = I.indexOf(M);\n          I = I.slice(V + 1);\n        }\n        setTimeout(() => In(I)), P.preventDefault();\n      }\n    }\n    const h = B(() => e.position === \"popper\" ? e : {}), E = Ot(h.value);\n    return Yf({\n      content: r,\n      viewport: c,\n      onViewportChange: (P) => {\n        c.value = P;\n      },\n      itemRefCallback: (P, D, I) => {\n        var A, F;\n        const M = !g.value && !I;\n        (((A = l.modelValue) == null ? void 0 : A.value) !== void 0 && ((F = l.modelValue) == null ? void 0 : F.value) === D || M) && (f.value = P, M && (g.value = !0));\n      },\n      selectedItem: f,\n      selectedItemText: v,\n      onItemLeave: () => {\n        var P;\n        (P = r.value) == null || P.focus();\n      },\n      itemTextRefCallback: (P, D, I) => {\n        var A, F;\n        const M = !g.value && !I;\n        (((A = l.modelValue) == null ? void 0 : A.value) !== void 0 && ((F = l.modelValue) == null ? void 0 : F.value) === D || M) && (v.value = P);\n      },\n      focusSelectedItem: m,\n      position: e.position,\n      isPositioned: p,\n      searchRef: u\n    }), (P, D) => (b(), S(o(Za), {\n      \"as-child\": \"\",\n      onMountAutoFocus: D[6] || (D[6] = ue(() => {\n      }, [\"prevent\"])),\n      onUnmountAutoFocus: D[7] || (D[7] = (I) => {\n        var M;\n        n(\"closeAutoFocus\", I), !I.defaultPrevented && ((M = o(l).triggerElement.value) == null || M.focus({ preventScroll: !0 }), I.preventDefault());\n      })\n    }, {\n      default: y(() => [\n        q(o(Ct), {\n          \"as-child\": \"\",\n          \"disable-outside-pointer-events\": \"\",\n          onFocusOutside: D[2] || (D[2] = ue(() => {\n          }, [\"prevent\"])),\n          onDismiss: D[3] || (D[3] = (I) => o(l).onOpenChange(!1)),\n          onEscapeKeyDown: D[4] || (D[4] = (I) => n(\"escapeKeyDown\", I)),\n          onPointerDownOutside: D[5] || (D[5] = (I) => n(\"pointerDownOutside\", I))\n        }, {\n          default: y(() => [\n            (b(), S(Xe(\n              P.position === \"popper\" ? qf : Gf\n            ), k({ ...P.$attrs, ...o(E) }, {\n              id: o(l).contentId,\n              ref: (I) => {\n                r.value = o($e)(I);\n              },\n              role: \"listbox\",\n              \"data-state\": o(l).open.value ? \"open\" : \"closed\",\n              dir: o(l).dir.value,\n              style: {\n                // flex layout so we can place the scroll buttons properly\n                display: \"flex\",\n                flexDirection: \"column\",\n                // reset the outline by default as the content MAY get focused\n                outline: \"none\"\n              },\n              onContextmenu: D[0] || (D[0] = ue(() => {\n              }, [\"prevent\"])),\n              onPlaced: D[1] || (D[1] = (I) => p.value = !0),\n              onKeydown: $\n            }), {\n              default: y(() => [\n                w(P.$slots, \"default\")\n              ]),\n              _: 3\n            }, 16, [\"id\", \"data-state\", \"dir\", \"onKeydown\"]))\n          ]),\n          _: 3\n        })\n      ]),\n      _: 3\n    }));\n  }\n}), Zf = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectProvider\",\n  props: {\n    context: {}\n  },\n  setup(a) {\n    return Rs(a.context), (e, n) => w(e.$slots, \"default\");\n  }\n}), Jf = { key: 1 }, jy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectContent\",\n  props: {\n    forceMount: { type: Boolean },\n    position: {},\n    bodyLock: { type: Boolean },\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean },\n    updatePositionStrategy: {},\n    prioritizePosition: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"closeAutoFocus\", \"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, l = Se(e, t), s = xt(), r = T();\n    le(() => {\n      r.value = new DocumentFragment();\n    });\n    const i = T(), u = B(() => e.forceMount || s.open.value);\n    return (d, c) => {\n      var f;\n      return u.value ? (b(), S(o(Pe), {\n        key: 0,\n        ref_key: \"presenceRef\",\n        ref: i,\n        present: !0\n      }, {\n        default: y(() => [\n          q(Xf, W(U({ ...o(l), ...d.$attrs })), {\n            default: y(() => [\n              w(d.$slots, \"default\")\n            ]),\n            _: 3\n          }, 16)\n        ]),\n        _: 3\n      }, 512)) : !((f = i.value) != null && f.present) && r.value ? (b(), ve(\"div\", Jf, [\n        (b(), S(qt, { to: r.value }, [\n          q(Zf, { context: o(s) }, {\n            default: y(() => [\n              w(d.$slots, \"default\")\n            ]),\n            _: 3\n          }, 8, [\"context\"])\n        ], 8, [\"to\"]))\n      ])) : ce(\"\", !0);\n    };\n  }\n}), Uy = /* @__PURE__ */ x({\n  __name: \"SelectArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a, e = xt(), n = St(zt);\n    return (l, s) => o(e).open.value && o(n).position === \"popper\" ? (b(), S(o(Zt), W(k({ key: 0 }, t)), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), Gy = /* @__PURE__ */ x({\n  __name: \"SelectSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(O), k({ \"aria-hidden\": \"true\" }, t), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), [Os, Qf] = te(\"SelectItem\"), qy = /* @__PURE__ */ x({\n  __name: \"SelectItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    textValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { disabled: e } = ae(t), n = xt(), l = St(zt), { forwardRef: s, currentElement: r } = R(), i = B(() => {\n      var m;\n      return ((m = n.modelValue) == null ? void 0 : m.value) === t.value;\n    }), u = T(!1), d = T(t.textValue ?? \"\"), c = ge(void 0, \"radix-vue-select-item-text\");\n    async function f(m) {\n      await oe(), !(m != null && m.defaultPrevented) && (e.value || (n.onValueChange(t.value), n.onOpenChange(!1)));\n    }\n    async function v(m) {\n      var _;\n      await oe(), !m.defaultPrevented && (e.value ? (_ = l.onItemLeave) == null || _.call(l) : m.currentTarget.focus({ preventScroll: !0 }));\n    }\n    async function p(m) {\n      var _;\n      await oe(), !m.defaultPrevented && m.currentTarget === me() && ((_ = l.onItemLeave) == null || _.call(l));\n    }\n    async function g(m) {\n      var C;\n      await oe(), !(m.defaultPrevented || ((C = l.searchRef) == null ? void 0 : C.value) !== \"\" && m.key === \" \") && (jf.includes(m.key) && f(), m.key === \" \" && m.preventDefault());\n    }\n    if (t.value === \"\")\n      throw new Error(\n        \"A <SelectItem /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\"\n      );\n    return le(() => {\n      r.value && l.itemRefCallback(\n        r.value,\n        t.value,\n        t.disabled\n      );\n    }), Qf({\n      value: t.value,\n      disabled: e,\n      textId: c,\n      isSelected: i,\n      onItemTextChange: (m) => {\n        d.value = ((d.value || (m == null ? void 0 : m.textContent)) ?? \"\").trim();\n      }\n    }), (m, _) => (b(), S(o(O), {\n      ref: o(s),\n      role: \"option\",\n      \"data-radix-vue-collection-item\": \"\",\n      \"aria-labelledby\": o(c),\n      \"data-highlighted\": u.value ? \"\" : void 0,\n      \"aria-selected\": i.value,\n      \"data-state\": i.value ? \"checked\" : \"unchecked\",\n      \"aria-disabled\": o(e) || void 0,\n      \"data-disabled\": o(e) ? \"\" : void 0,\n      tabindex: o(e) ? void 0 : -1,\n      as: m.as,\n      \"as-child\": m.asChild,\n      onFocus: _[0] || (_[0] = (C) => u.value = !0),\n      onBlur: _[1] || (_[1] = (C) => u.value = !1),\n      onPointerup: f,\n      onPointerdown: _[2] || (_[2] = (C) => {\n        C.currentTarget.focus({ preventScroll: !0 });\n      }),\n      onTouchend: _[3] || (_[3] = ue(() => {\n      }, [\"prevent\", \"stop\"])),\n      onPointermove: v,\n      onPointerleave: p,\n      onKeydown: g\n    }, {\n      default: y(() => [\n        w(m.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"aria-labelledby\", \"data-highlighted\", \"aria-selected\", \"data-state\", \"aria-disabled\", \"data-disabled\", \"tabindex\", \"as\", \"as-child\"]));\n  }\n}), Yy = /* @__PURE__ */ x({\n  __name: \"SelectItemIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = Os();\n    return (n, l) => o(e).isSelected.value ? (b(), S(o(O), k({\n      key: 0,\n      \"aria-hidden\": \"true\"\n    }, t), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16)) : ce(\"\", !0);\n  }\n}), [ep, tp] = te(\"SelectGroup\"), Xy = /* @__PURE__ */ x({\n  __name: \"SelectGroup\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = ge(void 0, \"radix-vue-select-group\");\n    return tp({ id: e }), (n, l) => (b(), S(o(O), k({ role: \"group\" }, t, { \"aria-labelledby\": o(e) }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\"]));\n  }\n}), Zy = /* @__PURE__ */ x({\n  __name: \"SelectLabel\",\n  props: {\n    for: {},\n    asChild: { type: Boolean },\n    as: { default: \"div\" }\n  },\n  setup(a) {\n    const t = a, e = ep({ id: \"\" });\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).id\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Jy = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SelectItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = xt(), n = St(zt), l = Kf(), s = Os(), { forwardRef: r, currentElement: i } = R(), u = B(() => {\n      var d;\n      return mt(\"option\", {\n        key: s.value,\n        value: s.value,\n        disabled: s.disabled.value,\n        textContent: (d = i.value) == null ? void 0 : d.textContent\n      });\n    });\n    return le(() => {\n      i.value && (s.onItemTextChange(i.value), n.itemTextRefCallback(\n        i.value,\n        s.value,\n        s.disabled.value\n      ), l.onNativeOptionAdd(u.value));\n    }), Nn(() => {\n      l.onNativeOptionRemove(u.value);\n    }), (d, c) => (b(), ve(_e, null, [\n      q(o(O), k({\n        id: o(s).textId,\n        ref: o(r)\n      }, { ...t, ...d.$attrs }, { \"data-item-text\": \"\" }), {\n        default: y(() => [\n          w(d.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16, [\"id\"]),\n      o(s).isSelected.value && o(e).valueElement.value && !o(e).valueElementHasChildren.value ? (b(), S(qt, {\n        key: 0,\n        to: o(e).valueElement.value\n      }, [\n        w(d.$slots, \"default\")\n      ], 8, [\"to\"])) : ce(\"\", !0)\n    ], 64));\n  }\n}), Qy = /* @__PURE__ */ x({\n  __name: \"SelectViewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { nonce: e } = ae(t), n = Ja(e), l = St(zt), s = l.position === \"item-aligned\" ? Io() : void 0, { forwardRef: r, currentElement: i } = R();\n    le(() => {\n      l == null || l.onViewportChange(i.value);\n    });\n    const u = T(0);\n    function d(c) {\n      const f = c.currentTarget, { shouldExpandOnScrollRef: v, contentWrapper: p } = s ?? {};\n      if (v != null && v.value && (p != null && p.value)) {\n        const g = Math.abs(u.value - f.scrollTop);\n        if (g > 0) {\n          const m = window.innerHeight - qe * 2, _ = Number.parseFloat(\n            p.value.style.minHeight\n          ), C = Number.parseFloat(p.value.style.height), $ = Math.max(_, C);\n          if ($ < m) {\n            const h = $ + g, E = Math.min(m, h), P = h - E;\n            p.value.style.height = `${E}px`, p.value.style.bottom === \"0px\" && (f.scrollTop = P > 0 ? P : 0, p.value.style.justifyContent = \"flex-end\");\n          }\n        }\n      }\n      u.value = f.scrollTop;\n    }\n    return (c, f) => (b(), ve(_e, null, [\n      q(o(O), k({\n        ref: o(r),\n        \"data-radix-select-viewport\": \"\",\n        role: \"presentation\"\n      }, { ...c.$attrs, ...t }, {\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"hidden auto\"\n        },\n        onScroll: d\n      }), {\n        default: y(() => [\n          w(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(n)\n      }, {\n        default: y(() => [\n          ye(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-select-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-select-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n}), ks = /* @__PURE__ */ x({\n  __name: \"SelectScrollButtonImpl\",\n  emits: [\"autoScroll\"],\n  setup(a, { emit: t }) {\n    const e = t, { injectCollection: n } = Fe(), l = n(), s = St(zt), r = T(null);\n    function i() {\n      r.value !== null && (window.clearInterval(r.value), r.value = null);\n    }\n    Ce(() => {\n      const c = l.value.find(\n        (f) => f === me()\n      );\n      c == null || c.scrollIntoView({ block: \"nearest\" });\n    });\n    function u() {\n      r.value === null && (r.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    function d() {\n      var c;\n      (c = s.onItemLeave) == null || c.call(s), r.value === null && (r.value = window.setInterval(() => {\n        e(\"autoScroll\");\n      }, 50));\n    }\n    return Nn(() => i()), (c, f) => {\n      var v;\n      return b(), S(o(O), k({\n        \"aria-hidden\": \"true\",\n        style: {\n          flexShrink: 0\n        }\n      }, (v = c.$parent) == null ? void 0 : v.$props, {\n        onPointerdown: u,\n        onPointermove: d,\n        onPointerleave: f[0] || (f[0] = () => {\n          i();\n        })\n      }), {\n        default: y(() => [\n          w(c.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16);\n    };\n  }\n}), eg = /* @__PURE__ */ x({\n  __name: \"SelectScrollUpButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = St(zt), e = t.position === \"item-aligned\" ? Io() : void 0, { forwardRef: n, currentElement: l } = R(), s = T(!1);\n    return Ce((r) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          s.value = c.scrollTop > 0;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), r(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), ee(l, () => {\n      l.value && (e == null || e.onScrollButtonChange(l.value));\n    }), (r, i) => s.value ? (b(), S(ks, {\n      key: 0,\n      ref: o(n),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = o(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop - d.value.offsetHeight);\n      })\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : ce(\"\", !0);\n  }\n}), tg = /* @__PURE__ */ x({\n  __name: \"SelectScrollDownButton\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = St(zt), e = t.position === \"item-aligned\" ? Io() : void 0, { forwardRef: n, currentElement: l } = R(), s = T(!1);\n    return Ce((r) => {\n      var i, u;\n      if ((i = t.viewport) != null && i.value && ((u = t.isPositioned) != null && u.value)) {\n        let d = function() {\n          const f = c.scrollHeight - c.clientHeight;\n          s.value = Math.ceil(c.scrollTop) < f;\n        };\n        const c = t.viewport.value;\n        d(), c.addEventListener(\"scroll\", d), r(() => c.removeEventListener(\"scroll\", d));\n      }\n    }), ee(l, () => {\n      l.value && (e == null || e.onScrollButtonChange(l.value));\n    }), (r, i) => s.value ? (b(), S(ks, {\n      key: 0,\n      ref: o(n),\n      onAutoScroll: i[0] || (i[0] = () => {\n        const { viewport: u, selectedItem: d } = o(t);\n        u != null && u.value && (d != null && d.value) && (u.value.scrollTop = u.value.scrollTop + d.value.offsetHeight);\n      })\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512)) : ce(\"\", !0);\n  }\n}), ag = /* @__PURE__ */ x({\n  __name: \"SelectValue\",\n  props: {\n    placeholder: { default: \"\" },\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const { forwardRef: t, currentElement: e } = R(), n = xt(), l = Ua();\n    return gl(() => {\n      var r;\n      const s = !!qa((r = l == null ? void 0 : l.default) == null ? void 0 : r.call(l)).length;\n      n.onValueElementHasChildrenChange(s);\n    }), le(() => {\n      n.valueElement = e;\n    }), (s, r) => (b(), S(o(O), {\n      ref: o(t),\n      as: s.as,\n      \"as-child\": s.asChild,\n      style: { pointerEvents: \"none\" }\n    }, {\n      default: y(() => {\n        var i;\n        return [\n          o(As)((i = o(n).modelValue) == null ? void 0 : i.value) ? (b(), ve(_e, { key: 0 }, [\n            ye(De(s.placeholder), 1)\n          ], 64)) : w(s.$slots, \"default\", { key: 1 })\n        ];\n      }),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), ng = /* @__PURE__ */ x({\n  __name: \"SelectIcon\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    return (t, e) => (b(), S(o(O), {\n      \"aria-hidden\": \"true\",\n      as: t.as,\n      \"as-child\": t.asChild\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\", {}, () => [\n          ye(\"â–¼\")\n        ])\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\"]));\n  }\n}), Ms = /* @__PURE__ */ x({\n  __name: \"BaseSeparator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = [\"horizontal\", \"vertical\"];\n    function n(i) {\n      return e.includes(i);\n    }\n    const l = B(\n      () => n(t.orientation) ? t.orientation : \"horizontal\"\n    ), s = B(\n      () => l.value === \"vertical\" ? t.orientation : void 0\n    ), r = B(\n      () => t.decorative ? { role: \"none\" } : { \"aria-orientation\": s.value, role: \"separator\" }\n    );\n    return (i, u) => (b(), S(o(O), k({\n      as: i.as,\n      \"as-child\": i.asChild,\n      \"data-orientation\": l.value\n    }, r.value), {\n      default: y(() => [\n        w(i.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"as\", \"as-child\", \"data-orientation\"]));\n  }\n}), ap = /* @__PURE__ */ x({\n  __name: \"Separator\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(Ms, W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction np(a = [], t, e) {\n  const n = [...a];\n  return n[e] = t, n.sort((l, s) => l - s);\n}\nfunction Vs(a, t, e) {\n  const s = 100 / (e - t) * (a - t);\n  return Ut(s, 0, 100);\n}\nfunction op(a, t) {\n  return t > 2 ? `Value ${a + 1} of ${t}` : t === 2 ? [\"Minimum\", \"Maximum\"][a] : void 0;\n}\nfunction lp(a, t) {\n  if (a.length === 1)\n    return 0;\n  const e = a.map((l) => Math.abs(l - t)), n = Math.min(...e);\n  return e.indexOf(n);\n}\nfunction sp(a, t, e) {\n  const n = a / 2, s = To([0, 50], [0, n]);\n  return (n - s(t) * e) * e;\n}\nfunction rp(a) {\n  return a.slice(0, -1).map((t, e) => a[e + 1] - t);\n}\nfunction ip(a, t) {\n  if (t > 0) {\n    const e = rp(a);\n    return Math.min(...e) >= t;\n  }\n  return !0;\n}\nfunction To(a, t) {\n  return (e) => {\n    if (a[0] === a[1] || t[0] === t[1])\n      return t[0];\n    const n = (t[1] - t[0]) / (a[1] - a[0]);\n    return t[0] + n * (e - a[0]);\n  };\n}\nfunction up(a) {\n  return (String(a).split(\".\")[1] || \"\").length;\n}\nfunction dp(a, t) {\n  const e = 10 ** t;\n  return Math.round(a * e) / e;\n}\nconst Fs = [\"PageUp\", \"PageDown\"], Ns = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"], Ls = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n}, [zs, Ks] = te([\"SliderVertical\", \"SliderHorizontal\"]), Hs = /* @__PURE__ */ x({\n  __name: \"SliderImpl\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  emits: [\"slideStart\", \"slideMove\", \"slideEnd\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = un();\n    return (s, r) => (b(), S(o(O), k({ \"data-slider-impl\": \"\" }, e, {\n      onKeydown: r[0] || (r[0] = (i) => {\n        i.key === \"Home\" ? (n(\"homeKeyDown\", i), i.preventDefault()) : i.key === \"End\" ? (n(\"endKeyDown\", i), i.preventDefault()) : o(Fs).concat(o(Ns)).includes(i.key) && (n(\"stepKeyDown\", i), i.preventDefault());\n      }),\n      onPointerdown: r[1] || (r[1] = (i) => {\n        const u = i.target;\n        u.setPointerCapture(i.pointerId), i.preventDefault(), o(l).thumbElements.value.includes(u) ? u.focus() : n(\"slideStart\", i);\n      }),\n      onPointermove: r[2] || (r[2] = (i) => {\n        i.target.hasPointerCapture(i.pointerId) && n(\"slideMove\", i);\n      }),\n      onPointerup: r[3] || (r[3] = (i) => {\n        const u = i.target;\n        u.hasPointerCapture(i.pointerId) && (u.releasePointerCapture(i.pointerId), n(\"slideEnd\", i));\n      })\n    }), {\n      default: y(() => [\n        w(s.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), cp = /* @__PURE__ */ x({\n  __name: \"SliderHorizontal\",\n  props: {\n    dir: {},\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { max: l, min: s, dir: r, inverted: i } = ae(e), { forwardRef: u, currentElement: d } = R(), c = T(), f = B(() => (r == null ? void 0 : r.value) === \"ltr\" && !i.value || (r == null ? void 0 : r.value) !== \"ltr\" && i.value);\n    function v(p) {\n      const g = c.value || d.value.getBoundingClientRect(), m = [0, g.width], _ = f.value ? [s.value, l.value] : [l.value, s.value], C = To(m, _);\n      return c.value = g, C(p - g.left);\n    }\n    return Ks({\n      startEdge: f.value ? \"left\" : \"right\",\n      endEdge: f.value ? \"right\" : \"left\",\n      direction: f.value ? 1 : -1,\n      size: \"width\"\n    }), (p, g) => (b(), S(Hs, {\n      ref: o(u),\n      dir: o(r),\n      \"data-orientation\": \"horizontal\",\n      style: {\n        \"--radix-slider-thumb-transform\": \"translateX(-50%)\"\n      },\n      onSlideStart: g[0] || (g[0] = (m) => {\n        const _ = v(m.clientX);\n        n(\"slideStart\", _);\n      }),\n      onSlideMove: g[1] || (g[1] = (m) => {\n        const _ = v(m.clientX);\n        n(\"slideMove\", _);\n      }),\n      onSlideEnd: g[2] || (g[2] = () => {\n        c.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: g[3] || (g[3] = (m) => {\n        const _ = f.value ? \"from-left\" : \"from-right\", C = o(Ls)[_].includes(m.key);\n        n(\"stepKeyDown\", m, C ? -1 : 1);\n      }),\n      onEndKeyDown: g[4] || (g[4] = (m) => n(\"endKeyDown\", m)),\n      onHomeKeyDown: g[5] || (g[5] = (m) => n(\"homeKeyDown\", m))\n    }, {\n      default: y(() => [\n        w(p.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"dir\"]));\n  }\n}), fp = /* @__PURE__ */ x({\n  __name: \"SliderVertical\",\n  props: {\n    min: {},\n    max: {},\n    inverted: { type: Boolean }\n  },\n  emits: [\"slideEnd\", \"slideStart\", \"slideMove\", \"homeKeyDown\", \"endKeyDown\", \"stepKeyDown\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { max: l, min: s, inverted: r } = ae(e), { forwardRef: i, currentElement: u } = R(), d = T(), c = B(() => !r.value);\n    function f(v) {\n      const p = d.value || u.value.getBoundingClientRect(), g = [0, p.height], m = c.value ? [l.value, s.value] : [s.value, l.value], _ = To(g, m);\n      return d.value = p, _(v - p.top);\n    }\n    return Ks({\n      startEdge: c.value ? \"bottom\" : \"top\",\n      endEdge: c.value ? \"top\" : \"bottom\",\n      size: \"height\",\n      direction: c.value ? 1 : -1\n    }), (v, p) => (b(), S(Hs, {\n      ref: o(i),\n      \"data-orientation\": \"vertical\",\n      style: {\n        \"--radix-slider-thumb-transform\": \"translateY(50%)\"\n      },\n      onSlideStart: p[0] || (p[0] = (g) => {\n        const m = f(g.clientY);\n        n(\"slideStart\", m);\n      }),\n      onSlideMove: p[1] || (p[1] = (g) => {\n        const m = f(g.clientY);\n        n(\"slideMove\", m);\n      }),\n      onSlideEnd: p[2] || (p[2] = () => {\n        d.value = void 0, n(\"slideEnd\");\n      }),\n      onStepKeyDown: p[3] || (p[3] = (g) => {\n        const m = c.value ? \"from-bottom\" : \"from-top\", _ = o(Ls)[m].includes(g.key);\n        n(\"stepKeyDown\", g, _ ? -1 : 1);\n      }),\n      onEndKeyDown: p[4] || (p[4] = (g) => n(\"endKeyDown\", g)),\n      onHomeKeyDown: p[5] || (p[5] = (g) => n(\"homeKeyDown\", g))\n    }, {\n      default: y(() => [\n        w(v.$slots, \"default\")\n      ]),\n      _: 3\n    }, 512));\n  }\n}), pp = [\"value\", \"name\", \"disabled\", \"step\"], [un, vp] = te(\"SliderRoot\"), og = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SliderRoot\",\n  props: {\n    name: {},\n    defaultValue: { default: () => [0] },\n    modelValue: {},\n    disabled: { type: Boolean, default: !1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    inverted: { type: Boolean, default: !1 },\n    min: { default: 0 },\n    max: { default: 100 },\n    step: { default: 1 },\n    minStepsBetweenThumbs: { default: 0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"valueCommit\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { min: l, max: s, step: r, minStepsBetweenThumbs: i, orientation: u, disabled: d, dir: c } = ae(e), f = we(c), { forwardRef: v, currentElement: p } = R(), g = at(p);\n    Ca();\n    const m = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), _ = T(0), C = T(m.value);\n    function $(I) {\n      const M = lp(m.value, I);\n      P(I, M);\n    }\n    function h(I) {\n      P(I, _.value);\n    }\n    function E() {\n      const I = C.value[_.value];\n      m.value[_.value] !== I && n(\"valueCommit\", Pr(m.value));\n    }\n    function P(I, M, { commit: V } = { commit: !1 }) {\n      var Q;\n      const A = up(r.value), F = dp(Math.round((I - l.value) / r.value) * r.value + l.value, A), j = Ut(F, l.value, s.value), H = np(m.value, j, M);\n      if (ip(H, i.value * r.value)) {\n        _.value = H.indexOf(j);\n        const G = String(H) !== String(m.value);\n        G && V && n(\"valueCommit\", H), G && ((Q = D.value[_.value]) == null || Q.focus(), m.value = H);\n      }\n    }\n    const D = T([]);\n    return vp({\n      modelValue: m,\n      valueIndexToChangeRef: _,\n      thumbElements: D,\n      orientation: u,\n      min: l,\n      max: s,\n      disabled: d\n    }), (I, M) => (b(), ve(_e, null, [\n      q(o(wa), null, {\n        default: y(() => [\n          (b(), S(Xe(o(u) === \"horizontal\" ? cp : fp), k(I.$attrs, {\n            ref: o(v),\n            \"as-child\": I.asChild,\n            as: I.as,\n            min: o(l),\n            max: o(s),\n            dir: o(f),\n            inverted: I.inverted,\n            \"aria-disabled\": o(d),\n            \"data-disabled\": o(d) ? \"\" : void 0,\n            onPointerdown: M[0] || (M[0] = () => {\n              o(d) || (C.value = o(m));\n            }),\n            onSlideStart: M[1] || (M[1] = (V) => !o(d) && $(V)),\n            onSlideMove: M[2] || (M[2] = (V) => !o(d) && h(V)),\n            onSlideEnd: M[3] || (M[3] = (V) => !o(d) && E()),\n            onHomeKeyDown: M[4] || (M[4] = (V) => !o(d) && P(o(l), 0, { commit: !0 })),\n            onEndKeyDown: M[5] || (M[5] = (V) => !o(d) && P(o(s), o(m).length - 1, { commit: !0 })),\n            onStepKeyDown: M[6] || (M[6] = (V, A) => {\n              if (!o(d)) {\n                const H = o(Fs).includes(V.key) || V.shiftKey && o(Ns).includes(V.key) ? 10 : 1, Q = _.value, G = o(m)[Q], J = o(r) * H * A;\n                P(G + J, Q, { commit: !0 });\n              }\n            })\n          }), {\n            default: y(() => [\n              w(I.$slots, \"default\", { modelValue: o(m) })\n            ]),\n            _: 3\n          }, 16, [\"as-child\", \"as\", \"min\", \"max\", \"dir\", \"inverted\", \"aria-disabled\", \"data-disabled\"]))\n        ]),\n        _: 3\n      }),\n      o(g) ? (b(!0), ve(_e, { key: 0 }, ma(o(m), (V, A) => (b(), ve(\"input\", {\n        key: A,\n        value: V,\n        type: \"number\",\n        style: { display: \"none\" },\n        name: I.name ? I.name + (o(m).length > 1 ? \"[]\" : \"\") : void 0,\n        disabled: o(d),\n        step: o(r)\n      }, null, 8, pp))), 128)) : ce(\"\", !0)\n    ], 64));\n  }\n}), mp = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"SliderThumbImpl\",\n  props: {\n    index: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = un(), n = zs(), { forwardRef: l, currentElement: s } = R(), r = B(() => {\n      var p, g;\n      return (g = (p = e.modelValue) == null ? void 0 : p.value) == null ? void 0 : g[t.index];\n    }), i = B(() => r.value === void 0 ? 0 : Vs(r.value, e.min.value ?? 0, e.max.value ?? 100)), u = B(() => {\n      var p, g;\n      return op(t.index, ((g = (p = e.modelValue) == null ? void 0 : p.value) == null ? void 0 : g.length) ?? 0);\n    }), d = Ll(s), c = B(() => d[n.size].value), f = B(() => c.value ? sp(c.value, i.value, n.direction) : 0), v = Ga();\n    return le(() => {\n      e.thumbElements.value.push(s.value);\n    }), Be(() => {\n      const p = e.thumbElements.value.findIndex((g) => g === s.value) ?? -1;\n      e.thumbElements.value.splice(p, 1);\n    }), (p, g) => (b(), S(o(Qt), null, {\n      default: y(() => [\n        q(o(O), k(p.$attrs, {\n          ref: o(l),\n          role: \"slider\",\n          \"data-radix-vue-collection-item\": \"\",\n          tabindex: o(e).disabled.value ? void 0 : 0,\n          \"aria-label\": p.$attrs[\"aria-label\"] || u.value,\n          \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n          \"data-orientation\": o(e).orientation.value,\n          \"aria-valuenow\": r.value,\n          \"aria-valuemin\": o(e).min.value,\n          \"aria-valuemax\": o(e).max.value,\n          \"aria-orientation\": o(e).orientation.value,\n          \"as-child\": p.asChild,\n          as: p.as,\n          style: {\n            transform: \"var(--radix-slider-thumb-transform)\",\n            position: \"absolute\",\n            [o(n).startEdge]: `calc(${i.value}% + ${f.value}px)`,\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            display: !o(v) && r.value === void 0 ? \"none\" : void 0\n          },\n          onFocus: g[0] || (g[0] = () => {\n            o(e).valueIndexToChangeRef.value = p.index;\n          })\n        }), {\n          default: y(() => [\n            w(p.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"tabindex\", \"aria-label\", \"data-disabled\", \"data-orientation\", \"aria-valuenow\", \"aria-valuemin\", \"aria-valuemax\", \"aria-orientation\", \"as-child\", \"as\", \"style\"])\n      ]),\n      _: 3\n    }));\n  }\n}), lg = /* @__PURE__ */ x({\n  __name: \"SliderThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { getItems: e } = ea(), { forwardRef: n, currentElement: l } = R(), s = B(() => l.value ? e().findIndex((r) => r.ref === l.value) : -1);\n    return (r, i) => (b(), S(mp, k({ ref: o(n) }, t, { index: s.value }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"index\"]));\n  }\n}), sg = /* @__PURE__ */ x({\n  __name: \"SliderTrack\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = un();\n    return R(), (e, n) => (b(), S(o(O), {\n      \"as-child\": e.asChild,\n      as: e.as,\n      \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value\n    }, {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as-child\", \"as\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), rg = /* @__PURE__ */ x({\n  __name: \"SliderRange\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = un(), e = zs();\n    R();\n    const n = B(() => {\n      var r, i;\n      return (i = (r = t.modelValue) == null ? void 0 : r.value) == null ? void 0 : i.map(\n        (u) => Vs(u, t.min.value, t.max.value)\n      );\n    }), l = B(() => t.modelValue.value.length > 1 ? Math.min(...n.value) : 0), s = B(() => 100 - Math.max(...n.value));\n    return (r, i) => (b(), S(o(O), {\n      \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value,\n      \"as-child\": r.asChild,\n      as: r.as,\n      style: Me({\n        [o(e).startEdge]: `${l.value}%`,\n        [o(e).endEdge]: `${s.value}%`\n      })\n    }, {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"data-disabled\", \"data-orientation\", \"as-child\", \"as\", \"style\"]));\n  }\n});\nlet kn = null, $t = null;\nfunction hp(a, t) {\n  if (t) {\n    const e = (t & Xs) !== 0, n = (t & Zs) !== 0, l = (t & Js) !== 0, s = (t & Qs) !== 0;\n    if (e)\n      return l ? \"se-resize\" : s ? \"ne-resize\" : \"e-resize\";\n    if (n)\n      return l ? \"sw-resize\" : s ? \"nw-resize\" : \"w-resize\";\n    if (l)\n      return \"s-resize\";\n    if (s)\n      return \"n-resize\";\n  }\n  switch (a) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction Ws() {\n  $t !== null && (document.head.removeChild($t), kn = null, $t = null);\n}\nfunction Pn(a, t) {\n  const e = hp(a, t);\n  kn !== e && (kn = e, $t === null && ($t = document.createElement(\"style\"), document.head.appendChild($t)), $t.innerHTML = `*{cursor: ${e}!important;}`);\n}\nfunction yp({\n  defaultSize: a,\n  dragState: t,\n  layout: e,\n  panelData: n,\n  panelIndex: l,\n  precision: s = 3\n}) {\n  const r = e[l];\n  let i;\n  return r == null ? i = a !== void 0 ? a.toPrecision(s) : \"1\" : n.length === 1 ? i = \"1\" : i = r.toPrecision(s), {\n    flexBasis: 0,\n    flexGrow: i,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: t !== null ? \"none\" : void 0\n  };\n}\nfunction js(a) {\n  return a.type === \"keydown\";\n}\nfunction Us(a) {\n  return a.type.startsWith(\"mouse\");\n}\nfunction Gs(a) {\n  return a.type.startsWith(\"touch\");\n}\nfunction dn(a) {\n  if (Us(a))\n    return {\n      x: a.clientX,\n      y: a.clientY\n    };\n  if (Gs(a)) {\n    const t = a.touches[0];\n    if (t && t.clientX && t.clientY)\n      return {\n        x: t.clientX,\n        y: t.clientY\n      };\n  }\n  return {\n    x: Number.POSITIVE_INFINITY,\n    y: Number.POSITIVE_INFINITY\n  };\n}\nfunction qs(a, t) {\n  const e = a === \"horizontal\", { x: n, y: l } = dn(t);\n  return e ? n : l;\n}\nfunction gp(a, t, e) {\n  return a.x < t.x + t.width && a.x + a.width > t.x && a.y < t.y + t.height && a.y + a.height > t.y;\n}\nfunction pe(a, t = \"Assertion failed!\") {\n  if (!a)\n    throw console.error(t), new Error(t);\n}\nfunction bp(a, t) {\n  if (a === t)\n    throw new Error(\"Cannot compare node with itself\");\n  const e = {\n    a: ll(a),\n    b: ll(t)\n  };\n  let n;\n  for (; e.a.at(-1) === e.b.at(-1); )\n    a = e.a.pop(), t = e.b.pop(), n = a;\n  pe(n);\n  const l = {\n    a: ol(nl(e.a)),\n    b: ol(nl(e.b))\n  };\n  if (l.a === l.b) {\n    const s = n.childNodes, r = {\n      a: e.a.at(-1),\n      b: e.b.at(-1)\n    };\n    let i = s.length;\n    for (; i--; ) {\n      const u = s[i];\n      if (u === r.a)\n        return 1;\n      if (u === r.b)\n        return -1;\n    }\n  }\n  return Math.sign(l.a - l.b);\n}\nconst Cp = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\nfunction wp(a) {\n  const t = getComputedStyle(Ys(a)).display;\n  return t === \"flex\" || t === \"inline-flex\";\n}\nfunction _p(a) {\n  const t = getComputedStyle(a);\n  return !!(t.position === \"fixed\" || t.zIndex !== \"auto\" && (t.position !== \"static\" || wp(a)) || +t.opacity < 1 || \"transform\" in t && t.transform !== \"none\" || \"webkitTransform\" in t && t.webkitTransform !== \"none\" || \"mixBlendMode\" in t && t.mixBlendMode !== \"normal\" || \"filter\" in t && t.filter !== \"none\" || \"webkitFilter\" in t && t.webkitFilter !== \"none\" || \"isolation\" in t && t.isolation === \"isolate\" || Cp.test(t.willChange) || t.webkitOverflowScrolling === \"touch\");\n}\nfunction nl(a) {\n  let t = a.length;\n  for (; t--; ) {\n    const e = a[t];\n    if (pe(e), _p(e))\n      return e;\n  }\n  return null;\n}\nfunction ol(a) {\n  return a && Number(getComputedStyle(a).zIndex) || 0;\n}\nfunction ll(a) {\n  const t = [];\n  for (; a; )\n    t.push(a), a = Ys(a);\n  return t;\n}\nfunction Ys(a) {\n  var t;\n  return a.parentNode instanceof DocumentFragment && ((t = a.parentNode) == null ? void 0 : t.host) || a.parentNode;\n}\nconst Xs = 1, Zs = 2, Js = 4, Qs = 8;\nfunction xp() {\n  if (typeof matchMedia == \"function\")\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n}\nconst Sp = xp() === \"coarse\", yt = [];\nlet cn = !1;\nconst vt = /* @__PURE__ */ new Map(), fn = /* @__PURE__ */ new Map(), fa = /* @__PURE__ */ new Set();\nfunction Ep(a, t, e, n, l) {\n  const { ownerDocument: s } = t, r = {\n    direction: e,\n    element: t,\n    hitAreaMargins: n,\n    setResizeHandlerState: l\n  }, i = vt.get(s) ?? 0;\n  return vt.set(s, i + 1), fa.add(r), Ha(), function() {\n    fn.delete(a), fa.delete(r);\n    const d = vt.get(s) ?? 1;\n    vt.set(s, d - 1), Ha(), Ws(), d === 1 && vt.delete(s);\n  };\n}\nfunction Aa(a) {\n  const { target: t } = a, { x: e, y: n } = dn(a);\n  cn = !0, Ro({ target: t, x: e, y: n }), Ha(), yt.length > 0 && (Ao(\"down\", a), a.preventDefault());\n}\nfunction ct(a) {\n  const { x: t, y: e } = dn(a);\n  if (!cn) {\n    const { target: n } = a;\n    Ro({ target: n, x: t, y: e });\n  }\n  Ao(\"move\", a), er(), yt.length > 0 && a.preventDefault();\n}\nfunction ft(a) {\n  const { target: t } = a, { x: e, y: n } = dn(a);\n  fn.clear(), cn = !1, yt.length > 0 && a.preventDefault(), Ao(\"up\", a), Ro({ target: t, x: e, y: n }), er(), Ha();\n}\nfunction Ro({\n  target: a,\n  x: t,\n  y: e\n}) {\n  yt.splice(0);\n  let n = null;\n  a instanceof HTMLElement && (n = a), fa.forEach((l) => {\n    const { element: s, hitAreaMargins: r } = l, i = s.getBoundingClientRect(), { bottom: u, left: d, right: c, top: f } = i, v = Sp ? r.coarse : r.fine;\n    if (t >= d - v && t <= c + v && e >= f - v && e <= u + v) {\n      if (n !== null && s !== n && !s.contains(n) && !n.contains(s) && bp(n, s) > 0) {\n        let g = n, m = !1;\n        for (; g && !g.contains(s); ) {\n          if (gp(\n            g.getBoundingClientRect(),\n            i\n          )) {\n            m = !0;\n            break;\n          }\n          g = g.parentElement;\n        }\n        if (m)\n          return;\n      }\n      yt.push(l);\n    }\n  });\n}\nfunction Dn(a, t) {\n  fn.set(a, t);\n}\nfunction er() {\n  let a = !1, t = !1;\n  yt.forEach((n) => {\n    const { direction: l } = n;\n    l.value === \"horizontal\" ? a = !0 : t = !0;\n  });\n  let e = 0;\n  fn.forEach((n) => {\n    e |= n;\n  }), a && t ? Pn(\"intersection\", e) : a ? Pn(\"horizontal\", e) : t ? Pn(\"vertical\", e) : Ws();\n}\nfunction Ha() {\n  vt.forEach((a, t) => {\n    const { body: e } = t;\n    e.removeEventListener(\"contextmenu\", ft), e.removeEventListener(\"mousedown\", Aa), e.removeEventListener(\"mouseleave\", ct), e.removeEventListener(\"mousemove\", ct), e.removeEventListener(\"touchmove\", ct), e.removeEventListener(\"touchstart\", Aa);\n  }), window.removeEventListener(\"mouseup\", ft), window.removeEventListener(\"touchcancel\", ft), window.removeEventListener(\"touchend\", ft), fa.size > 0 && (cn ? (yt.length > 0 && vt.forEach((a, t) => {\n    const { body: e } = t;\n    a > 0 && (e.addEventListener(\"contextmenu\", ft), e.addEventListener(\"mouseleave\", ct), e.addEventListener(\"mousemove\", ct), e.addEventListener(\"touchmove\", ct, {\n      passive: !1\n    }));\n  }), window.addEventListener(\"mouseup\", ft), window.addEventListener(\"touchcancel\", ft), window.addEventListener(\"touchend\", ft)) : vt.forEach((a, t) => {\n    const { body: e } = t;\n    a > 0 && (e.addEventListener(\"mousedown\", Aa), e.addEventListener(\"mousemove\", ct), e.addEventListener(\"touchmove\", ct, {\n      passive: !1\n    }), e.addEventListener(\"touchstart\", Aa));\n  }));\n}\nfunction Ao(a, t) {\n  fa.forEach((e) => {\n    const { setResizeHandlerState: n } = e, l = yt.includes(e);\n    n(a, l, t);\n  });\n}\nconst Oo = 10;\nfunction pa(a, t, e = Oo) {\n  a = Number.parseFloat(a.toFixed(e)), t = Number.parseFloat(t.toFixed(e));\n  const n = a - t;\n  return n === 0 ? 0 : n > 0 ? 1 : -1;\n}\nfunction Le(a, t, e) {\n  return pa(a, t, e) === 0;\n}\nfunction Wt({\n  panelConstraints: a,\n  panelIndex: t,\n  size: e\n}) {\n  const n = a[t];\n  pe(n != null);\n  const { collapsedSize: l = 0, collapsible: s, maxSize: r = 100, minSize: i = 0 } = n;\n  if (pa(e, i) < 0)\n    if (s) {\n      const u = (l + i) / 2;\n      pa(e, u) < 0 ? e = l : e = i;\n    } else\n      e = i;\n  return e = Math.min(r, e), e = Number.parseFloat(e.toFixed(Oo)), e;\n}\nfunction Oa(a, t) {\n  if (a.length !== t.length)\n    return !1;\n  for (let e = 0; e < a.length; e++)\n    if (a[e] !== t[e])\n      return !1;\n  return !0;\n}\nfunction sa({\n  delta: a,\n  layout: t,\n  panelConstraints: e,\n  pivotIndices: n,\n  trigger: l\n}) {\n  if (Le(a, 0))\n    return t;\n  const s = [...t], [r, i] = n;\n  pe(r != null), pe(i != null);\n  let u = 0;\n  if (l === \"keyboard\") {\n    {\n      const c = a < 0 ? i : r, f = e[c];\n      if (pe(f), f.collapsible) {\n        const v = t[c];\n        pe(v != null);\n        const p = e[c];\n        pe(p);\n        const { collapsedSize: g = 0, minSize: m = 0 } = p;\n        if (Le(v, g)) {\n          const _ = m - v;\n          pa(_, Math.abs(a)) > 0 && (a = a < 0 ? 0 - _ : _);\n        }\n      }\n    }\n    {\n      const c = a < 0 ? r : i, f = e[c];\n      pe(f);\n      const { collapsible: v } = f;\n      if (v) {\n        const p = t[c];\n        pe(p != null);\n        const g = e[c];\n        pe(g);\n        const { collapsedSize: m = 0, minSize: _ = 0 } = g;\n        if (Le(p, _)) {\n          const C = p - m;\n          pa(C, Math.abs(a)) > 0 && (a = a < 0 ? 0 - C : C);\n        }\n      }\n    }\n  }\n  {\n    const c = a < 0 ? 1 : -1;\n    let f = a < 0 ? i : r, v = 0;\n    for (; ; ) {\n      const g = t[f];\n      pe(g != null);\n      const _ = Wt({\n        panelConstraints: e,\n        panelIndex: f,\n        size: 100\n      }) - g;\n      if (v += _, f += c, f < 0 || f >= e.length)\n        break;\n    }\n    const p = Math.min(Math.abs(a), Math.abs(v));\n    a = a < 0 ? 0 - p : p;\n  }\n  {\n    let f = a < 0 ? r : i;\n    for (; f >= 0 && f < e.length; ) {\n      const v = Math.abs(a) - Math.abs(u), p = t[f];\n      pe(p != null);\n      const g = p - v, m = Wt({\n        panelConstraints: e,\n        panelIndex: f,\n        size: g\n      });\n      if (!Le(p, m) && (u += p - m, s[f] = m, u.toPrecision(3).localeCompare(Math.abs(a).toPrecision(3), void 0, {\n        numeric: !0\n      }) >= 0))\n        break;\n      a < 0 ? f-- : f++;\n    }\n  }\n  if (Le(u, 0))\n    return t;\n  {\n    const c = a < 0 ? i : r, f = t[c];\n    pe(f != null);\n    const v = f + u, p = Wt({\n      panelConstraints: e,\n      panelIndex: c,\n      size: v\n    });\n    if (s[c] = p, !Le(p, v)) {\n      let g = v - p, _ = a < 0 ? i : r;\n      for (; _ >= 0 && _ < e.length; ) {\n        const C = s[_];\n        pe(C != null);\n        const $ = C + g, h = Wt({\n          panelConstraints: e,\n          panelIndex: _,\n          size: $\n        });\n        if (Le(C, h) || (g -= h - C, s[_] = h), Le(g, 0))\n          break;\n        a > 0 ? _-- : _++;\n      }\n    }\n  }\n  const d = s.reduce((c, f) => f + c, 0);\n  return Le(d, 100) ? s : t;\n}\nfunction tr(a, t = document) {\n  var n;\n  if (!ha)\n    return null;\n  if (t instanceof HTMLElement && ((n = t == null ? void 0 : t.dataset) == null ? void 0 : n.panelGroupId) === a)\n    return t;\n  const e = t.querySelector(\n    `[data-panel-group][data-panel-group-id=\"${a}\"]`\n  );\n  return e || null;\n}\nfunction pn(a, t = document) {\n  if (!ha)\n    return null;\n  const e = t.querySelector(`[data-panel-resize-handle-id=\"${a}\"]`);\n  return e || null;\n}\nfunction ar(a, t, e = document) {\n  return ha ? va(a, e).findIndex(\n    (s) => s.getAttribute(\"data-panel-resize-handle-id\") === t\n  ) ?? null : null;\n}\nfunction va(a, t = document) {\n  return ha ? Array.from(\n    t.querySelectorAll(\n      `[data-panel-resize-handle-id][data-panel-group-id=\"${a}\"]`\n    )\n  ) : [];\n}\nfunction Pp(a, t, e, n = document) {\n  var d, c;\n  const l = pn(t, n), s = va(a, n), r = l ? s.indexOf(l) : -1, i = ((d = e[r]) == null ? void 0 : d.id) ?? null, u = ((c = e[r + 1]) == null ? void 0 : c.id) ?? null;\n  return [i, u];\n}\nfunction Dp(a, t, e, n, l) {\n  const s = e === \"horizontal\", r = pn(t, l);\n  pe(r);\n  const i = r.getAttribute(\"data-panel-group-id\");\n  pe(i);\n  const { initialCursorPosition: u } = n, d = qs(e, a), c = tr(i, l);\n  pe(c);\n  const f = c.getBoundingClientRect(), v = s ? f.width : f.height;\n  return (d - u) / v * 100;\n}\nfunction $p(a, t, e, n, l, s) {\n  if (js(a)) {\n    const r = e === \"horizontal\";\n    let i = 0;\n    a.shiftKey ? i = 100 : i = l ?? 10;\n    let u = 0;\n    switch (a.key) {\n      case \"ArrowDown\":\n        u = r ? 0 : i;\n        break;\n      case \"ArrowLeft\":\n        u = r ? -i : 0;\n        break;\n      case \"ArrowRight\":\n        u = r ? i : 0;\n        break;\n      case \"ArrowUp\":\n        u = r ? 0 : -i;\n        break;\n      case \"End\":\n        u = 100;\n        break;\n      case \"Home\":\n        u = -100;\n        break;\n    }\n    return u;\n  } else\n    return n == null ? 0 : Dp(\n      a,\n      t,\n      e,\n      n,\n      s\n    );\n}\nfunction Bp({\n  layout: a,\n  panelsArray: t,\n  pivotIndices: e\n}) {\n  let n = 0, l = 100, s = 0, r = 0;\n  const i = e[0];\n  pe(i != null), t.forEach((f, v) => {\n    const { constraints: p } = f, { maxSize: g = 100, minSize: m = 0 } = p;\n    v === i ? (n = m, l = g) : (s += m, r += g);\n  });\n  const u = Math.min(l, 100 - s), d = Math.max(n, 100 - r), c = a[i];\n  return {\n    valueMax: u,\n    valueMin: d,\n    valueNow: c\n  };\n}\nfunction Ip({\n  panelDataArray: a\n}) {\n  const t = Array(a.length), e = a.map(\n    (s) => s.constraints\n  );\n  let n = 0, l = 100;\n  for (let s = 0; s < a.length; s++) {\n    const r = e[s];\n    pe(r);\n    const { defaultSize: i } = r;\n    i != null && (n++, t[s] = i, l -= i);\n  }\n  for (let s = 0; s < a.length; s++) {\n    const r = e[s];\n    pe(r);\n    const { defaultSize: i } = r;\n    if (i != null)\n      continue;\n    const u = a.length - n, d = l / u;\n    n++, t[s] = d, l -= d;\n  }\n  return t;\n}\nfunction la(a, t, e) {\n  t.forEach((n, l) => {\n    const s = a[l];\n    pe(s);\n    const { callbacks: r, constraints: i, id: u } = s, { collapsedSize: d = 0, collapsible: c } = i, f = e[u];\n    if (f == null || n !== f) {\n      e[u] = n;\n      const { onCollapse: v, onExpand: p, onResize: g } = r;\n      g && g(n, f), c && (v || p) && (p && (f == null || f === d) && n !== d && p(), v && (f == null || f !== d) && n === d && v());\n    }\n  });\n}\nfunction Tp(a, t = 10) {\n  let e = null;\n  return (...l) => {\n    e !== null && clearTimeout(e), e = setTimeout(() => {\n      a(...l);\n    }, t);\n  };\n}\nfunction nr(a, t, e) {\n  const n = ar(\n    a,\n    t,\n    e\n  );\n  return n != null ? [n, n + 1] : [-1, -1];\n}\nfunction Rp({\n  layout: a,\n  panelConstraints: t\n}) {\n  const e = [...a], n = e.reduce(\n    (s, r) => s + r,\n    0\n  );\n  if (e.length !== t.length)\n    throw new Error(\n      `Invalid ${t.length} panel layout: ${e.map((s) => `${s}%`).join(\", \")}`\n    );\n  if (!Le(n, 100)) {\n    console.warn(\n      `WARNING: Invalid layout total size: ${e.map((s) => `${s}%`).join(\", \")}. Layout normalization will be applied.`\n    );\n    for (let s = 0; s < t.length; s++) {\n      const r = e[s];\n      pe(r != null);\n      const i = 100 / n * r;\n      e[s] = i;\n    }\n  }\n  let l = 0;\n  for (let s = 0; s < t.length; s++) {\n    const r = e[s];\n    pe(r != null);\n    const i = Wt({\n      panelConstraints: t,\n      panelIndex: s,\n      size: r\n    });\n    r !== i && (l += r - i, e[s] = i);\n  }\n  if (!Le(l, 0))\n    for (let s = 0; s < t.length; s++) {\n      const r = e[s];\n      pe(r != null);\n      const i = r + l, u = Wt({\n        panelConstraints: t,\n        panelIndex: s,\n        size: i\n      });\n      if (r !== u && (l -= u - r, e[s] = u, Le(l, 0)))\n        break;\n    }\n  return e;\n}\nfunction sl(a) {\n  try {\n    if (typeof localStorage < \"u\")\n      a.getItem = (t) => localStorage.getItem(t), a.setItem = (t, e) => {\n        localStorage.setItem(t, e);\n      };\n    else\n      throw new TypeError(\"localStorage not supported in this environment\");\n  } catch (t) {\n    console.error(t), a.getItem = () => null, a.setItem = () => {\n    };\n  }\n}\nfunction or(a) {\n  return `radix-vue:${a}`;\n}\nfunction lr(a) {\n  return a.map((t) => {\n    const { constraints: e, id: n, idIsFromProps: l, order: s } = t;\n    return l ? n : s ? `${s}:${JSON.stringify(e)}` : JSON.stringify(e);\n  }).sort((t, e) => t.localeCompare(e)).join(\",\");\n}\nfunction sr(a, t) {\n  try {\n    const e = or(a), n = t.getItem(e);\n    if (n) {\n      const l = JSON.parse(n);\n      if (typeof l == \"object\" && l != null)\n        return l;\n    }\n  } catch {\n  }\n  return null;\n}\nfunction Ap(a, t, e) {\n  const n = sr(a, e) ?? {}, l = lr(t);\n  return n[l] ?? null;\n}\nfunction Op(a, t, e, n, l) {\n  const s = or(a), r = lr(t), i = sr(a, l) ?? {};\n  i[r] = {\n    expandToSizes: Object.fromEntries(e.entries()),\n    layout: n\n  };\n  try {\n    l.setItem(s, JSON.stringify(i));\n  } catch (u) {\n    console.error(u);\n  }\n}\nfunction kp({\n  eagerValuesRef: a,\n  groupId: t,\n  layout: e,\n  panelDataArray: n,\n  panelGroupElement: l,\n  setLayout: s\n}) {\n  Ce((r) => {\n    const i = l.value;\n    if (!i)\n      return;\n    const u = va(\n      t,\n      i\n    );\n    for (let d = 0; d < n.length - 1; d++) {\n      const { valueMax: c, valueMin: f, valueNow: v } = Bp({\n        layout: e.value,\n        panelsArray: n,\n        pivotIndices: [d, d + 1]\n      }), p = u[d];\n      if (p != null) {\n        const g = n[d];\n        pe(g), p.setAttribute(\"aria-controls\", g.id), p.setAttribute(\n          \"aria-valuemax\",\n          `${Math.round(c)}`\n        ), p.setAttribute(\n          \"aria-valuemin\",\n          `${Math.round(f)}`\n        ), p.setAttribute(\n          \"aria-valuenow\",\n          v != null ? `${Math.round(v)}` : \"\"\n        );\n      }\n    }\n    r(() => {\n      u.forEach((d) => {\n        d.removeAttribute(\"aria-controls\"), d.removeAttribute(\"aria-valuemax\"), d.removeAttribute(\"aria-valuemin\"), d.removeAttribute(\"aria-valuenow\");\n      });\n    });\n  }), Ce((r) => {\n    const i = l.value;\n    if (!i)\n      return;\n    const u = a.value;\n    pe(u);\n    const { panelDataArray: d } = u, c = tr(t, i);\n    pe(c != null, `No group found for id \"${t}\"`);\n    const f = va(t, i);\n    pe(f);\n    const v = f.map((p) => {\n      const g = p.getAttribute(\"data-panel-resize-handle-id\");\n      pe(g);\n      const [m, _] = Pp(\n        t,\n        g,\n        d,\n        i\n      );\n      if (m == null || _ == null)\n        return () => {\n        };\n      const C = ($) => {\n        if (!$.defaultPrevented)\n          switch ($.key) {\n            case \"Enter\": {\n              $.preventDefault();\n              const h = d.findIndex(\n                (E) => E.id === m\n              );\n              if (h >= 0) {\n                const E = d[h];\n                pe(E);\n                const P = e.value[h], {\n                  collapsedSize: D = 0,\n                  collapsible: I,\n                  minSize: M = 0\n                } = E.constraints;\n                if (P != null && I) {\n                  const V = sa({\n                    delta: Le(P, D) ? M - D : D - P,\n                    layout: e.value,\n                    panelConstraints: d.map(\n                      (A) => A.constraints\n                    ),\n                    pivotIndices: nr(\n                      t,\n                      g,\n                      i\n                    ),\n                    trigger: \"keyboard\"\n                  });\n                  e.value !== V && s(V);\n                }\n              }\n              break;\n            }\n          }\n      };\n      return p.addEventListener(\"keydown\", C), () => {\n        p.removeEventListener(\"keydown\", C);\n      };\n    });\n    r(() => {\n      v.forEach((p) => p());\n    });\n  });\n}\nconst Mp = 100, ra = {\n  getItem: (a) => (sl(ra), ra.getItem(a)),\n  setItem: (a, t) => {\n    sl(ra), ra.setItem(a, t);\n  }\n}, [rr, Vp] = te(\"PanelGroup\"), ig = /* @__PURE__ */ x({\n  __name: \"SplitterGroup\",\n  props: {\n    id: {},\n    autoSaveId: { default: null },\n    direction: {},\n    keyboardResizeBy: { default: 10 },\n    storage: { default: () => ra },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"layout\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = {}, { direction: s } = ae(e), r = ge(e.id, \"radix-vue-splitter-group\"), i = we(), { forwardRef: u, currentElement: d } = R(), c = T(null), f = T([]), v = T({}), p = T(/* @__PURE__ */ new Map()), g = T(0), m = B(() => ({\n      autoSaveId: e.autoSaveId,\n      direction: e.direction,\n      dragState: c.value,\n      id: r,\n      keyboardResizeBy: e.keyboardResizeBy,\n      storage: e.storage\n    })), _ = T({\n      layout: f.value,\n      panelDataArray: [],\n      panelDataArrayChanged: !1\n    }), C = (z) => f.value = z;\n    kp({\n      eagerValuesRef: _,\n      groupId: r,\n      layout: f,\n      panelDataArray: _.value.panelDataArray,\n      setLayout: C,\n      panelGroupElement: d\n    }), Ce(() => {\n      const { panelDataArray: z } = _.value, { autoSaveId: K } = e;\n      if (K) {\n        if (f.value.length === 0 || f.value.length !== z.length)\n          return;\n        let L = l[K];\n        L || (L = Tp(\n          Op,\n          Mp\n        ), l[K] = L);\n        const N = [...z], Z = new Map(\n          p.value\n        );\n        L(\n          K,\n          N,\n          Z,\n          f.value,\n          e.storage\n        );\n      }\n    });\n    function $(z, K) {\n      const { panelDataArray: L } = _.value, N = G(L, z);\n      return yp({\n        defaultSize: K,\n        dragState: c.value,\n        layout: f.value,\n        panelData: L,\n        panelIndex: N\n      });\n    }\n    function h(z) {\n      const { panelDataArray: K } = _.value;\n      K.push(z), K.sort((L, N) => {\n        const Z = L.order, Y = N.order;\n        return Z == null && Y == null ? 0 : Z == null ? -1 : Y == null ? 1 : Z - Y;\n      }), _.value.panelDataArrayChanged = !0;\n    }\n    ee(() => _.value.panelDataArrayChanged, () => {\n      if (_.value.panelDataArrayChanged) {\n        _.value.panelDataArrayChanged = !1;\n        const { autoSaveId: z, storage: K } = m.value, { layout: L, panelDataArray: N } = _.value;\n        let Z = null;\n        if (z) {\n          const re = Ap(z, N, K);\n          re && (p.value = new Map(\n            Object.entries(re.expandToSizes)\n          ), Z = re.layout);\n        }\n        Z === null && (Z = Ip({\n          panelDataArray: N\n        }));\n        const Y = Rp({\n          layout: Z,\n          panelConstraints: N.map(\n            (re) => re.constraints\n          )\n        });\n        Gr(L, Y) || (C(Y), _.value.layout = Y, n(\"layout\", Y), la(\n          N,\n          Y,\n          v.value\n        ));\n      }\n    });\n    function E(z) {\n      return function(L) {\n        L.preventDefault();\n        const N = d.value;\n        if (!N)\n          return () => null;\n        const { direction: Z, dragState: Y, id: re, keyboardResizeBy: X } = m.value, { layout: se, panelDataArray: fe } = _.value, { initialLayout: xe } = Y ?? {}, Ee = nr(\n          re,\n          z,\n          N\n        );\n        let be = $p(\n          L,\n          z,\n          Z,\n          Y,\n          X,\n          N\n        );\n        if (be === 0)\n          return;\n        const de = Z === \"horizontal\";\n        i.value === \"rtl\" && de && (be = -be);\n        const Ie = fe.map((Et) => Et.constraints), Ae = sa({\n          delta: be,\n          layout: xe ?? se,\n          panelConstraints: Ie,\n          pivotIndices: Ee,\n          trigger: js(L) ? \"keyboard\" : \"mouse-or-touch\"\n        }), We = !Oa(se, Ae);\n        (Us(L) || Gs(L)) && g.value !== be && (g.value = be, We ? Dn(z, 0) : de ? Dn(\n          z,\n          be < 0 ? Xs : Zs\n        ) : Dn(\n          z,\n          be < 0 ? Js : Qs\n        )), We && (C(Ae), _.value.layout = Ae, n(\"layout\", Ae), la(\n          fe,\n          Ae,\n          v.value\n        ));\n      };\n    }\n    function P(z, K) {\n      const { layout: L, panelDataArray: N } = _.value, Z = N.map((xe) => xe.constraints), { panelSize: Y, pivotIndices: re } = J(\n        N,\n        z,\n        L\n      );\n      pe(Y != null);\n      const se = G(N, z) === N.length - 1 ? Y - K : K - Y, fe = sa({\n        delta: se,\n        layout: L,\n        panelConstraints: Z,\n        pivotIndices: re,\n        trigger: \"imperative-api\"\n      });\n      Oa(L, fe) || (C(fe), _.value.layout = fe, n(\"layout\", fe), la(\n        N,\n        fe,\n        v.value\n      ));\n    }\n    function D(z, K) {\n      const { layout: L, panelDataArray: N } = _.value, Z = G(N, z);\n      N[Z] = z, _.value.panelDataArrayChanged = !0;\n      const {\n        collapsedSize: Y = 0,\n        collapsible: re\n      } = K, {\n        collapsedSize: X = 0,\n        collapsible: se,\n        maxSize: fe = 100,\n        minSize: xe = 0\n      } = z.constraints, { panelSize: Ee } = J(\n        N,\n        z,\n        L\n      );\n      Ee !== null && (re && se && Ee === Y ? Y !== X && P(z, X) : Ee < xe ? P(z, xe) : Ee > fe && P(z, fe));\n    }\n    function I(z, K) {\n      const { direction: L } = m.value, { layout: N } = _.value;\n      if (!d.value)\n        return;\n      const Z = pn(\n        z,\n        d.value\n      );\n      pe(Z);\n      const Y = qs(\n        L,\n        K\n      );\n      c.value = {\n        dragHandleId: z,\n        dragHandleRect: Z.getBoundingClientRect(),\n        initialCursorPosition: Y,\n        initialLayout: N\n      };\n    }\n    function M() {\n      c.value = null;\n    }\n    function V(z) {\n      const { panelDataArray: K } = _.value, L = G(K, z);\n      L >= 0 && (K.splice(L, 1), delete v.value[z.id], _.value.panelDataArrayChanged = !0);\n    }\n    function A(z) {\n      const { layout: K, panelDataArray: L } = _.value;\n      if (z.constraints.collapsible) {\n        const N = L.map(\n          (X) => X.constraints\n        ), {\n          collapsedSize: Z = 0,\n          panelSize: Y,\n          pivotIndices: re\n        } = J(L, z, K);\n        if (pe(\n          Y != null,\n          `Panel size not found for panel \"${z.id}\"`\n        ), Y !== Z) {\n          p.value.set(z.id, Y);\n          const se = G(L, z) === L.length - 1 ? Y - Z : Z - Y, fe = sa({\n            delta: se,\n            layout: K,\n            panelConstraints: N,\n            pivotIndices: re,\n            trigger: \"imperative-api\"\n          });\n          Oa(K, fe) || (C(fe), _.value.layout = fe, n(\"layout\", fe), la(\n            L,\n            fe,\n            v.value\n          ));\n        }\n      }\n    }\n    function F(z) {\n      const { layout: K, panelDataArray: L } = _.value;\n      if (z.constraints.collapsible) {\n        const N = L.map(\n          (se) => se.constraints\n        ), {\n          collapsedSize: Z = 0,\n          panelSize: Y,\n          minSize: re = 0,\n          pivotIndices: X\n        } = J(L, z, K);\n        if (Y === Z) {\n          const se = p.value.get(\n            z.id\n          ), fe = se != null && se >= re ? se : re, Ee = G(L, z) === L.length - 1 ? Y - fe : fe - Y, be = sa({\n            delta: Ee,\n            layout: K,\n            panelConstraints: N,\n            pivotIndices: X,\n            trigger: \"imperative-api\"\n          });\n          Oa(K, be) || (C(be), _.value.layout = be, n(\"layout\", be), la(\n            L,\n            be,\n            v.value\n          ));\n        }\n      }\n    }\n    function j(z) {\n      const { layout: K, panelDataArray: L } = _.value, { panelSize: N } = J(L, z, K);\n      return pe(\n        N != null,\n        `Panel size not found for panel \"${z.id}\"`\n      ), N;\n    }\n    function H(z) {\n      const { layout: K, panelDataArray: L } = _.value, {\n        collapsedSize: N = 0,\n        collapsible: Z,\n        panelSize: Y\n      } = J(L, z, K);\n      return Z ? Y === void 0 ? z.constraints.defaultSize === z.constraints.collapsedSize : Y === N : !1;\n    }\n    function Q(z) {\n      const { layout: K, panelDataArray: L } = _.value, {\n        collapsedSize: N = 0,\n        collapsible: Z,\n        panelSize: Y\n      } = J(L, z, K);\n      return pe(\n        Y != null,\n        `Panel size not found for panel \"${z.id}\"`\n      ), !Z || Y > N;\n    }\n    Vp({\n      direction: s,\n      dragState: c.value,\n      groupId: r,\n      reevaluatePanelConstraints: D,\n      registerPanel: h,\n      registerResizeHandle: E,\n      resizePanel: P,\n      startDragging: I,\n      stopDragging: M,\n      unregisterPanel: V,\n      panelGroupElement: d,\n      collapsePanel: A,\n      expandPanel: F,\n      isPanelCollapsed: H,\n      isPanelExpanded: Q,\n      getPanelSize: j,\n      getPanelStyle: $\n    });\n    function G(z, K) {\n      return z.findIndex(\n        (L) => L === K || L.id === K.id\n      );\n    }\n    function J(z, K, L) {\n      const N = G(z, K), Y = N === z.length - 1 ? [N - 1, N] : [N, N + 1], re = L[N];\n      return {\n        ...K.constraints,\n        panelSize: re,\n        pivotIndices: Y\n      };\n    }\n    return (z, K) => (b(), S(o(O), {\n      ref: o(u),\n      as: z.as,\n      \"as-child\": z.asChild,\n      style: Me({\n        display: \"flex\",\n        flexDirection: o(s) === \"horizontal\" ? \"row\" : \"column\",\n        height: \"100%\",\n        overflow: \"hidden\",\n        width: \"100%\"\n      }),\n      \"data-panel-group\": \"\",\n      \"data-orientation\": o(s),\n      \"data-panel-group-id\": o(r)\n    }, {\n      default: y(() => [\n        w(z.$slots, \"default\", { layout: f.value })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"style\", \"data-orientation\", \"data-panel-group-id\"]));\n  }\n}), ug = /* @__PURE__ */ x({\n  __name: \"SplitterPanel\",\n  props: {\n    collapsedSize: {},\n    collapsible: { type: Boolean },\n    defaultSize: {},\n    id: {},\n    maxSize: {},\n    minSize: {},\n    order: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"collapse\", \"expand\", \"resize\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, s = rr();\n    if (s === null)\n      throw new Error(\n        \"SplitterPanel components must be rendered within a SplitterGroup container\"\n      );\n    const { collapsePanel: r, expandPanel: i, getPanelSize: u, getPanelStyle: d, isPanelCollapsed: c, resizePanel: f, groupId: v, reevaluatePanelConstraints: p, registerPanel: g, unregisterPanel: m } = s, _ = ge(n.id, \"radix-vue-splitter-panel\"), C = B(() => ({\n      callbacks: {\n        onCollapse: () => l(\"collapse\"),\n        onExpand: () => l(\"expand\"),\n        onResize: (...P) => l(\"resize\", ...P)\n      },\n      constraints: {\n        collapsedSize: n.collapsedSize && Number.parseFloat(n.collapsedSize.toFixed(Oo)),\n        collapsible: n.collapsible,\n        defaultSize: n.defaultSize,\n        /** Panel id (unique within group); falls back to useId when not provided */\n        /** Panel id (unique within group); falls back to useId when not provided */\n        maxSize: n.maxSize,\n        minSize: n.minSize\n      },\n      id: _,\n      idIsFromProps: n.id !== void 0,\n      order: n.order\n    }));\n    ee(() => C.value.constraints, (P, D) => {\n      (D.collapsedSize !== P.collapsedSize || D.collapsible !== P.collapsible || D.maxSize !== P.maxSize || D.minSize !== P.minSize) && p(C.value, D);\n    }, { deep: !0 }), le(() => {\n      const P = C.value;\n      g(P), Be(() => {\n        m(P);\n      });\n    });\n    const $ = B(() => d(C.value, n.defaultSize)), h = B(() => c(C.value)), E = B(() => !h.value);\n    return t({\n      /** If panel is `collapsible`, collapse it fully. */\n      collapse: () => {\n        r(C.value);\n      },\n      /** If panel is currently collapsed, expand it to its most recent size. */\n      expand: () => {\n        i(C.value);\n      },\n      /** Gets the current size of the panel as a percentage (1 - 100). */\n      getSize() {\n        return u(C.value);\n      },\n      /** Resize panel to the specified percentage (1 - 100). */\n      resize: (P) => {\n        f(C.value, P);\n      },\n      /** Returns `true` if the panel is currently collapsed */\n      isCollapsed: h,\n      /** Returns `true` if the panel is currently not collapsed */\n      isExpanded: E\n    }), (P, D) => (b(), S(o(O), {\n      id: o(_),\n      style: Me($.value),\n      as: P.as,\n      \"as-child\": P.asChild,\n      \"data-panel\": \"\",\n      \"data-panel-collapsible\": P.collapsible || void 0,\n      \"data-panel-group-id\": o(v),\n      \"data-panel-id\": o(_),\n      \"data-panel-size\": Number.parseFloat(`${$.value.flexGrow}`).toFixed(1),\n      \"data-state\": P.collapsible ? h.value ? \"collapsed\" : \"expanded\" : void 0\n    }, {\n      default: y(() => [\n        w(P.$slots, \"default\", {\n          isCollapsed: h.value,\n          isExpanded: E.value\n        })\n      ]),\n      _: 3\n    }, 8, [\"id\", \"style\", \"as\", \"as-child\", \"data-panel-collapsible\", \"data-panel-group-id\", \"data-panel-id\", \"data-panel-size\", \"data-state\"]));\n  }\n});\nfunction Fp({\n  disabled: a,\n  handleId: t,\n  resizeHandler: e,\n  panelGroupElement: n\n}) {\n  Ce((l) => {\n    const s = n.value;\n    if (a.value || e.value === null || s === null)\n      return;\n    const r = pn(t, s);\n    if (r == null)\n      return;\n    const i = (u) => {\n      var d;\n      if (!u.defaultPrevented)\n        switch (u.key) {\n          case \"ArrowDown\":\n          case \"ArrowLeft\":\n          case \"ArrowRight\":\n          case \"ArrowUp\":\n          case \"End\":\n          case \"Home\": {\n            u.preventDefault(), (d = e.value) == null || d.call(e, u);\n            break;\n          }\n          case \"F6\": {\n            u.preventDefault();\n            const c = r.getAttribute(\"data-panel-group-id\");\n            pe(c);\n            const f = va(\n              c,\n              s\n            ), v = ar(\n              c,\n              t,\n              s\n            );\n            pe(v !== null);\n            const p = u.shiftKey ? v > 0 ? v - 1 : f.length - 1 : v + 1 < f.length ? v + 1 : 0;\n            f[p].focus();\n            break;\n          }\n        }\n    };\n    r.addEventListener(\"keydown\", i), l(() => {\n      r.removeEventListener(\"keydown\", i);\n    });\n  });\n}\nconst dg = /* @__PURE__ */ x({\n  __name: \"SplitterResizeHandle\",\n  props: {\n    id: {},\n    hitAreaMargins: {},\n    tabindex: { default: 0 },\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"dragging\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), { disabled: r } = ae(e), i = rr();\n    if (i === null)\n      throw new Error(\n        \"PanelResizeHandle components must be rendered within a PanelGroup container\"\n      );\n    const {\n      direction: u,\n      groupId: d,\n      registerResizeHandle: c,\n      startDragging: f,\n      stopDragging: v,\n      panelGroupElement: p\n    } = i, g = ge(e.id, \"radix-vue-splitter-resize-handle\"), m = T(\"inactive\"), _ = T(!1), C = T(null);\n    return ee(r, () => {\n      ha && (r.value ? C.value = null : C.value = c(g));\n    }, { immediate: !0 }), Ce(($) => {\n      var P, D;\n      if (r.value || C.value === null)\n        return;\n      const h = s.value;\n      if (!h)\n        return;\n      pe(h);\n      const E = (I, M, V) => {\n        var A;\n        if (M)\n          switch (I) {\n            case \"down\": {\n              m.value = \"drag\", f(g, V), n(\"dragging\", !0);\n              break;\n            }\n            case \"move\": {\n              m.value !== \"drag\" && (m.value = \"hover\"), (A = C.value) == null || A.call(C, V);\n              break;\n            }\n            case \"up\": {\n              m.value = \"hover\", v(), n(\"dragging\", !1);\n              break;\n            }\n          }\n        else\n          m.value = \"inactive\";\n      };\n      $(Ep(\n        g,\n        h,\n        u,\n        {\n          // Coarse inputs (e.g. finger/touch)\n          coarse: ((P = e.hitAreaMargins) == null ? void 0 : P.coarse) ?? 15,\n          // Fine inputs (e.g. mouse)\n          fine: ((D = e.hitAreaMargins) == null ? void 0 : D.fine) ?? 5\n        },\n        E\n      ));\n    }), Fp({\n      disabled: r,\n      resizeHandler: C,\n      handleId: g,\n      panelGroupElement: p\n    }), ($, h) => (b(), S(o(O), {\n      id: o(g),\n      ref: o(l),\n      style: {\n        touchAction: \"none\",\n        userSelect: \"none\"\n      },\n      as: $.as,\n      \"as-child\": $.asChild,\n      role: \"separator\",\n      \"data-resize-handle\": \"\",\n      tabindex: $.tabindex,\n      \"data-state\": m.value,\n      \"data-disabled\": o(r) ? \"\" : void 0,\n      \"data-orientation\": o(u),\n      \"data-panel-group-id\": o(d),\n      \"data-resize-handle-active\": m.value === \"drag\" ? \"pointer\" : _.value ? \"keyboard\" : void 0,\n      \"data-resize-handle-state\": m.value,\n      \"data-panel-resize-handle-enabled\": !o(r),\n      \"data-panel-resize-handle-id\": o(g),\n      onBlur: h[0] || (h[0] = (E) => _.value = !1),\n      onFocus: h[1] || (h[1] = (E) => _.value = !1)\n    }, {\n      default: y(() => [\n        w($.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"id\", \"as\", \"as-child\", \"tabindex\", \"data-state\", \"data-disabled\", \"data-orientation\", \"data-panel-group-id\", \"data-resize-handle-active\", \"data-resize-handle-state\", \"data-panel-resize-handle-enabled\", \"data-panel-resize-handle-id\"]));\n  }\n}), Np = {\n  \"aria-live\": \"polite\",\n  \"aria-atomic\": \"true\",\n  role: \"status\",\n  style: {\n    transform: \"translateX(-100%)\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    opacity: 0,\n    margin: 0\n  }\n}, [ko, Lp] = te(\"StepperRoot\"), cg = /* @__PURE__ */ x({\n  __name: \"StepperRoot\",\n  props: {\n    defaultValue: { default: 1 },\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    modelValue: {},\n    linear: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { dir: l, orientation: s, linear: r } = ae(e), i = we(l);\n    R();\n    const u = T(/* @__PURE__ */ new Set()), d = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), c = B(() => Array.from(u.value)), f = B(() => d.value === 1), v = B(() => d.value === c.value.length), p = B(() => u.value.size);\n    function g(h) {\n      h > p.value || h < 1 || u.value.size && c.value[h] && c.value[h].getAttribute(\"disabled\") || r.value && h > (d.value ?? 1) + 1 || (d.value = h);\n    }\n    const m = T(null), _ = T(null), C = B(() => m.value ? m.value.getAttribute(\"disabled\") === \"\" : !0), $ = B(() => _.value ? _.value.getAttribute(\"disabled\") === \"\" : !0);\n    return ee(d, async () => {\n      await oe(() => {\n        m.value = c.value.length && d.value < c.value.length ? c.value[d.value] : null, _.value = c.value.length && d.value > 1 ? c.value[d.value - 2] : null;\n      });\n    }), ee(c, async () => {\n      await oe(() => {\n        m.value = c.value.length && d.value < c.value.length ? c.value[d.value] : null, _.value = c.value.length && d.value > 1 ? c.value[d.value - 2] : null;\n      });\n    }), Lp({\n      modelValue: d,\n      changeModelValue: (h) => {\n        d.value = h;\n      },\n      orientation: s,\n      dir: i,\n      linear: r,\n      totalStepperItems: u\n    }), (h, E) => (b(), S(o(O), {\n      role: \"group\",\n      \"aria-label\": \"progress\",\n      as: h.as,\n      \"as-child\": h.asChild,\n      \"data-linear\": o(r) ? \"\" : void 0,\n      \"data-orientation\": h.orientation\n    }, {\n      default: y(() => [\n        w(h.$slots, \"default\", {\n          modelValue: o(d),\n          totalSteps: u.value.size,\n          isNextDisabled: C.value,\n          isPrevDisabled: $.value,\n          isFirstStep: f.value,\n          isLastStep: v.value,\n          goToStep: g,\n          nextStep: () => g((o(d) ?? 1) + 1),\n          prevStep: () => g((o(d) ?? 1) - 1)\n        }),\n        Ye(\"div\", Np, \" Step \" + De(o(d)) + \" of \" + De(u.value.size), 1)\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-linear\", \"data-orientation\"]));\n  }\n}), [Sa, zp] = te(\"StepperItem\"), fg = /* @__PURE__ */ x({\n  __name: \"StepperItem\",\n  props: {\n    step: {},\n    disabled: { type: Boolean, default: !1 },\n    completed: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { disabled: e, step: n, completed: l } = ae(t), { forwardRef: s } = R(), r = ko(), i = ge(void 0, \"radix-vue-stepper-item-title\"), u = ge(void 0, \"radix-vue-stepper-item-description\"), d = B(() => l.value ? \"completed\" : r.modelValue.value === n.value ? \"active\" : r.modelValue.value > n.value ? \"completed\" : \"inactive\"), c = B(() => e.value ? !1 : r.linear.value ? n.value <= r.modelValue.value || n.value === r.modelValue.value + 1 : !0);\n    return zp({\n      titleId: i,\n      descriptionId: u,\n      state: d,\n      disabled: e,\n      step: n,\n      isFocusable: c\n    }), (f, v) => (b(), S(o(O), {\n      ref: o(s),\n      as: f.as,\n      \"as-child\": f.asChild,\n      \"aria-current\": d.value === \"active\" ? \"true\" : void 0,\n      \"data-state\": d.value,\n      disabled: o(e) || !c.value ? \"\" : void 0,\n      \"data-disabled\": o(e) || !c.value ? \"\" : void 0,\n      \"data-orientation\": o(r).orientation.value\n    }, {\n      default: y(() => [\n        w(f.$slots, \"default\", { state: d.value })\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"aria-current\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"]));\n  }\n}), pg = /* @__PURE__ */ x({\n  __name: \"StepperTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = ko(), e = Sa(), n = nt(), l = B(() => Array.from(t.totalStepperItems.value));\n    function s(d) {\n      if (!e.disabled.value) {\n        if (t.linear.value) {\n          if ((e.step.value <= t.modelValue.value || e.step.value === t.modelValue.value + 1) && d.ctrlKey === !1) {\n            t.changeModelValue(e.step.value);\n            return;\n          }\n        } else if (d.ctrlKey === !1) {\n          t.changeModelValue(e.step.value);\n          return;\n        }\n        d.preventDefault();\n      }\n    }\n    function r(d) {\n      d.preventDefault(), !e.disabled.value && ((d.key === n.ENTER || d.key === n.SPACE) && !d.ctrlKey && !d.shiftKey && t.changeModelValue(e.step.value), [n.ARROW_LEFT, n.ARROW_RIGHT, n.ARROW_UP, n.ARROW_DOWN].includes(d.key) && At(d, me(), void 0, {\n        itemsArray: l.value,\n        focus: !0,\n        loop: !1,\n        arrowKeyOptions: t.orientation.value,\n        dir: t.dir.value\n      }));\n    }\n    const { forwardRef: i, currentElement: u } = R();\n    return le(() => {\n      t.totalStepperItems.value.add(u.value);\n    }), Be(() => {\n      t.totalStepperItems.value.delete(u.value);\n    }), (d, c) => (b(), S(o(O), {\n      ref: o(i),\n      type: d.as === \"button\" ? \"button\" : void 0,\n      as: d.as,\n      \"as-child\": d.asChild,\n      \"data-state\": o(e).state.value,\n      disabled: o(e).disabled.value || !o(e).isFocusable.value ? \"\" : void 0,\n      \"data-disabled\": o(e).disabled.value || !o(e).isFocusable.value ? \"\" : void 0,\n      \"data-orientation\": o(t).orientation.value,\n      tabindex: o(e).isFocusable.value ? 0 : -1,\n      \"aria-describedby\": o(e).descriptionId,\n      \"aria-labelledby\": o(e).titleId,\n      onMousedown: ue(s, [\"left\"]),\n      onKeydown: ie(r, [\"enter\", \"space\", \"left\", \"right\", \"up\", \"down\"])\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as\", \"as-child\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\", \"tabindex\", \"aria-describedby\", \"aria-labelledby\"]));\n  }\n}), vg = /* @__PURE__ */ x({\n  __name: \"StepperDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"p\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = Sa();\n    return (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).descriptionId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), mg = /* @__PURE__ */ x({\n  __name: \"StepperTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"h4\" }\n  },\n  setup(a) {\n    const t = a, e = Sa();\n    return R(), (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).titleId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), hg = /* @__PURE__ */ x({\n  __name: \"StepperIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = Sa();\n    return R(), (n, l) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          ye(\" Step \" + De(o(e).step.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16));\n  }\n}), yg = /* @__PURE__ */ x({\n  __name: \"StepperSeparator\",\n  props: {\n    orientation: {},\n    decorative: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = ko(), n = Sa();\n    return R(), (l, s) => (b(), S(o(ap), k(t, {\n      decorative: \"\",\n      orientation: o(e).orientation.value,\n      \"data-state\": o(n).state.value\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"orientation\", \"data-state\"]));\n  }\n}), Kp = [\"name\", \"disabled\", \"required\", \"value\", \"checked\", \"data-state\", \"data-disabled\"], [Hp, Wp] = te(\"SwitchRoot\"), gg = /* @__PURE__ */ x({\n  __name: \"SwitchRoot\",\n  props: {\n    defaultChecked: { type: Boolean },\n    checked: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    value: { default: \"on\" },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:checked\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { disabled: l } = ae(e), s = ne(e, \"checked\", n, {\n      defaultValue: e.defaultChecked,\n      passive: e.checked === void 0\n    });\n    function r() {\n      l.value || (s.value = !s.value);\n    }\n    const { forwardRef: i, currentElement: u } = R(), d = at(u), c = B(() => {\n      var f;\n      return e.id && u.value ? (f = document.querySelector(`[for=\"${e.id}\"]`)) == null ? void 0 : f.innerText : void 0;\n    });\n    return Wp({\n      checked: s,\n      toggleCheck: r,\n      disabled: l\n    }), (f, v) => (b(), ve(_e, null, [\n      q(o(O), k(f.$attrs, {\n        id: f.id,\n        ref: o(i),\n        role: \"switch\",\n        type: f.as === \"button\" ? \"button\" : void 0,\n        value: f.value,\n        \"aria-label\": f.$attrs[\"aria-label\"] || c.value,\n        \"aria-checked\": o(s),\n        \"aria-required\": f.required,\n        \"data-state\": o(s) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        \"as-child\": f.asChild,\n        as: f.as,\n        disabled: o(l),\n        onClick: r,\n        onKeydown: ie(ue(r, [\"prevent\"]), [\"enter\"])\n      }), {\n        default: y(() => [\n          w(f.$slots, \"default\", { checked: o(s) })\n        ]),\n        _: 3\n      }, 16, [\"id\", \"type\", \"value\", \"aria-label\", \"aria-checked\", \"aria-required\", \"data-state\", \"data-disabled\", \"as-child\", \"as\", \"disabled\", \"onKeydown\"]),\n      o(d) ? (b(), ve(\"input\", {\n        key: 0,\n        type: \"checkbox\",\n        name: f.name,\n        tabindex: \"-1\",\n        \"aria-hidden\": \"true\",\n        disabled: o(l),\n        required: f.required,\n        value: f.value,\n        checked: !!o(s),\n        \"data-state\": o(s) ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(l) ? \"\" : void 0,\n        style: {\n          transform: \"translateX(-100%)\",\n          position: \"absolute\",\n          pointerEvents: \"none\",\n          opacity: 0,\n          margin: 0\n        }\n      }, null, 8, Kp)) : ce(\"\", !0)\n    ], 64));\n  }\n}), bg = /* @__PURE__ */ x({\n  __name: \"SwitchThumb\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = Hp();\n    return R(), (e, n) => {\n      var l;\n      return b(), S(o(O), {\n        \"data-state\": (l = o(t).checked) != null && l.value ? \"checked\" : \"unchecked\",\n        \"data-disabled\": o(t).disabled.value ? \"\" : void 0,\n        \"as-child\": e.asChild,\n        as: e.as\n      }, {\n        default: y(() => [\n          w(e.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"data-state\", \"data-disabled\", \"as-child\", \"as\"]);\n    };\n  }\n}), [vn, jp] = te(\"TabsRoot\"), Cg = /* @__PURE__ */ x({\n  __name: \"TabsRoot\",\n  props: {\n    defaultValue: {},\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    activationMode: { default: \"automatic\" },\n    modelValue: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { orientation: l, dir: s } = ae(e), r = we(s);\n    R();\n    const i = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.modelValue === void 0\n    }), u = T();\n    return jp({\n      modelValue: i,\n      changeModelValue: (d) => {\n        i.value = d;\n      },\n      orientation: l,\n      dir: r,\n      activationMode: e.activationMode,\n      baseId: ge(void 0, \"radix-vue-tabs\"),\n      tabsList: u\n    }), (d, c) => (b(), S(o(O), {\n      dir: o(r),\n      \"data-orientation\": o(l),\n      \"as-child\": d.asChild,\n      as: d.as\n    }, {\n      default: y(() => [\n        w(d.$slots, \"default\", { modelValue: o(i) })\n      ]),\n      _: 3\n    }, 8, [\"dir\", \"data-orientation\", \"as-child\", \"as\"]));\n  }\n}), wg = /* @__PURE__ */ x({\n  __name: \"TabsList\",\n  props: {\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { loop: e } = ae(t), { forwardRef: n, currentElement: l } = R(), s = vn();\n    return s.tabsList = l, (r, i) => (b(), S(o(Ft), {\n      \"as-child\": \"\",\n      orientation: o(s).orientation.value,\n      dir: o(s).dir.value,\n      loop: o(e)\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(n),\n          role: \"tablist\",\n          \"as-child\": r.asChild,\n          as: r.as,\n          \"aria-orientation\": o(s).orientation.value\n        }, {\n          default: y(() => [\n            w(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\", \"aria-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n});\nfunction ir(a, t) {\n  return `${a}-trigger-${t}`;\n}\nfunction ur(a, t) {\n  return `${a}-content-${t}`;\n}\nconst _g = /* @__PURE__ */ x({\n  __name: \"TabsContent\",\n  props: {\n    value: {},\n    forceMount: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = vn(), l = B(() => ir(n.baseId, t.value)), s = B(() => ur(n.baseId, t.value)), r = B(() => t.value === n.modelValue.value), i = T(r.value);\n    return le(() => {\n      requestAnimationFrame(() => {\n        i.value = !1;\n      });\n    }), (u, d) => (b(), S(o(Pe), {\n      present: r.value,\n      \"force-mount\": \"\"\n    }, {\n      default: y(({ present: c }) => [\n        q(o(O), {\n          id: s.value,\n          ref: o(e),\n          \"as-child\": u.asChild,\n          as: u.as,\n          role: \"tabpanel\",\n          \"data-state\": r.value ? \"active\" : \"inactive\",\n          \"data-orientation\": o(n).orientation.value,\n          \"aria-labelledby\": l.value,\n          hidden: !c.value,\n          tabindex: \"0\",\n          style: Me({\n            animationDuration: i.value ? \"0s\" : void 0\n          })\n        }, {\n          default: y(() => [\n            u.forceMount || r.value ? w(u.$slots, \"default\", { key: 0 }) : ce(\"\", !0)\n          ]),\n          _: 2\n        }, 1032, [\"id\", \"as-child\", \"as\", \"data-state\", \"data-orientation\", \"aria-labelledby\", \"hidden\", \"style\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), xg = /* @__PURE__ */ x({\n  __name: \"TabsTrigger\",\n  props: {\n    value: {},\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), n = vn(), l = B(() => ir(n.baseId, t.value)), s = B(() => ur(n.baseId, t.value)), r = B(() => t.value === n.modelValue.value);\n    return (i, u) => (b(), S(o(Nt), {\n      \"as-child\": \"\",\n      focusable: !i.disabled,\n      active: r.value\n    }, {\n      default: y(() => [\n        q(o(O), {\n          id: l.value,\n          ref: o(e),\n          role: \"tab\",\n          type: i.as === \"button\" ? \"button\" : void 0,\n          as: i.as,\n          \"as-child\": i.asChild,\n          \"aria-selected\": r.value ? \"true\" : \"false\",\n          \"aria-controls\": s.value,\n          \"data-state\": r.value ? \"active\" : \"inactive\",\n          disabled: i.disabled,\n          \"data-disabled\": i.disabled ? \"\" : void 0,\n          \"data-orientation\": o(n).orientation.value,\n          onMousedown: u[0] || (u[0] = ue((d) => {\n            !i.disabled && d.ctrlKey === !1 ? o(n).changeModelValue(i.value) : d.preventDefault();\n          }, [\"left\"])),\n          onKeydown: u[1] || (u[1] = ie((d) => o(n).changeModelValue(i.value), [\"enter\", \"space\"])),\n          onFocus: u[2] || (u[2] = () => {\n            const d = o(n).activationMode !== \"manual\";\n            !r.value && !i.disabled && d && o(n).changeModelValue(i.value);\n          })\n        }, {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"id\", \"type\", \"as\", \"as-child\", \"aria-selected\", \"aria-controls\", \"data-state\", \"disabled\", \"data-disabled\", \"data-orientation\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), Sg = /* @__PURE__ */ x({\n  __name: \"TabsIndicator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = vn();\n    R();\n    const n = T(), l = T({\n      size: null,\n      position: null\n    });\n    ee(() => [e.modelValue.value, e == null ? void 0 : e.dir.value], async () => {\n      await oe(), s();\n    }, { immediate: !0 }), tt([e.tabsList, n], s);\n    function s() {\n      var r;\n      n.value = (r = e.tabsList.value) == null ? void 0 : r.querySelector('[role=\"tab\"][data-state=\"active\"]'), n.value && (e.orientation.value === \"horizontal\" ? l.value = {\n        size: n.value.offsetWidth,\n        position: n.value.offsetLeft\n      } : l.value = {\n        size: n.value.offsetHeight,\n        position: n.value.offsetTop\n      });\n    }\n    return (r, i) => typeof l.value.size == \"number\" ? (b(), S(o(O), k({ key: 0 }, t, {\n      style: {\n        \"--radix-tabs-indicator-size\": `${l.value.size}px`,\n        \"--radix-tabs-indicator-position\": `${l.value.position}px`\n      }\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"style\"])) : ce(\"\", !0);\n  }\n}), [mn, Up] = te(\"TagsInputRoot\"), Eg = /* @__PURE__ */ x({\n  __name: \"TagsInputRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: { default: () => [] },\n    addOnPaste: { type: Boolean },\n    addOnTab: { type: Boolean },\n    addOnBlur: { type: Boolean },\n    duplicate: { type: Boolean },\n    disabled: { type: Boolean },\n    delimiter: { default: \",\" },\n    dir: {},\n    max: { default: 0 },\n    required: { type: Boolean },\n    name: {},\n    id: {},\n    convertValue: {},\n    displayValue: { type: Function, default: (a) => a.toString() },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  emits: [\"update:modelValue\", \"invalid\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { addOnPaste: l, disabled: s, delimiter: r, max: i, id: u, dir: d, addOnBlur: c, addOnTab: f } = ae(e), v = we(d), p = ne(e, \"modelValue\", n, {\n      defaultValue: e.defaultValue,\n      passive: !0,\n      deep: !0\n    }), { forwardRef: g, currentElement: m } = R(), { focused: _ } = Si(m), C = at(m), { getItems: $ } = Ca(), h = T(), E = T(!1);\n    return Up({\n      modelValue: p,\n      onAddValue: (P) => {\n        const D = p.value.length > 0 && typeof p.value[0] == \"object\", I = p.value.length > 0 && typeof e.defaultValue[0] == \"object\";\n        if ((D || I) && typeof e.convertValue != \"function\")\n          throw new Error(\"You must provide a `convertValue` function when using objects as values.\");\n        const M = e.convertValue ? e.convertValue(P) : P;\n        if (p.value.length >= i.value && i.value)\n          return n(\"invalid\", M), !1;\n        if (e.duplicate)\n          return p.value = [...p.value, M], !0;\n        if (p.value.includes(M))\n          E.value = !0;\n        else\n          return p.value = [...p.value, M], !0;\n        return n(\"invalid\", M), !1;\n      },\n      onRemoveValue: (P) => {\n        P !== -1 && (p.value = p.value.filter((D, I) => I !== P));\n      },\n      onInputKeydown: (P) => {\n        const D = P.target, I = $().map((V) => V.ref).filter((V) => V.dataset.disabled !== \"\");\n        if (!I.length)\n          return;\n        const M = I.at(-1);\n        switch (P.key) {\n          case \"Delete\":\n          case \"Backspace\": {\n            if (D.selectionStart !== 0 || D.selectionEnd !== 0)\n              break;\n            if (h.value) {\n              const V = I.findIndex((A) => A === h.value);\n              p.value = p.value.filter((A, F) => F !== V), h.value = h.value === M ? I.at(V - 1) : I.at(V + 1), P.preventDefault();\n            } else P.key === \"Backspace\" && (h.value = M, P.preventDefault());\n            break;\n          }\n          case \"Home\":\n          case \"End\":\n          case \"ArrowRight\":\n          case \"ArrowLeft\": {\n            const V = P.key === \"ArrowRight\" && v.value === \"ltr\" || P.key === \"ArrowLeft\" && v.value === \"rtl\", A = !V;\n            if (D.selectionStart !== 0 || D.selectionEnd !== 0)\n              break;\n            if (A && !h.value)\n              h.value = M, P.preventDefault();\n            else if (V && M && h.value === M)\n              h.value = void 0, P.preventDefault();\n            else if (h.value) {\n              const F = At(P, h.value, void 0, {\n                itemsArray: I,\n                loop: !1,\n                dir: v.value\n              });\n              F && (h.value = F), P.preventDefault();\n            }\n            break;\n          }\n          case \"ArrowUp\":\n          case \"ArrowDown\": {\n            h.value && P.preventDefault();\n            break;\n          }\n          default:\n            h.value = void 0;\n        }\n      },\n      selectedElement: h,\n      isInvalidInput: E,\n      addOnPaste: l,\n      addOnBlur: c,\n      addOnTab: f,\n      dir: v,\n      disabled: s,\n      delimiter: r,\n      max: i,\n      id: u,\n      displayValue: e.displayValue\n    }), (P, D) => (b(), S(o(wa), null, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(g),\n          dir: o(v),\n          as: P.as,\n          \"as-child\": P.asChild,\n          \"data-invalid\": E.value ? \"\" : void 0,\n          \"data-disabled\": o(s) ? \"\" : void 0,\n          \"data-focused\": o(_) ? \"\" : void 0\n        }, {\n          default: y(() => [\n            w(P.$slots, \"default\", { modelValue: o(p) }),\n            o(C) && P.name ? (b(), S(o(no), {\n              key: 0,\n              name: P.name,\n              value: o(p),\n              required: P.required,\n              disabled: o(s)\n            }, null, 8, [\"name\", \"value\", \"required\", \"disabled\"])) : ce(\"\", !0)\n          ]),\n          _: 3\n        }, 8, [\"dir\", \"as\", \"as-child\", \"data-invalid\", \"data-disabled\", \"data-focused\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Pg = /* @__PURE__ */ x({\n  __name: \"TagsInputInput\",\n  props: {\n    placeholder: {},\n    autoFocus: { type: Boolean },\n    maxLength: {},\n    asChild: { type: Boolean },\n    as: { default: \"input\" }\n  },\n  setup(a) {\n    const t = a, e = mn(), { forwardRef: n, currentElement: l } = R();\n    function s(p) {\n      if (!e.addOnBlur.value)\n        return;\n      const g = p.target;\n      if (!g.value)\n        return;\n      e.onAddValue(g.value) && (g.value = \"\");\n    }\n    function r(p) {\n      e.addOnTab.value && c(p);\n    }\n    const i = T(!1);\n    function u() {\n      i.value = !0;\n    }\n    function d() {\n      requestAnimationFrame(() => {\n        i.value = !1;\n      });\n    }\n    async function c(p) {\n      if (i.value || (await oe(), p.defaultPrevented))\n        return;\n      const g = p.target;\n      if (!g.value)\n        return;\n      e.onAddValue(g.value) && (g.value = \"\"), p.preventDefault();\n    }\n    function f(p) {\n      e.isInvalidInput.value = !1;\n      const g = e.delimiter.value;\n      if (g === p.data) {\n        const m = p.target;\n        m.value = m.value.replaceAll(g, \"\"), e.onAddValue(m.value) && (m.value = \"\");\n      }\n    }\n    function v(p) {\n      if (e.addOnPaste.value) {\n        p.preventDefault();\n        const g = p.clipboardData;\n        if (!g)\n          return;\n        const m = g.getData(\"text\");\n        e.delimiter.value ? m.split(e.delimiter.value).forEach((C) => {\n          e.onAddValue(C);\n        }) : e.onAddValue(m);\n      }\n    }\n    return le(() => {\n      const p = l.value.nodeName === \"INPUT\" ? l.value : l.value.querySelector(\"input\");\n      p && setTimeout(() => {\n        t.autoFocus && (p == null || p.focus());\n      }, 1);\n    }), (p, g) => {\n      var m;\n      return b(), S(o(O), {\n        id: (m = o(e).id) == null ? void 0 : m.value,\n        ref: o(n),\n        type: \"text\",\n        autocomplete: \"off\",\n        autocorrect: \"off\",\n        autocapitalize: \"off\",\n        as: p.as,\n        \"as-child\": p.asChild,\n        maxlength: p.maxLength,\n        placeholder: p.placeholder,\n        disabled: o(e).disabled.value,\n        \"data-invalid\": o(e).isInvalidInput.value ? \"\" : void 0,\n        onInput: f,\n        onKeydown: [\n          ie(c, [\"enter\"]),\n          ie(r, [\"tab\"]),\n          o(e).onInputKeydown\n        ],\n        onBlur: s,\n        onCompositionstart: u,\n        onCompositionend: d,\n        onPaste: v\n      }, {\n        default: y(() => [\n          w(p.$slots, \"default\")\n        ]),\n        _: 3\n      }, 8, [\"id\", \"as\", \"as-child\", \"maxlength\", \"placeholder\", \"disabled\", \"data-invalid\", \"onKeydown\"]);\n    };\n  }\n}), [dr, Gp] = te(\"TagsInputItem\"), Dg = /* @__PURE__ */ x({\n  __name: \"TagsInputItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { value: e } = ae(t), n = mn(), { forwardRef: l, currentElement: s } = R(), r = B(() => n.selectedElement.value === s.value), i = B(() => t.disabled || n.disabled.value), u = Gp({\n      value: e,\n      isSelected: r,\n      disabled: i,\n      textId: \"\",\n      displayValue: B(() => n.displayValue(e.value))\n    });\n    return (d, c) => (b(), S(o(Qt), null, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(l),\n          as: d.as,\n          \"as-child\": d.asChild,\n          \"aria-labelledby\": o(u).textId,\n          \"aria-current\": r.value,\n          \"data-disabled\": i.value ? \"\" : void 0,\n          \"data-state\": r.value ? \"active\" : \"inactive\"\n        }, {\n          default: y(() => [\n            w(d.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-labelledby\", \"aria-current\", \"data-disabled\", \"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), $g = /* @__PURE__ */ x({\n  __name: \"TagsInputItemText\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"span\" }\n  },\n  setup(a) {\n    const t = a, e = dr();\n    return R(), e.textId || (e.textId = ge(void 0, \"radix-vue-tags-input-item-text\")), (n, l) => (b(), S(o(O), k(t, {\n      id: o(e).textId\n    }), {\n      default: y(() => [\n        w(n.$slots, \"default\", {}, () => [\n          ye(De(o(e).displayValue.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 16, [\"id\"]));\n  }\n}), Bg = /* @__PURE__ */ x({\n  __name: \"TagsInputItemDelete\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = mn(), n = dr(), l = B(() => {\n      var r;\n      return ((r = n.disabled) == null ? void 0 : r.value) || e.disabled.value;\n    });\n    function s() {\n      if (l.value)\n        return;\n      const r = e.modelValue.value.findIndex((i) => i === n.value.value);\n      e.onRemoveValue(r);\n    }\n    return (r, i) => (b(), S(o(O), k({ tabindex: \"-1\" }, t, {\n      \"aria-labelledby\": o(n).textId,\n      \"aria-current\": o(n).isSelected.value,\n      \"data-state\": o(n).isSelected.value ? \"active\" : \"inactive\",\n      \"data-disabled\": l.value ? \"\" : void 0,\n      type: r.as === \"button\" ? \"button\" : void 0,\n      onClick: s\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"aria-labelledby\", \"aria-current\", \"data-state\", \"data-disabled\", \"type\"]));\n  }\n}), Ig = /* @__PURE__ */ x({\n  __name: \"TagsInputClear\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a;\n    R();\n    const e = mn();\n    function n() {\n      e.disabled.value || (e.modelValue.value = []);\n    }\n    return (l, s) => (b(), S(o(O), k(t, {\n      type: l.as === \"button\" ? \"button\" : void 0,\n      \"data-disabled\": o(e).disabled.value ? \"\" : void 0,\n      onClick: n\n    }), {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"type\", \"data-disabled\"]));\n  }\n}), [hn, qp] = te(\"ToastProvider\"), Tg = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ToastProvider\",\n  props: {\n    label: { default: \"Notification\" },\n    duration: { default: 5e3 },\n    swipeDirection: { default: \"right\" },\n    swipeThreshold: { default: 50 }\n  },\n  setup(a) {\n    const t = a, { label: e, duration: n, swipeDirection: l, swipeThreshold: s } = ae(t), r = T(), i = T(0), u = T(!1), d = T(!1);\n    if (t.label && typeof t.label == \"string\" && !t.label.trim()) {\n      const c = \"Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.\";\n      throw new Error(c);\n    }\n    return qp({\n      label: e,\n      duration: n,\n      swipeDirection: l,\n      swipeThreshold: s,\n      toastCount: i,\n      viewport: r,\n      onViewportChange(c) {\n        r.value = c;\n      },\n      onToastAdd() {\n        i.value++;\n      },\n      onToastRemove() {\n        i.value--;\n      },\n      isFocusedToastEscapeKeyDownRef: u,\n      isClosePausedRef: d\n    }), (c, f) => w(c.$slots, \"default\");\n  }\n}), Yp = \"toast.swipeStart\", Xp = \"toast.swipeMove\", Zp = \"toast.swipeCancel\", Jp = \"toast.swipeEnd\", Mn = \"toast.viewportPause\", Vn = \"toast.viewportResume\";\nfunction ka(a, t, e) {\n  const n = e.originalEvent.currentTarget, l = new CustomEvent(a, {\n    bubbles: !1,\n    cancelable: !0,\n    detail: e\n  });\n  t && n.addEventListener(a, t, { once: !0 }), n.dispatchEvent(l);\n}\nfunction rl(a, t, e = 0) {\n  const n = Math.abs(a.x), l = Math.abs(a.y), s = n > l;\n  return t === \"left\" || t === \"right\" ? s && n > e : !s && l > e;\n}\nfunction Qp(a) {\n  return a.nodeType === a.ELEMENT_NODE;\n}\nfunction cr(a) {\n  const t = [];\n  return Array.from(a.childNodes).forEach((n) => {\n    if (n.nodeType === n.TEXT_NODE && n.textContent && t.push(n.textContent), Qp(n)) {\n      const l = n.ariaHidden || n.hidden || n.style.display === \"none\", s = n.dataset.radixToastAnnounceExclude === \"\";\n      if (!l)\n        if (s) {\n          const r = n.dataset.radixToastAnnounceAlt;\n          r && t.push(r);\n        } else\n          t.push(...cr(n));\n    }\n  }), t;\n}\nconst ev = /* @__PURE__ */ x({\n  __name: \"ToastAnnounce\",\n  setup(a) {\n    const t = hn(), e = gi(1e3), n = T(!1);\n    return Ol(() => {\n      n.value = !0;\n    }), (l, s) => o(e) || n.value ? (b(), S(o(Jt), { key: 0 }, {\n      default: y(() => [\n        ye(De(o(t).label.value) + \" \", 1),\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    })) : ce(\"\", !0);\n  }\n}), [tv, av] = te(\"ToastRoot\"), nv = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ToastRootImpl\",\n  props: {\n    type: {},\n    open: { type: Boolean, default: !1 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"close\", \"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l, currentElement: s } = R(), r = hn(), i = T(null), u = T(null), d = B(\n      () => typeof e.duration == \"number\" ? e.duration : r.duration.value\n    ), c = T(0), f = T(d.value), v = T(0), p = T(d.value), g = Ol(() => {\n      const $ = (/* @__PURE__ */ new Date()).getTime() - c.value;\n      p.value = Math.max(f.value - $, 0);\n    }, { fpsLimit: 60 });\n    function m($) {\n      $ <= 0 || $ === Number.POSITIVE_INFINITY || Je && (window.clearTimeout(v.value), c.value = (/* @__PURE__ */ new Date()).getTime(), v.value = window.setTimeout(_, $));\n    }\n    function _() {\n      var h, E;\n      ((h = s.value) == null ? void 0 : h.contains(me())) && ((E = r.viewport.value) == null || E.focus()), r.isClosePausedRef.value = !1, n(\"close\");\n    }\n    const C = B(() => s.value ? cr(s.value) : null);\n    if (e.type && ![\"foreground\", \"background\"].includes(e.type)) {\n      const $ = \"Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.\";\n      throw new Error($);\n    }\n    return Ce(($) => {\n      const h = r.viewport.value;\n      if (h) {\n        const E = () => {\n          m(f.value), g.resume(), n(\"resume\");\n        }, P = () => {\n          const D = (/* @__PURE__ */ new Date()).getTime() - c.value;\n          f.value = f.value - D, window.clearTimeout(v.value), g.pause(), n(\"pause\");\n        };\n        return h.addEventListener(Mn, P), h.addEventListener(Vn, E), () => {\n          h.removeEventListener(Mn, P), h.removeEventListener(Vn, E);\n        };\n      }\n    }), ee(() => [e.open, d.value], () => {\n      f.value = d.value, e.open && !r.isClosePausedRef.value && m(d.value);\n    }, { immediate: !0 }), Gn(\"Escape\", ($) => {\n      n(\"escapeKeyDown\", $), $.defaultPrevented || (r.isFocusedToastEscapeKeyDownRef.value = !0, _());\n    }), le(() => {\n      r.onToastAdd();\n    }), Be(() => {\n      r.onToastRemove();\n    }), av({ onClose: _ }), ($, h) => (b(), ve(_e, null, [\n      C.value ? (b(), S(ev, {\n        key: 0,\n        role: \"alert\",\n        \"aria-live\": $.type === \"foreground\" ? \"assertive\" : \"polite\",\n        \"aria-atomic\": \"true\"\n      }, {\n        default: y(() => [\n          ye(De(C.value), 1)\n        ]),\n        _: 1\n      }, 8, [\"aria-live\"])) : ce(\"\", !0),\n      o(r).viewport.value ? (b(), S(qt, {\n        key: 1,\n        to: o(r).viewport.value\n      }, [\n        q(o(O), k({\n          ref: o(l),\n          role: \"alert\",\n          \"aria-live\": \"off\",\n          \"aria-atomic\": \"true\",\n          tabindex: \"0\",\n          \"data-radix-vue-collection-item\": \"\"\n        }, $.$attrs, {\n          as: $.as,\n          \"as-child\": $.asChild,\n          \"data-state\": $.open ? \"open\" : \"closed\",\n          \"data-swipe-direction\": o(r).swipeDirection.value,\n          style: { userSelect: \"none\", touchAction: \"none\" },\n          onPointerdown: h[0] || (h[0] = ue((E) => {\n            i.value = { x: E.clientX, y: E.clientY };\n          }, [\"left\"])),\n          onPointermove: h[1] || (h[1] = (E) => {\n            if (!i.value) return;\n            const P = E.clientX - i.value.x, D = E.clientY - i.value.y, I = !!u.value, M = [\"left\", \"right\"].includes(o(r).swipeDirection.value), V = [\"left\", \"up\"].includes(o(r).swipeDirection.value) ? Math.min : Math.max, A = M ? V(0, P) : 0, F = M ? 0 : V(0, D), j = E.pointerType === \"touch\" ? 10 : 2, H = { x: A, y: F }, Q = { originalEvent: E, delta: H };\n            I ? (u.value = H, o(ka)(o(Xp), (G) => n(\"swipeMove\", G), Q)) : o(rl)(H, o(r).swipeDirection.value, j) ? (u.value = H, o(ka)(o(Yp), (G) => n(\"swipeStart\", G), Q), E.target.setPointerCapture(E.pointerId)) : (Math.abs(P) > j || Math.abs(D) > j) && (i.value = null);\n          }),\n          onPointerup: h[2] || (h[2] = (E) => {\n            const P = u.value, D = E.target;\n            if (D.hasPointerCapture(E.pointerId) && D.releasePointerCapture(E.pointerId), u.value = null, i.value = null, P) {\n              const I = E.currentTarget, M = { originalEvent: E, delta: P };\n              o(rl)(P, o(r).swipeDirection.value, o(r).swipeThreshold.value) ? o(ka)(o(Jp), (V) => n(\"swipeEnd\", V), M) : o(ka)(o(Zp), (V) => n(\"swipeCancel\", V), M), I == null || I.addEventListener(\"click\", (V) => V.preventDefault(), {\n                once: !0\n              });\n            }\n          })\n        }), {\n          default: y(() => [\n            w($.$slots, \"default\", {\n              remaining: p.value,\n              duration: d.value\n            })\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"data-state\", \"data-swipe-direction\"])\n      ], 8, [\"to\"])) : ce(\"\", !0)\n    ], 64));\n  }\n}), Rg = /* @__PURE__ */ x({\n  __name: \"ToastRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !0 },\n    forceMount: { type: Boolean },\n    type: { default: \"foreground\" },\n    open: { type: Boolean, default: void 0 },\n    duration: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"escapeKeyDown\", \"pause\", \"resume\", \"swipeStart\", \"swipeMove\", \"swipeCancel\", \"swipeEnd\", \"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { forwardRef: l } = R(), s = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    return (r, i) => (b(), S(o(Pe), {\n      present: r.forceMount || o(s)\n    }, {\n      default: y(() => [\n        q(nv, k({\n          ref: o(l),\n          open: o(s),\n          type: r.type,\n          as: r.as,\n          \"as-child\": r.asChild,\n          duration: r.duration\n        }, r.$attrs, {\n          onClose: i[0] || (i[0] = (u) => s.value = !1),\n          onPause: i[1] || (i[1] = (u) => n(\"pause\")),\n          onResume: i[2] || (i[2] = (u) => n(\"resume\")),\n          onEscapeKeyDown: i[3] || (i[3] = (u) => n(\"escapeKeyDown\", u)),\n          onSwipeStart: i[4] || (i[4] = (u) => {\n            n(\"swipeStart\", u), u.currentTarget.setAttribute(\"data-swipe\", \"start\");\n          }),\n          onSwipeMove: i[5] || (i[5] = (u) => {\n            const { x: d, y: c } = u.detail.delta, f = u.currentTarget;\n            f.setAttribute(\"data-swipe\", \"move\"), f.style.setProperty(\"--radix-toast-swipe-move-x\", `${d}px`), f.style.setProperty(\"--radix-toast-swipe-move-y\", `${c}px`);\n          }),\n          onSwipeCancel: i[6] || (i[6] = (u) => {\n            const d = u.currentTarget;\n            d.setAttribute(\"data-swipe\", \"cancel\"), d.style.removeProperty(\"--radix-toast-swipe-move-x\"), d.style.removeProperty(\"--radix-toast-swipe-move-y\"), d.style.removeProperty(\"--radix-toast-swipe-end-x\"), d.style.removeProperty(\"--radix-toast-swipe-end-y\");\n          }),\n          onSwipeEnd: i[7] || (i[7] = (u) => {\n            const { x: d, y: c } = u.detail.delta, f = u.currentTarget;\n            f.setAttribute(\"data-swipe\", \"end\"), f.style.removeProperty(\"--radix-toast-swipe-move-x\"), f.style.removeProperty(\"--radix-toast-swipe-move-y\"), f.style.setProperty(\"--radix-toast-swipe-end-x\", `${d}px`), f.style.setProperty(\"--radix-toast-swipe-end-y\", `${c}px`), s.value = !1;\n          })\n        }), {\n          default: y(({ remaining: u, duration: d }) => [\n            w(r.$slots, \"default\", {\n              remaining: u,\n              duration: d,\n              open: o(s)\n            })\n          ]),\n          _: 3\n        }, 16, [\"open\", \"type\", \"as\", \"as-child\", \"duration\"])\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Ag = /* @__PURE__ */ x({\n  __name: \"ToastPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), fr = /* @__PURE__ */ x({\n  __name: \"ToastAnnounceExclude\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    return (t, e) => (b(), S(o(O), {\n      as: t.as,\n      \"as-child\": t.asChild,\n      \"data-radix-toast-announce-exclude\": \"\",\n      \"data-radix-toast-announce-alt\": t.altText || void 0\n    }, {\n      default: y(() => [\n        w(t.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"as\", \"as-child\", \"data-radix-toast-announce-alt\"]));\n  }\n}), ov = /* @__PURE__ */ x({\n  __name: \"ToastClose\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = tv(), { forwardRef: n } = R();\n    return (l, s) => (b(), S(fr, { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), k(t, {\n          ref: o(n),\n          type: l.as === \"button\" ? \"button\" : void 0,\n          onClick: s[0] || (s[0] = (r) => o(e).onClose())\n        }), {\n          default: y(() => [\n            w(l.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }));\n  }\n}), Og = /* @__PURE__ */ x({\n  __name: \"ToastAction\",\n  props: {\n    altText: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    if (!a.altText)\n      throw new Error(\"Missing prop `altText` expected on `ToastAction`\");\n    const { forwardRef: e } = R();\n    return (n, l) => n.altText ? (b(), S(fr, {\n      key: 0,\n      \"alt-text\": n.altText,\n      \"as-child\": \"\"\n    }, {\n      default: y(() => [\n        q(ov, {\n          ref: o(e),\n          as: n.as,\n          \"as-child\": n.asChild\n        }, {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\"])\n      ]),\n      _: 3\n    }, 8, [\"alt-text\"])) : ce(\"\", !0);\n  }\n}), il = /* @__PURE__ */ x({\n  __name: \"FocusProxy\",\n  emits: [\"focusFromOutsideViewport\"],\n  setup(a, { emit: t }) {\n    const e = t, n = hn();\n    return (l, s) => (b(), S(o(Jt), {\n      \"aria-hidden\": \"true\",\n      tabindex: \"0\",\n      style: { position: \"fixed\" },\n      onFocus: s[0] || (s[0] = (r) => {\n        var d;\n        const i = r.relatedTarget;\n        !((d = o(n).viewport.value) != null && d.contains(i)) && e(\"focusFromOutsideViewport\");\n      })\n    }, {\n      default: y(() => [\n        w(l.$slots, \"default\")\n      ]),\n      _: 3\n    }));\n  }\n}), kg = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"ToastViewport\",\n  props: {\n    hotkey: { default: () => [\"F8\"] },\n    label: { type: [String, Function], default: \"Notifications ({hotkey})\" },\n    asChild: { type: Boolean },\n    as: { default: \"ol\" }\n  },\n  setup(a) {\n    const t = a, { hotkey: e, label: n } = ae(t), { forwardRef: l, currentElement: s } = R(), { createCollection: r } = Fe(), i = r(s), u = hn(), d = B(() => u.toastCount.value > 0), c = T(), f = T(), v = B(() => e.value.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\"));\n    Gn(e.value, () => {\n      s.value.focus();\n    }), le(() => {\n      u.onViewportChange(s.value);\n    }), Ce((g) => {\n      const m = s.value;\n      if (d.value && m) {\n        const _ = () => {\n          if (!u.isClosePausedRef.value) {\n            const P = new CustomEvent(Mn);\n            m.dispatchEvent(P), u.isClosePausedRef.value = !0;\n          }\n        }, C = () => {\n          if (u.isClosePausedRef.value) {\n            const P = new CustomEvent(Vn);\n            m.dispatchEvent(P), u.isClosePausedRef.value = !1;\n          }\n        }, $ = (P) => {\n          !m.contains(P.relatedTarget) && C();\n        }, h = () => {\n          m.contains(me()) || C();\n        }, E = (P) => {\n          var M, V, A;\n          const D = P.altKey || P.ctrlKey || P.metaKey;\n          if (P.key === \"Tab\" && !D) {\n            const F = me(), j = P.shiftKey;\n            if (P.target === m && j) {\n              (M = c.value) == null || M.focus();\n              return;\n            }\n            const G = p({ tabbingDirection: j ? \"backwards\" : \"forwards\" }), J = G.findIndex((z) => z === F);\n            Ma(G.slice(J + 1)) ? P.preventDefault() : j ? (V = c.value) == null || V.focus() : (A = f.value) == null || A.focus();\n          }\n        };\n        m.addEventListener(\"focusin\", _), m.addEventListener(\"focusout\", $), m.addEventListener(\"pointermove\", _), m.addEventListener(\"pointerleave\", h), m.addEventListener(\"keydown\", E), window.addEventListener(\"blur\", _), window.addEventListener(\"focus\", C), g(() => {\n          m.removeEventListener(\"focusin\", _), m.removeEventListener(\"focusout\", $), m.removeEventListener(\"pointermove\", _), m.removeEventListener(\"pointerleave\", h), m.removeEventListener(\"keydown\", E), window.removeEventListener(\"blur\", _), window.removeEventListener(\"focus\", C);\n        });\n      }\n    });\n    function p({ tabbingDirection: g }) {\n      const _ = i.value.map((C) => {\n        const $ = [C, ...eo(C)];\n        return g === \"forwards\" ? $ : $.reverse();\n      });\n      return (g === \"forwards\" ? _.reverse() : _).flat();\n    }\n    return (g, m) => (b(), S(o(ru), {\n      role: \"region\",\n      \"aria-label\": typeof o(n) == \"string\" ? o(n).replace(\"{hotkey}\", v.value) : o(n)(v.value),\n      tabindex: \"-1\",\n      style: Me({\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        pointerEvents: d.value ? void 0 : \"none\"\n      })\n    }, {\n      default: y(() => [\n        d.value ? (b(), S(il, {\n          key: 0,\n          ref: (_) => {\n            c.value = o($e)(_);\n          },\n          onFocusFromOutsideViewport: m[0] || (m[0] = () => {\n            const _ = p({\n              tabbingDirection: \"forwards\"\n            });\n            o(Ma)(_);\n          })\n        }, null, 512)) : ce(\"\", !0),\n        q(o(O), k({\n          ref: o(l),\n          tabindex: \"-1\",\n          as: g.as,\n          \"as-child\": g.asChild\n        }, g.$attrs), {\n          default: y(() => [\n            w(g.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\"]),\n        d.value ? (b(), S(il, {\n          key: 1,\n          ref: (_) => {\n            f.value = o($e)(_);\n          },\n          onFocusFromOutsideViewport: m[1] || (m[1] = () => {\n            const _ = p({\n              tabbingDirection: \"backwards\"\n            });\n            o(Ma)(_);\n          })\n        }, null, 512)) : ce(\"\", !0)\n      ]),\n      _: 3\n    }, 8, [\"aria-label\", \"style\"]));\n  }\n}), Mg = /* @__PURE__ */ x({\n  __name: \"ToastTitle\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Vg = /* @__PURE__ */ x({\n  __name: \"ToastDescription\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(O), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), lv = /* @__PURE__ */ x({\n  __name: \"Toggle\",\n  props: {\n    defaultValue: { type: Boolean },\n    pressed: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: !1 },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  emits: [\"update:pressed\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = ne(e, \"pressed\", n, {\n      defaultValue: e.defaultValue,\n      passive: e.pressed === void 0\n    });\n    function s() {\n      l.value = !l.value;\n    }\n    const r = B(() => l.value ? \"on\" : \"off\");\n    return (i, u) => (b(), S(o(O), {\n      type: i.as === \"button\" ? \"button\" : void 0,\n      \"as-child\": e.asChild,\n      as: i.as,\n      \"aria-pressed\": o(l),\n      \"data-state\": r.value,\n      \"data-disabled\": i.disabled ? \"\" : void 0,\n      disabled: i.disabled,\n      onClick: s\n    }, {\n      default: y(() => [\n        w(i.$slots, \"default\", { pressed: o(l) })\n      ]),\n      _: 3\n    }, 8, [\"type\", \"as-child\", \"as\", \"aria-pressed\", \"data-state\", \"data-disabled\", \"disabled\"]));\n  }\n}), [sv, rv] = te(\"ToggleGroupRoot\"), iv = /* @__PURE__ */ x({\n  __name: \"ToggleGroupRoot\",\n  props: {\n    rovingFocus: { type: Boolean, default: !0 },\n    disabled: { type: Boolean, default: !1 },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean, default: !0 },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { loop: l, rovingFocus: s, disabled: r, dir: i } = ae(e), u = we(i), { forwardRef: d } = R(), { modelValue: c, changeModelValue: f, isSingle: v } = Wl(e, n);\n    return rv({\n      isSingle: v,\n      modelValue: c,\n      changeModelValue: f,\n      dir: u,\n      orientation: e.orientation,\n      loop: l,\n      rovingFocus: s,\n      disabled: r\n    }), (p, g) => (b(), S(Xe(o(s) ? o(Ft) : o(O)), {\n      \"as-child\": \"\",\n      orientation: o(s) ? p.orientation : void 0,\n      dir: o(u),\n      loop: o(s) ? o(l) : void 0\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(d),\n          role: \"group\",\n          \"as-child\": p.asChild,\n          as: p.as\n        }, {\n          default: y(() => [\n            w(p.$slots, \"default\", { modelValue: o(c) })\n          ]),\n          _: 3\n        }, 8, [\"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), uv = /* @__PURE__ */ x({\n  __name: \"ToggleGroupItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = sv(), n = B(() => {\n      var i;\n      return ((i = e.disabled) == null ? void 0 : i.value) || t.disabled;\n    }), l = B(() => {\n      var i;\n      return (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);\n    }), s = B(() => {\n      var i;\n      return e.isSingle.value ? e.modelValue.value === t.value : (i = e.modelValue.value) == null ? void 0 : i.includes(t.value);\n    }), { forwardRef: r } = R();\n    return (i, u) => (b(), S(Xe(o(e).rovingFocus.value ? o(Nt) : o(O)), {\n      \"as-child\": \"\",\n      focusable: !n.value,\n      active: l.value\n    }, {\n      default: y(() => [\n        q(o(lv), k(t, {\n          ref: o(r),\n          disabled: n.value,\n          pressed: s.value,\n          \"onUpdate:pressed\": u[0] || (u[0] = (d) => o(e).changeModelValue(i.value))\n        }), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"disabled\", \"pressed\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\", \"active\"]));\n  }\n}), [pr, dv] = te(\"ToolbarRoot\"), Fg = /* @__PURE__ */ x({\n  __name: \"ToolbarRoot\",\n  props: {\n    orientation: { default: \"horizontal\" },\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { orientation: e, dir: n } = ae(t), l = we(n), { forwardRef: s } = R();\n    return dv({ orientation: e, dir: l }), (r, i) => (b(), S(o(Ft), {\n      \"as-child\": \"\",\n      orientation: o(e),\n      dir: o(l),\n      loop: r.loop\n    }, {\n      default: y(() => [\n        q(o(O), {\n          ref: o(s),\n          role: \"toolbar\",\n          \"aria-orientation\": o(e),\n          \"as-child\": r.asChild,\n          as: r.as\n        }, {\n          default: y(() => [\n            w(r.$slots, \"default\")\n          ]),\n          _: 3\n        }, 8, [\"aria-orientation\", \"as-child\", \"as\"])\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"dir\", \"loop\"]));\n  }\n}), cv = /* @__PURE__ */ x({\n  __name: \"ToolbarButton\",\n  props: {\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R();\n    return (n, l) => (b(), S(o(Nt), {\n      \"as-child\": \"\",\n      focusable: !n.disabled\n    }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(e),\n          type: n.as === \"button\" ? \"button\" : void 0\n        }, t), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"type\"])\n      ]),\n      _: 3\n    }, 8, [\"focusable\"]));\n  }\n}), Ng = /* @__PURE__ */ x({\n  __name: \"ToolbarLink\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"a\" }\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R();\n    return (n, l) => (b(), S(o(Nt), {\n      \"as-child\": \"\",\n      focusable: \"\"\n    }, {\n      default: y(() => [\n        q(o(O), k(t, {\n          ref: o(e),\n          onKeydown: l[0] || (l[0] = (s) => {\n            var r;\n            s.key === \" \" && ((r = s.currentTarget) == null || r.click());\n          })\n        }), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Lg = /* @__PURE__ */ x({\n  __name: \"ToolbarToggleGroup\",\n  props: {\n    rovingFocus: { type: Boolean },\n    disabled: { type: Boolean },\n    orientation: {},\n    dir: {},\n    loop: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {},\n    type: {},\n    modelValue: {},\n    defaultValue: {}\n  },\n  emits: [\"update:modelValue\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = pr(), s = Te(n);\n    return R(), (r, i) => (b(), S(o(iv), k({ ...e, ...o(s) }, {\n      \"data-orientation\": o(l).orientation.value,\n      dir: o(l).dir.value,\n      \"roving-focus\": !1\n    }), {\n      default: y(() => [\n        w(r.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16, [\"data-orientation\", \"dir\"]));\n  }\n}), zg = /* @__PURE__ */ x({\n  __name: \"ToolbarToggleItem\",\n  props: {\n    value: {},\n    disabled: { type: Boolean },\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R();\n    return (n, l) => (b(), S(cv, { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(uv), k(t, { ref: o(e) }), {\n          default: y(() => [\n            w(n.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16)\n      ]),\n      _: 3\n    }));\n  }\n}), Kg = /* @__PURE__ */ x({\n  __name: \"ToolbarSeparator\",\n  props: {\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, e = pr();\n    return R(), (n, l) => (b(), S(Ms, {\n      orientation: o(e).orientation.value,\n      \"as-child\": t.asChild,\n      as: n.as\n    }, {\n      default: y(() => [\n        w(n.$slots, \"default\")\n      ]),\n      _: 3\n    }, 8, [\"orientation\", \"as-child\", \"as\"]));\n  }\n}), vr = \"tooltip.open\", [Mo, fv] = te(\"TooltipProvider\"), Hg = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"TooltipProvider\",\n  props: {\n    delayDuration: { default: 700 },\n    skipDelayDuration: { default: 300 },\n    disableHoverableContent: { type: Boolean, default: !1 },\n    disableClosingTrigger: { type: Boolean },\n    disabled: { type: Boolean },\n    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }\n  },\n  setup(a) {\n    const t = a, { delayDuration: e, skipDelayDuration: n, disableHoverableContent: l, disableClosingTrigger: s, ignoreNonKeyboardFocus: r, disabled: i } = ae(t);\n    R();\n    const u = T(!0), d = T(!1), { start: c, stop: f } = Un(() => {\n      u.value = !0;\n    }, n, { immediate: !1 });\n    return fv({\n      isOpenDelayed: u,\n      delayDuration: e,\n      onOpen() {\n        f(), u.value = !1;\n      },\n      onClose() {\n        c();\n      },\n      isPointerInTransitRef: d,\n      disableHoverableContent: l,\n      disableClosingTrigger: s,\n      disabled: i,\n      ignoreNonKeyboardFocus: r\n    }), (v, p) => w(v.$slots, \"default\");\n  }\n}), [yn, pv] = te(\"TooltipRoot\"), Wg = /* @__PURE__ */ x({\n  __name: \"TooltipRoot\",\n  props: {\n    defaultOpen: { type: Boolean, default: !1 },\n    open: { type: Boolean, default: void 0 },\n    delayDuration: { default: void 0 },\n    disableHoverableContent: { type: Boolean, default: void 0 },\n    disableClosingTrigger: { type: Boolean, default: void 0 },\n    disabled: { type: Boolean, default: void 0 },\n    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }\n  },\n  emits: [\"update:open\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t;\n    R();\n    const l = Mo(), s = B(() => e.disableHoverableContent ?? l.disableHoverableContent.value), r = B(() => e.disableClosingTrigger ?? l.disableClosingTrigger.value), i = B(() => e.disabled ?? l.disabled.value), u = B(() => e.delayDuration ?? l.delayDuration.value), d = B(() => e.ignoreNonKeyboardFocus ?? l.ignoreNonKeyboardFocus.value), c = ne(e, \"open\", n, {\n      defaultValue: e.defaultOpen,\n      passive: e.open === void 0\n    });\n    ee(c, (h) => {\n      l.onClose && (h ? (l.onOpen(), document.dispatchEvent(new CustomEvent(vr))) : l.onClose());\n    });\n    const f = T(!1), v = T(), p = B(() => c.value ? f.value ? \"delayed-open\" : \"instant-open\" : \"closed\"), { start: g, stop: m } = Un(() => {\n      f.value = !0, c.value = !0;\n    }, u, { immediate: !1 });\n    function _() {\n      m(), f.value = !1, c.value = !0;\n    }\n    function C() {\n      m(), c.value = !1;\n    }\n    function $() {\n      g();\n    }\n    return pv({\n      contentId: \"\",\n      open: c,\n      stateAttribute: p,\n      trigger: v,\n      onTriggerChange(h) {\n        v.value = h;\n      },\n      onTriggerEnter() {\n        l.isOpenDelayed.value ? $() : _();\n      },\n      onTriggerLeave() {\n        s.value ? C() : m();\n      },\n      onOpen: _,\n      onClose: C,\n      disableHoverableContent: s,\n      disableClosingTrigger: r,\n      disabled: i,\n      ignoreNonKeyboardFocus: d\n    }), (h, E) => (b(), S(o(kt), null, {\n      default: y(() => [\n        w(h.$slots, \"default\", { open: o(c) })\n      ]),\n      _: 3\n    }));\n  }\n}), jg = /* @__PURE__ */ x({\n  __name: \"TooltipTrigger\",\n  props: {\n    asChild: { type: Boolean },\n    as: { default: \"button\" }\n  },\n  setup(a) {\n    const t = a, e = yn(), n = Mo();\n    e.contentId || (e.contentId = ge(void 0, \"radix-vue-tooltip-content\"));\n    const { forwardRef: l, currentElement: s } = R(), r = T(!1), i = T(!1), u = B(() => e.disabled.value ? {} : {\n      click: m,\n      focus: p,\n      pointermove: f,\n      pointerleave: v,\n      pointerdown: c,\n      blur: g\n    });\n    le(() => {\n      e.onTriggerChange(s.value);\n    });\n    function d() {\n      setTimeout(() => {\n        r.value = !1;\n      }, 1);\n    }\n    function c() {\n      r.value = !0, document.addEventListener(\"pointerup\", d, { once: !0 });\n    }\n    function f(_) {\n      _.pointerType !== \"touch\" && !i.value && !n.isPointerInTransitRef.value && (e.onTriggerEnter(), i.value = !0);\n    }\n    function v() {\n      e.onTriggerLeave(), i.value = !1;\n    }\n    function p(_) {\n      var C, $;\n      r.value || e.ignoreNonKeyboardFocus.value && !(($ = (C = _.target).matches) != null && $.call(C, \":focus-visible\")) || e.onOpen();\n    }\n    function g() {\n      e.onClose();\n    }\n    function m() {\n      e.disableClosingTrigger.value || e.onClose();\n    }\n    return (_, C) => (b(), S(o(Mt), { \"as-child\": \"\" }, {\n      default: y(() => [\n        q(o(O), k({\n          ref: o(l),\n          \"aria-describedby\": o(e).open.value ? o(e).contentId : void 0,\n          \"data-state\": o(e).stateAttribute.value,\n          as: _.as,\n          \"as-child\": t.asChild,\n          \"data-grace-area-trigger\": \"\"\n        }, Kn(u.value)), {\n          default: y(() => [\n            w(_.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16, [\"aria-describedby\", \"data-state\", \"as\", \"as-child\"])\n      ]),\n      _: 3\n    }));\n  }\n}), mr = /* @__PURE__ */ x({\n  __name: \"TooltipContentImpl\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: { default: 0 },\n    align: { default: \"center\" },\n    alignOffset: {},\n    avoidCollisions: { type: Boolean, default: !0 },\n    collisionBoundary: { default: () => [] },\n    collisionPadding: { default: 0 },\n    arrowPadding: { default: 0 },\n    sticky: { default: \"partial\" },\n    hideWhenDetached: { type: Boolean, default: !1 }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = yn(), { forwardRef: s } = R(), r = Ua(), i = B(() => {\n      var c;\n      return (c = r.default) == null ? void 0 : c.call(r);\n    }), u = B(() => {\n      var v;\n      if (e.ariaLabel)\n        return e.ariaLabel;\n      let c = \"\";\n      function f(p) {\n        typeof p.children == \"string\" && p.type !== hl ? c += p.children : Array.isArray(p.children) && p.children.forEach((g) => f(g));\n      }\n      return (v = i.value) == null || v.forEach((p) => f(p)), c;\n    }), d = B(() => {\n      const { ariaLabel: c, ...f } = e;\n      return f;\n    });\n    return le(() => {\n      He(window, \"scroll\", (c) => {\n        const f = c.target;\n        f != null && f.contains(l.trigger.value) && l.onClose();\n      }), He(window, vr, l.onClose);\n    }), (c, f) => (b(), S(o(Ct), {\n      \"as-child\": \"\",\n      \"disable-outside-pointer-events\": !1,\n      onEscapeKeyDown: f[0] || (f[0] = (v) => n(\"escapeKeyDown\", v)),\n      onPointerDownOutside: f[1] || (f[1] = (v) => {\n        var p;\n        o(l).disableClosingTrigger.value && ((p = o(l).trigger.value) != null && p.contains(v.target)) && v.preventDefault(), n(\"pointerDownOutside\", v);\n      }),\n      onFocusOutside: f[2] || (f[2] = ue(() => {\n      }, [\"prevent\"])),\n      onDismiss: f[3] || (f[3] = (v) => o(l).onClose())\n    }, {\n      default: y(() => [\n        q(o(It), k({\n          ref: o(s),\n          \"data-state\": o(l).stateAttribute.value\n        }, { ...c.$attrs, ...d.value }, { style: {\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        } }), {\n          default: y(() => [\n            w(c.$slots, \"default\"),\n            q(o(Jt), {\n              id: o(l).contentId,\n              role: \"tooltip\"\n            }, {\n              default: y(() => [\n                ye(De(u.value), 1)\n              ]),\n              _: 1\n            }, 8, [\"id\"])\n          ]),\n          _: 3\n        }, 16, [\"data-state\"])\n      ]),\n      _: 3\n    }));\n  }\n}), vv = /* @__PURE__ */ x({\n  __name: \"TooltipContentHoverable\",\n  props: {\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: {},\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  setup(a) {\n    const e = Ot(a), { forwardRef: n, currentElement: l } = R(), { trigger: s, onClose: r } = yn(), i = Mo(), { isPointerInTransit: u, onPointerExit: d } = Fl(s, l);\n    return i.isPointerInTransitRef = u, d(() => {\n      r();\n    }), (c, f) => (b(), S(mr, k({ ref: o(n) }, o(e)), {\n      default: y(() => [\n        w(c.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), Ug = /* @__PURE__ */ x({\n  __name: \"TooltipContent\",\n  props: {\n    forceMount: { type: Boolean },\n    ariaLabel: {},\n    asChild: { type: Boolean },\n    as: {},\n    side: { default: \"top\" },\n    sideOffset: {},\n    align: {},\n    alignOffset: {},\n    avoidCollisions: { type: Boolean },\n    collisionBoundary: {},\n    collisionPadding: {},\n    arrowPadding: {},\n    sticky: {},\n    hideWhenDetached: { type: Boolean }\n  },\n  emits: [\"escapeKeyDown\", \"pointerDownOutside\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, l = yn(), s = Se(e, n), { forwardRef: r } = R();\n    return (i, u) => (b(), S(o(Pe), {\n      present: i.forceMount || o(l).open.value\n    }, {\n      default: y(() => [\n        (b(), S(Xe(o(l).disableHoverableContent.value ? mr : vv), k({ ref: o(r) }, o(s)), {\n          default: y(() => [\n            w(i.$slots, \"default\")\n          ]),\n          _: 3\n        }, 16))\n      ]),\n      _: 3\n    }, 8, [\"present\"]));\n  }\n}), Gg = /* @__PURE__ */ x({\n  __name: \"TooltipArrow\",\n  props: {\n    width: { default: 10 },\n    height: { default: 5 },\n    asChild: { type: Boolean },\n    as: { default: \"svg\" }\n  },\n  setup(a) {\n    const t = a;\n    return R(), (e, n) => (b(), S(o(Zt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n}), qg = /* @__PURE__ */ x({\n  __name: \"TooltipPortal\",\n  props: {\n    to: {},\n    disabled: { type: Boolean },\n    forceMount: { type: Boolean }\n  },\n  setup(a) {\n    const t = a;\n    return (e, n) => (b(), S(o(rt), W(U(t)), {\n      default: y(() => [\n        w(e.$slots, \"default\")\n      ]),\n      _: 3\n    }, 16));\n  }\n});\nfunction Vo(a) {\n  return a.reduce((t, e) => (t.push(e), e.children && t.push(...Vo(e.children)), t), []);\n}\nconst [hr, mv] = te(\"TreeRoot\"), Yg = /* @__PURE__ */ x({\n  __name: \"TreeRoot\",\n  props: {\n    modelValue: {},\n    defaultValue: {},\n    items: {},\n    expanded: {},\n    defaultExpanded: {},\n    getKey: {},\n    getChildren: { type: Function, default: (a) => a.children },\n    selectionBehavior: { default: \"toggle\" },\n    multiple: { type: Boolean },\n    dir: {},\n    disabled: { type: Boolean },\n    propagateSelect: { type: Boolean },\n    asChild: { type: Boolean },\n    as: { default: \"ul\" }\n  },\n  emits: [\"update:modelValue\", \"update:expanded\"],\n  setup(a, { emit: t }) {\n    const e = a, n = t, { items: l, multiple: s, disabled: r, propagateSelect: i, dir: u } = ae(e), { handleTypeaheadSearch: d } = ba(), c = we(u), f = T(), v = T(!1), p = ua(), g = ne(e, \"modelValue\", n, {\n      // @ts-expect-error idk\n      defaultValue: e.defaultValue ?? (s.value ? [] : void 0),\n      passive: e.modelValue === void 0,\n      deep: !0\n    }), m = ne(e, \"expanded\", n, {\n      // @ts-expect-error idk\n      defaultValue: e.defaultExpanded ?? [],\n      passive: e.expanded === void 0,\n      deep: !0\n    }), { onSelectItem: _, handleMultipleReplace: C } = ji(g, e), $ = B(() => s.value && Array.isArray(g.value) ? g.value.map((I) => e.getKey(I)) : [e.getKey(g.value ?? {})]);\n    function h(I, M = 1, V) {\n      return I.reduce((A, F, j) => {\n        const H = e.getKey(F), Q = e.getChildren(F), G = m.value.includes(H), J = {\n          _id: H,\n          value: F,\n          index: j,\n          level: M,\n          parentItem: V,\n          hasChildren: !!Q,\n          bind: {\n            value: F,\n            level: M,\n            \"aria-setsize\": I.length,\n            \"aria-posinset\": j + 1\n          }\n        };\n        return A.push(J), Q && G && A.push(...h(Q, M + 1, F)), A;\n      }, []);\n    }\n    const E = B(() => {\n      const I = e.items;\n      return m.value.map((M) => M), h(I ?? []);\n    });\n    function P(I) {\n      var M;\n      if (v.value)\n        p.trigger(I);\n      else {\n        const V = (M = f.value) == null ? void 0 : M.getItems().map((A) => A.ref);\n        d(I.key, V);\n      }\n    }\n    function D(I) {\n      if (v.value)\n        return;\n      const M = en[I.key];\n      oe(() => {\n        var V;\n        C(\n          M,\n          me(),\n          (V = f.value) == null ? void 0 : V.getItems,\n          E.value.map((A) => A.value)\n        );\n      });\n    }\n    return mv({\n      modelValue: g,\n      selectedKeys: $,\n      onSelect: (I) => {\n        var A;\n        const M = (F) => e.getKey(F ?? {}) === e.getKey(I), V = e.multiple && Array.isArray(g.value) ? ((A = g.value) == null ? void 0 : A.findIndex(M)) !== -1 : void 0;\n        if (_(I, M), e.propagateSelect && e.multiple && Array.isArray(g.value)) {\n          const F = Vo(e.getChildren(I) ?? []);\n          V ? g.value = [...g.value].filter((j) => !F.some((H) => e.getKey(j ?? {}) === e.getKey(H))) : g.value = [...g.value, ...F];\n        }\n      },\n      expanded: m,\n      onToggle(I) {\n        if (!(I ? e.getChildren(I) : void 0))\n          return;\n        const V = e.getKey(I) ?? I;\n        m.value.includes(V) ? m.value = m.value.filter((A) => A !== V) : m.value.push(V);\n      },\n      getKey: e.getKey,\n      getChildren: e.getChildren,\n      items: l,\n      expandedItems: E,\n      disabled: r,\n      multiple: s,\n      dir: c,\n      propagateSelect: i,\n      isVirtual: v,\n      virtualKeydownHook: p,\n      handleMultipleReplace: C\n    }), (I, M) => (b(), S(o(Ft), {\n      ref_key: \"rovingFocusGroupRef\",\n      ref: f,\n      \"as-child\": \"\",\n      orientation: \"vertical\",\n      dir: o(c)\n    }, {\n      default: y(() => [\n        q(o(O), {\n          role: \"tree\",\n          as: I.as,\n          \"as-child\": I.asChild,\n          \"aria-multiselectable\": o(s) ? !0 : void 0,\n          onKeydown: [\n            P,\n            ie(ue(D, [\"shift\"]), [\"up\", \"down\"])\n          ]\n        }, {\n          default: y(() => [\n            w(I.$slots, \"default\", {\n              flattenItems: E.value,\n              modelValue: o(g),\n              expanded: o(m)\n            })\n          ]),\n          _: 3\n        }, 8, [\"as\", \"as-child\", \"aria-multiselectable\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"dir\"]));\n  }\n}), hv = \"tree.select\", yv = \"tree.toggle\", Xg = /* @__PURE__ */ x({\n  inheritAttrs: !1,\n  __name: \"TreeItem\",\n  props: {\n    value: {},\n    level: {},\n    asChild: { type: Boolean },\n    as: { default: \"li\" }\n  },\n  emits: [\"select\", \"toggle\"],\n  setup(a, { expose: t, emit: e }) {\n    const n = a, l = e, s = hr(), { getItems: r } = ea(), i = B(() => !!s.getChildren(n.value)), u = B(() => {\n      const C = s.getKey(n.value);\n      return s.expanded.value.includes(C);\n    }), d = B(() => {\n      const C = s.getKey(n.value);\n      return s.selectedKeys.value.includes(C);\n    }), c = B(() => {\n      if (s.propagateSelect.value && d.value && i.value && Array.isArray(s.modelValue.value))\n        return !Vo(s.getChildren(n.value) || []).every(($) => s.modelValue.value.find((h) => s.getKey(h) === s.getKey($)));\n    });\n    function f(C) {\n      if (i.value)\n        if (u.value) {\n          const $ = r().map((I) => I.ref), h = me(), E = $.indexOf(h), D = [...$].slice(E).find((I) => Number(I.getAttribute(\"data-indent\")) === n.level + 1);\n          D && D.focus();\n        } else\n          _(C);\n    }\n    function v(C) {\n      if (u.value)\n        _(C);\n      else {\n        const $ = r().map((I) => I.ref), h = me(), E = $.indexOf(h), D = [...$].slice(0, E).reverse().find((I) => Number(I.getAttribute(\"data-indent\")) === n.level - 1);\n        D && D.focus();\n      }\n    }\n    async function p(C) {\n      l(\"select\", C), !(C != null && C.defaultPrevented) && s.onSelect(n.value);\n    }\n    async function g(C) {\n      l(\"toggle\", C), !(C != null && C.defaultPrevented) && s.onToggle(n.value);\n    }\n    async function m(C) {\n      if (!C)\n        return;\n      const $ = { originalEvent: C, value: n.value, isExpanded: u.value, isSelected: d.value };\n      jt(hv, p, $);\n    }\n    async function _(C) {\n      if (!C)\n        return;\n      const $ = { originalEvent: C, value: n.value, isExpanded: u.value, isSelected: d.value };\n      jt(yv, g, $);\n    }\n    return t({\n      isExpanded: u,\n      isSelected: d,\n      isIndeterminate: c,\n      handleToggle: () => s.onToggle(n.value),\n      handleSelect: () => s.onSelect(n.value)\n    }), (C, $) => (b(), S(o(Nt), {\n      \"as-child\": \"\",\n      value: C.value,\n      \"allow-shift-key\": \"\"\n    }, {\n      default: y(() => [\n        q(o(O), k(C.$attrs, {\n          role: \"treeitem\",\n          as: C.as,\n          \"as-child\": C.asChild,\n          \"aria-selected\": d.value,\n          \"aria-expanded\": i.value ? u.value : void 0,\n          \"aria-level\": C.level,\n          \"data-indent\": C.level,\n          \"data-selected\": d.value ? \"\" : void 0,\n          \"data-expanded\": u.value ? \"\" : void 0,\n          onKeydown: [\n            ie(ue(m, [\"self\", \"prevent\"]), [\"enter\", \"space\"]),\n            $[0] || ($[0] = ie(ue((h) => o(s).dir.value === \"ltr\" ? f(h) : v(h), [\"prevent\"]), [\"right\"])),\n            $[1] || ($[1] = ie(ue((h) => o(s).dir.value === \"ltr\" ? v(h) : f(h), [\"prevent\"]), [\"left\"]))\n          ],\n          onClick: $[2] || ($[2] = ue((h) => {\n            m(h), _(h);\n          }, [\"stop\"]))\n        }), {\n          default: y(() => [\n            w(C.$slots, \"default\", {\n              isExpanded: u.value,\n              isSelected: d.value,\n              isIndeterminate: c.value,\n              handleSelect: () => o(s).onSelect(C.value),\n              handleToggle: () => o(s).onToggle(C.value)\n            })\n          ]),\n          _: 3\n        }, 16, [\"as\", \"as-child\", \"aria-selected\", \"aria-expanded\", \"aria-level\", \"data-indent\", \"data-selected\", \"data-expanded\", \"onKeydown\"])\n      ]),\n      _: 3\n    }, 8, [\"value\"]));\n  }\n}), Zg = /* @__PURE__ */ x({\n  __name: \"TreeVirtualizer\",\n  props: {\n    estimateSize: {},\n    textContent: { type: Function }\n  },\n  setup(a) {\n    const t = a, e = Ua(), n = hr(), l = kl(), { getItems: s } = ea(), r = Tt(\"\", 1e3), i = B(() => {\n      const v = (p) => t.textContent ? t.textContent(p) : p.toString().toLowerCase();\n      return n.expandedItems.value.map((p, g) => ({\n        index: g,\n        textContent: v(p.value)\n      }));\n    });\n    n.isVirtual.value = !0;\n    const u = B(() => {\n      const v = l.value;\n      if (v) {\n        const p = window.getComputedStyle(v);\n        return {\n          start: Number.parseFloat(p.paddingBlockStart || p.paddingTop),\n          end: Number.parseFloat(p.paddingBlockEnd || p.paddingBottom)\n        };\n      } else\n        return { start: 0, end: 0 };\n    }), d = vs(\n      {\n        get scrollPaddingStart() {\n          return u.value.start;\n        },\n        get scrollPaddingEnd() {\n          return u.value.end;\n        },\n        get count() {\n          return n.expandedItems.value.length ?? 0;\n        },\n        get horizontal() {\n          return !1;\n        },\n        getItemKey(v) {\n          return v + n.getKey(n.expandedItems.value[v].value);\n        },\n        estimateSize() {\n          return t.estimateSize ?? 28;\n        },\n        getScrollElement() {\n          return l.value;\n        },\n        overscan: 12\n      }\n    ), c = B(() => d.value.getVirtualItems().map((v) => ({\n      item: v,\n      is: Ln(e.default({\n        item: n.expandedItems.value[v.index],\n        virtualizer: d.value,\n        virtualItem: v\n      })[0], {\n        \"data-index\": v.index,\n        style: {\n          position: \"absolute\",\n          top: 0,\n          left: 0,\n          transform: `translateY(${v.start}px)`,\n          overflowAnchor: \"none\"\n        }\n      })\n    })));\n    function f(v) {\n      d.value.scrollToIndex(v, { align: \"start\" }), requestAnimationFrame(() => {\n        const p = l.value.querySelector(`[data-index=\"${v}\"]`);\n        p instanceof HTMLElement && p.focus();\n      });\n    }\n    return n.virtualKeydownHook.on((v) => {\n      var _;\n      const p = v.altKey || v.ctrlKey || v.metaKey;\n      if (v.key === \"Tab\" && !p)\n        return;\n      const m = en[v.key];\n      if ([\"first\", \"last\"].includes(m)) {\n        v.preventDefault();\n        const C = m === \"first\" ? 0 : n.expandedItems.value.length - 1;\n        d.value.scrollToIndex(C), requestAnimationFrame(() => {\n          const $ = s();\n          (m === \"first\" ? $[0] : $[$.length - 1]).ref.focus();\n        });\n      } else if (m === \"prev\" && v.key !== \"ArrowUp\") {\n        const C = me(), $ = Number(C.getAttribute(\"data-index\")), h = Number(C.getAttribute(\"data-indent\")), P = n.expandedItems.value.slice(0, $).map((D, I) => ({ ...D, index: I })).reverse().find((D) => D.level === h - 1);\n        P && f(P.index);\n      } else if (!m && !p) {\n        r.value += v.key;\n        const C = Number((_ = me()) == null ? void 0 : _.getAttribute(\"data-index\")), $ = i.value[C].textContent, h = i.value.map((D) => D.textContent), E = Zn(h, r.value, $), P = i.value.find((D) => D.textContent === E);\n        P && f(P.index);\n      }\n      oe(() => {\n        v.shiftKey && m && n.handleMultipleReplace(m, me(), s, n.expandedItems.value.map((C) => C.value));\n      });\n    }), (v, p) => (b(), ve(\"div\", {\n      \"data-radix-vue-virtualizer\": \"\",\n      style: Me({\n        position: \"relative\",\n        width: \"100%\",\n        height: `${o(d).getTotalSize()}px`\n      })\n    }, [\n      (b(!0), ve(_e, null, ma(c.value, ({ is: g, item: m }) => (b(), S(Xe(g), {\n        key: m.key\n      }))), 128))\n    ], 4));\n  }\n}), Jg = /* @__PURE__ */ x({\n  __name: \"Viewport\",\n  props: {\n    nonce: {},\n    asChild: { type: Boolean },\n    as: {}\n  },\n  setup(a) {\n    const t = a, { forwardRef: e } = R(), { nonce: n } = ae(t), l = Ja(n);\n    return (s, r) => (b(), ve(_e, null, [\n      q(o(O), k({ ...s.$attrs, ...t }, {\n        ref: o(e),\n        \"data-radix-viewport\": \"\",\n        role: \"presentation\",\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          overflow: \"auto\"\n        }\n      }), {\n        default: y(() => [\n          w(s.$slots, \"default\")\n        ]),\n        _: 3\n      }, 16),\n      q(o(O), {\n        as: \"style\",\n        nonce: o(l)\n      }, {\n        default: y(() => [\n          ye(\" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-radix-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-radix-viewport]::-webkit-scrollbar { display: none; } \")\n        ]),\n        _: 1\n      }, 8, [\"nonce\"])\n    ], 64));\n  }\n});\nexport {\n  Dv as AccordionContent,\n  $v as AccordionHeader,\n  Pv as AccordionItem,\n  Ev as AccordionRoot,\n  Bv as AccordionTrigger,\n  Nv as AlertDialogAction,\n  Mv as AlertDialogCancel,\n  Ov as AlertDialogContent,\n  Fv as AlertDialogDescription,\n  kv as AlertDialogOverlay,\n  Av as AlertDialogPortal,\n  Tv as AlertDialogRoot,\n  Vv as AlertDialogTitle,\n  Rv as AlertDialogTrigger,\n  Lv as AspectRatio,\n  Hv as AvatarFallback,\n  Kv as AvatarImage,\n  zv as AvatarRoot,\n  Gu as CalendarCell,\n  ed as CalendarCellTrigger,\n  Uu as CalendarGrid,\n  Ju as CalendarGridBody,\n  Zu as CalendarGridHead,\n  Qu as CalendarGridRow,\n  qu as CalendarHeadCell,\n  Wu as CalendarHeader,\n  ju as CalendarHeading,\n  Yu as CalendarNext,\n  Xu as CalendarPrev,\n  Hu as CalendarRoot,\n  jv as CheckboxIndicator,\n  Wv as CheckboxRoot,\n  Zi as CollapsibleContent,\n  qi as CollapsibleRoot,\n  Yi as CollapsibleTrigger,\n  qv as ComboboxAnchor,\n  lm as ComboboxArrow,\n  Xv as ComboboxCancel,\n  Qv as ComboboxContent,\n  em as ComboboxEmpty,\n  Zv as ComboboxGroup,\n  Gv as ComboboxInput,\n  am as ComboboxItem,\n  nm as ComboboxItemIndicator,\n  Jv as ComboboxLabel,\n  sm as ComboboxPortal,\n  Uv as ComboboxRoot,\n  om as ComboboxSeparator,\n  Yv as ComboboxTrigger,\n  tm as ComboboxViewport,\n  xv as ConfigProvider,\n  cm as ContextMenuArrow,\n  mm as ContextMenuCheckboxItem,\n  dm as ContextMenuContent,\n  pm as ContextMenuGroup,\n  fm as ContextMenuItem,\n  hm as ContextMenuItemIndicator,\n  ym as ContextMenuLabel,\n  um as ContextMenuPortal,\n  gm as ContextMenuRadioGroup,\n  bm as ContextMenuRadioItem,\n  rm as ContextMenuRoot,\n  vm as ContextMenuSeparator,\n  Cm as ContextMenuSub,\n  wm as ContextMenuSubContent,\n  _m as ContextMenuSubTrigger,\n  im as ContextMenuTrigger,\n  nc as DateFieldInput,\n  jd as DateFieldRoot,\n  Fm as DatePickerAnchor,\n  Nm as DatePickerArrow,\n  Mm as DatePickerCalendar,\n  Pm as DatePickerCell,\n  Am as DatePickerCellTrigger,\n  Lm as DatePickerClose,\n  Km as DatePickerContent,\n  Vm as DatePickerField,\n  Em as DatePickerGrid,\n  Tm as DatePickerGridBody,\n  Im as DatePickerGridHead,\n  Rm as DatePickerGridRow,\n  Dm as DatePickerHeadCell,\n  xm as DatePickerHeader,\n  Sm as DatePickerHeading,\n  Om as DatePickerInput,\n  $m as DatePickerNext,\n  Bm as DatePickerPrev,\n  km as DatePickerRoot,\n  zm as DatePickerTrigger,\n  dc as DateRangeFieldInput,\n  uc as DateRangeFieldRoot,\n  oh as DateRangePickerAnchor,\n  lh as DateRangePickerArrow,\n  ah as DateRangePickerCalendar,\n  Um as DateRangePickerCell,\n  Qm as DateRangePickerCellTrigger,\n  sh as DateRangePickerClose,\n  ih as DateRangePickerContent,\n  nh as DateRangePickerField,\n  jm as DateRangePickerGrid,\n  Zm as DateRangePickerGridBody,\n  Xm as DateRangePickerGridHead,\n  Jm as DateRangePickerGridRow,\n  Gm as DateRangePickerHeadCell,\n  Hm as DateRangePickerHeader,\n  Wm as DateRangePickerHeading,\n  eh as DateRangePickerInput,\n  qm as DateRangePickerNext,\n  Ym as DateRangePickerPrev,\n  th as DateRangePickerRoot,\n  rh as DateRangePickerTrigger,\n  Xl as DialogClose,\n  Pu as DialogContent,\n  Iu as DialogDescription,\n  $u as DialogOverlay,\n  Iv as DialogPortal,\n  nu as DialogRoot,\n  Bu as DialogTitle,\n  ou as DialogTrigger,\n  ph as DropdownMenuArrow,\n  yh as DropdownMenuCheckboxItem,\n  fh as DropdownMenuContent,\n  mh as DropdownMenuGroup,\n  vh as DropdownMenuItem,\n  gh as DropdownMenuItemIndicator,\n  bh as DropdownMenuLabel,\n  ch as DropdownMenuPortal,\n  Ch as DropdownMenuRadioGroup,\n  wh as DropdownMenuRadioItem,\n  uh as DropdownMenuRoot,\n  hh as DropdownMenuSeparator,\n  _h as DropdownMenuSub,\n  xh as DropdownMenuSubContent,\n  Sh as DropdownMenuSubTrigger,\n  dh as DropdownMenuTrigger,\n  Ph as EditableArea,\n  Ih as EditableCancelTrigger,\n  Th as EditableEditTrigger,\n  Dh as EditableInput,\n  $h as EditablePreview,\n  Eh as EditableRoot,\n  Bh as EditableSubmitTrigger,\n  Za as FocusScope,\n  Mh as HoverCardArrow,\n  kh as HoverCardContent,\n  Oh as HoverCardPortal,\n  Rh as HoverCardRoot,\n  Ah as HoverCardTrigger,\n  Vh as Label,\n  Nh as ListboxContent,\n  Lh as ListboxFilter,\n  Wh as ListboxGroup,\n  jh as ListboxGroupLabel,\n  zh as ListboxItem,\n  Kh as ListboxItemIndicator,\n  Fh as ListboxRoot,\n  Hh as ListboxVirtualizer,\n  Zh as MenubarArrow,\n  ty as MenubarCheckboxItem,\n  Xh as MenubarContent,\n  Qh as MenubarGroup,\n  Jh as MenubarItem,\n  ay as MenubarItemIndicator,\n  ny as MenubarLabel,\n  Gh as MenubarMenu,\n  Yh as MenubarPortal,\n  oy as MenubarRadioGroup,\n  ly as MenubarRadioItem,\n  Uh as MenubarRoot,\n  ey as MenubarSeparator,\n  sy as MenubarSub,\n  ry as MenubarSubContent,\n  iy as MenubarSubTrigger,\n  qh as MenubarTrigger,\n  cy as NavigationMenuContent,\n  fy as NavigationMenuIndicator,\n  dy as NavigationMenuItem,\n  py as NavigationMenuLink,\n  vy as NavigationMenuList,\n  uy as NavigationMenuRoot,\n  my as NavigationMenuSub,\n  hy as NavigationMenuTrigger,\n  yy as NavigationMenuViewport,\n  wy as NumberFieldDecrement,\n  Cy as NumberFieldIncrement,\n  by as NumberFieldInput,\n  gy as NumberFieldRoot,\n  xy as PaginationEllipsis,\n  Sy as PaginationFirst,\n  Ey as PaginationLast,\n  Py as PaginationList,\n  Dy as PaginationListItem,\n  $y as PaginationNext,\n  By as PaginationPrev,\n  _y as PaginationRoot,\n  Ty as PinInputInput,\n  Iy as PinInputRoot,\n  Ds as PopoverAnchor,\n  Es as PopoverArrow,\n  Ps as PopoverClose,\n  Ss as PopoverContent,\n  _s as PopoverPortal,\n  Cs as PopoverRoot,\n  ws as PopoverTrigger,\n  O as Primitive,\n  Ay as ProgressIndicator,\n  Ry as ProgressRoot,\n  My as RadioGroupIndicator,\n  ky as RadioGroupItem,\n  Oy as RadioGroupRoot,\n  wf as RangeCalendarCell,\n  $f as RangeCalendarCellTrigger,\n  Cf as RangeCalendarGrid,\n  Pf as RangeCalendarGridBody,\n  Ef as RangeCalendarGridHead,\n  Df as RangeCalendarGridRow,\n  _f as RangeCalendarHeadCell,\n  gf as RangeCalendarHeader,\n  bf as RangeCalendarHeading,\n  xf as RangeCalendarNext,\n  Sf as RangeCalendarPrev,\n  yf as RangeCalendarRoot,\n  zy as ScrollAreaCorner,\n  Vy as ScrollAreaRoot,\n  Ny as ScrollAreaScrollbar,\n  Ly as ScrollAreaThumb,\n  Fy as ScrollAreaViewport,\n  Uy as SelectArrow,\n  jy as SelectContent,\n  Xy as SelectGroup,\n  ng as SelectIcon,\n  qy as SelectItem,\n  Yy as SelectItemIndicator,\n  Jy as SelectItemText,\n  Zy as SelectLabel,\n  Wy as SelectPortal,\n  Ky as SelectRoot,\n  tg as SelectScrollDownButton,\n  eg as SelectScrollUpButton,\n  Gy as SelectSeparator,\n  Hy as SelectTrigger,\n  ag as SelectValue,\n  Qy as SelectViewport,\n  ap as Separator,\n  rg as SliderRange,\n  og as SliderRoot,\n  lg as SliderThumb,\n  sg as SliderTrack,\n  Jn as Slot,\n  ig as SplitterGroup,\n  ug as SplitterPanel,\n  dg as SplitterResizeHandle,\n  vg as StepperDescription,\n  hg as StepperIndicator,\n  fg as StepperItem,\n  cg as StepperRoot,\n  yg as StepperSeparator,\n  mg as StepperTitle,\n  pg as StepperTrigger,\n  gg as SwitchRoot,\n  bg as SwitchThumb,\n  _g as TabsContent,\n  Sg as TabsIndicator,\n  wg as TabsList,\n  Cg as TabsRoot,\n  xg as TabsTrigger,\n  Ig as TagsInputClear,\n  Pg as TagsInputInput,\n  Dg as TagsInputItem,\n  Bg as TagsInputItemDelete,\n  $g as TagsInputItemText,\n  Eg as TagsInputRoot,\n  Og as ToastAction,\n  ov as ToastClose,\n  Vg as ToastDescription,\n  Ag as ToastPortal,\n  Tg as ToastProvider,\n  Rg as ToastRoot,\n  Mg as ToastTitle,\n  kg as ToastViewport,\n  lv as Toggle,\n  uv as ToggleGroupItem,\n  iv as ToggleGroupRoot,\n  cv as ToolbarButton,\n  Ng as ToolbarLink,\n  Fg as ToolbarRoot,\n  Kg as ToolbarSeparator,\n  Lg as ToolbarToggleGroup,\n  zg as ToolbarToggleItem,\n  Gg as TooltipArrow,\n  Ug as TooltipContent,\n  qg as TooltipPortal,\n  Hg as TooltipProvider,\n  Wg as TooltipRoot,\n  jg as TooltipTrigger,\n  Xg as TreeItem,\n  Yg as TreeRoot,\n  Zg as TreeVirtualizer,\n  Jg as Viewport,\n  Jt as VisuallyHidden,\n  te as createContext,\n  ya as useBodyScrollLock,\n  qn as useDateFormatter,\n  Te as useEmitAsProps,\n  R as useForwardExpose,\n  Ot as useForwardProps,\n  Se as useForwardPropsEmits,\n  ge as useId,\n  zl as useStateMachine,\n  Sv as withDefault\n};\n"],"names":["sides","min","max","round","floor","createCoords","v","oppositeSideMap","oppositeAlignmentMap","clamp","start","value","end","evaluate","param","getSide","placement","getAlignment","getOppositeAxis","axis","getAxisLength","yAxisSides","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","length","mainAlignmentSide","getOppositePlacement","getExpandedPlacements","oppositePlacement","getOppositeAlignmentPlacement","lrPlacement","rlPlacement","tbPlacement","btPlacement","getSideList","side","isStart","getOppositeAxisPlacements","flipAlignment","direction","list","expandPaddingObject","padding","getPaddingObject","rectToClientRect","rect","x","y","width","height","computeCoordsFromPlacement","_ref","reference","floating","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","computePosition","config","strategy","middleware","platform","validMiddleware","statefulPlacement","middlewareData","resetCount","i","name","fn","nextX","nextY","data","reset","detectOverflow","state","options","_await$platform$isEle","elements","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","offsetParent","offsetScale","elementClientRect","arrow","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","checkMainAxis","checkCrossAxis","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","detectOverflowOptions","initialSideAxis","isBasePlacement","fallbackPlacements","hasFallbackAxisSideDirection","placements","overflow","overflows","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","d","resetPlacement","a","b","_overflowsData$filter2","currentSideAxis","acc","getSideOffsets","isAnySideFullyClipped","hide","offsets","originSides","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","_middlewareData$offse","diffCoords","shift","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","size","_state$middlewareData","_state$middlewareData2","apply","heightSide","widthSide","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","hasWindow","getNodeName","node","isNode","getWindow","_node$ownerDocument","getDocumentElement","isElement","isHTMLElement","isShadowRoot","invalidOverflowDisplayValues","isOverflowElement","overflowX","overflowY","display","getComputedStyle","tableElements","isTableElement","topLayerSelectors","isTopLayer","selector","transformProperties","willChangeValues","containValues","isContainingBlock","elementOrCss","webkit","isWebKit","css","getContainingBlock","currentNode","getParentNode","isLastTraversableNode","lastTraversableNodeNames","getNodeScroll","result","getNearestOverflowAncestor","parentNode","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","getCssDimensions","getComputedStyle$1","hasOffset","offsetWidth","offsetHeight","shouldFallback","unwrapElement","getScale","domElement","$","noOffsets","getVisualOffsets","shouldAddVisualOffsets","isFixed","floatingOffsetParent","getBoundingClientRect","includeScale","isFixedStrategy","clientRect","scale","visualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","left","top","getWindowScrollBarX","leftScroll","getHTMLOffset","documentElement","scroll","htmlRect","convertOffsetParentRelativeRectToViewportRelativeRect","topLayer","isOffsetParentAnElement","offsetRect","htmlOffset","getClientRects","getDocumentRect","html","body","SCROLLBAR_MAX","getViewportRect","visualViewport","visualViewportBased","windowScrollbarX","doc","bodyStyles","bodyMarginInline","clippingStableScrollbarWidth","absoluteOrFixed","getInnerBoundingClientRect","getClientRectFromClippingAncestor","clippingAncestor","hasFixedPositionAncestor","stopNode","getClippingElementAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingRect","clippingAncestors","firstClippingAncestor","clippingRect","accRect","getDimensions","getRectRelativeToOffsetParent","setLeftRTLScrollbarOffset","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","getOffsetParent","svgOffsetParent","getElementRects","getOffsetParentFn","getDimensionsFn","floatingDimensions","isRTL","rectsAreEqual","observeMove","onMove","io","timeoutId","root","cleanup","_io","refresh","skip","threshold","elementRectForRootMargin","insetTop","insetRight","insetBottom","insetLeft","isFirstUpdate","handleObserve","entries","ratio","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","layoutShift","animationFrame","referenceEl","ancestors","cleanupIo","reobserveFrame","resizeObserver","firstEntry","_resizeObserver","frameId","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","offset$1","shift$1","flip$1","size$1","hide$1","arrow$1","limitShift$1","mergedOptions","platformWithCache","computePosition$1","isComponentPublicInstance","target","toValue","source","unref","args","getDPR","roundByDPR","dpr","useFloating","whileElementsMountedOption","openOption","computed","_toValue","middlewareOption","placementOption","_toValue2","strategyOption","_toValue3","transformOption","_toValue4","referenceElement","floatingElement","ref","shallowRef","isPositioned","floatingStyles","initialStyles","xVal","yVal","whileElementsMountedCleanup","open","position","attach","watch","getCurrentScope","onScopeDispose","shallowReadonly","te","e","n","r","ul","dl","jt","l","jr","Ur","s","Qe","ni","Fn","Ce","Wa","bt","gr","fl","ua","li","pl","Dl","je","o","Je","ri","ui","di","Na","jo","ci","Tl","gt","Tt","cl","hi","Nn","Un","T","u","$e","Rt","He","c","f","ee","g","Ci","Gn","Ga","le","_i","ne","m","_","h","C","E","D","oe","B","qa","_e","me","Cn","$n","Pi","Di","Ya","Bi","Ii","Ti","Ri","ya","Vl","we","Te","Cr","ml","at","Ot","wr","Se","R","Fl","Oi","ki","Mi","Fi","p","Vi","Ni","Li","Kt","$a","Ba","_n","Nl","zi","Ki","Hi","ga","Be","Wi","ge","No.useId","Ll","zl","Jn","hl","k","Ln","O","mt","Re","Xi","P","Ia","Pe","ae","ot","au","nu","w","ou","S","rt","qt","ce","Iv","W","U","lu","su","jl","Ul","Gl","Ge","Fa","Ct","Me","xn","Sn","qo","Ma","pt","iu","eo","Yo","uu","du","cu","fu","Xo","pu","Za","to","Yl","q","Su","Eu","Pu","Du","$u","Xl","Bu","es","od","kt","Mt","ld","sd","Tn","ts","rd","id","It","yl","Mr","Ho","Vr","Fr","Nr","A","F","j","H","Q","G","J","Lr","zr","Or","kr","_r","I","M","ve","Jt","no","ma","fd","oo","pd","Ca","ea","wa","Qt","xr","it","vd","Uv","L","N","Z","Y","re","X","z","K","Gv","Sr","ie","ue","qv","Yv","as","hd","yd","gd","Xe","Qv","em","ye","bd","Cd","wd","am","ja","De","zn","Ed","Pd","en","Dd","os","ls","$d","Bd","Id","Ft","Nt","xp","vn","jp","Cg","wg","ir","ur","_g","xg","vr","Mo","fv","Hg","yn","pv","Wg","jg","Kn","mr","Ua","vv","Ug","qg"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}