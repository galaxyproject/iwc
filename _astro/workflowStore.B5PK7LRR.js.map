{"version":3,"file":"workflowStore.B5PK7LRR.js","sources":["../../node_modules/nanostores/atom/index.js","../../node_modules/nanostores/lifecycle/index.js","../../node_modules/nanostores/computed/index.js","../../src/stores/workflowStore.ts"],"sourcesContent":["import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\n/* @__NO_SIDE_EFFECTS__ */\nexport const atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n","import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = (oldValue, changed) => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed, oldValue })\n      if (!isAborted) return originNotify(oldValue, changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n","import { atom, epoch } from '../atom/index.js'\nimport { onMount } from '../lifecycle/index.js'\n\nlet computedStore = (stores, cb, batched) => {\n  if (!Array.isArray(stores)) stores = [stores]\n\n  let previousArgs\n  let currentEpoch\n  let set = () => {\n    if (currentEpoch === epoch) return\n    currentEpoch = epoch\n    let args = stores.map($store => $store.get())\n    if (!previousArgs || args.some((arg, i) => arg !== previousArgs[i])) {\n      previousArgs = args\n      let value = cb(...args)\n      if (value && value.then && value.t) {\n        value.then(asyncValue => {\n          if (previousArgs === args) {\n            // Prevent a stale set\n            $computed.set(asyncValue)\n          }\n        })\n      } else {\n        $computed.set(value)\n        currentEpoch = epoch\n      }\n    }\n  }\n  let $computed = atom(undefined)\n  let get = $computed.get\n  $computed.get = () => {\n    set()\n    return get()\n  }\n\n  let timer\n  let run = batched\n    ? () => {\n        clearTimeout(timer)\n        timer = setTimeout(set)\n      }\n    : set\n\n  onMount($computed, () => {\n    let unbinds = stores.map($store => $store.listen(run))\n    set()\n    return () => {\n      for (let unbind of unbinds) unbind()\n    }\n  })\n\n  return $computed\n}\n\n/* @__NO_SIDE_EFFECTS__ */\nexport const computed = (stores, fn) => computedStore(stores, fn)\n\n/* @__NO_SIDE_EFFECTS__ */\nexport const batched = (stores, fn) => computedStore(stores, fn, true)\n","import { atom, computed } from \"nanostores\";\nimport type { WorkflowCollection, SearchIndexEntry } from \"../models/workflow\";\n\n// Store for workflow collections\nexport const workflowCollections = atom<WorkflowCollection[]>([]);\n\n// Store for search index (lightweight workflow data, initialized from props at build time)\nexport const searchIndex = atom<SearchIndexEntry[]>([]);\n\n// Selected filters\nexport const selectedFilters = atom<string[]>([]);\n\n// Collection page search query\nexport const collectionSearchQuery = atom<string>(\"\");\n\n// View mode (list or grid)\nexport const viewMode = atom<\"list\" | \"grid\">(\"list\");\n\n// Search query (homepage)\nexport const searchQuery = atom<string>(\"\");\n\n// Computed: is search active?\nexport const isSearchActive = computed(searchQuery, (q) => q.trim().length > 0);\n\n// Computed stores\nexport const allWorkflows = computed(workflowCollections, (collections) => {\n    return collections.flatMap((collection) => collection.workflows);\n});\n\nexport const allCollections = computed(allWorkflows, (workflows) => {\n    return Array.from(new Set(workflows.flatMap((w) => w.collections))).sort();\n});\n\n// Helper functions\nexport function setWorkflowCollections(collections: WorkflowCollection[]) {\n    workflowCollections.set(collections);\n}\n\nexport function toggleFilter(filter: string) {\n    const current = selectedFilters.get();\n    if (current.includes(filter)) {\n        selectedFilters.set([]);\n    } else {\n        selectedFilters.set([filter]);\n    }\n}\n\nexport function setFilterFromUrl() {\n    if (typeof window !== \"undefined\") {\n        const params = new URLSearchParams(window.location.search);\n        const filter = params.get(\"filter\");\n        if (filter) {\n            selectedFilters.set([filter]);\n        }\n    }\n}\n\nexport function setSearchFromUrl() {\n    if (typeof window !== \"undefined\") {\n        const params = new URLSearchParams(window.location.search);\n        const q = params.get(\"q\");\n        if (q) {\n            searchQuery.set(q);\n        }\n    }\n}\n\nexport function updateSearchUrl(query: string) {\n    if (typeof window !== \"undefined\") {\n        const params = new URLSearchParams(window.location.search);\n        if (query.trim()) {\n            params.set(\"q\", query.trim());\n        } else {\n            params.delete(\"q\");\n        }\n        const newUrl = params.toString() ? `?${params.toString()}` : window.location.pathname;\n        window.history.replaceState({}, \"\", newUrl);\n    }\n}\n\nexport function collectionToSlug(collection: string): string {\n    return collection\n        .toLowerCase()\n        .replace(/\\s+/g, \"-\")\n        .replace(/[^a-z0-9-]/g, \"\");\n}\n\n// Computed: all collections from search index\nexport const searchIndexCollections = computed(searchIndex, (entries) => {\n    return Array.from(new Set(entries.flatMap((e) => e.collections))).sort();\n});\n"],"names":["n","listenerQueue","lqIndex","QUEUE_ITEMS_PER_LISTENER","epoch","atom","initialValue","listeners","$atom","listener","index","oldValue","changedKey","runListenerQueue","newValue","unbind","MOUNT","UNMOUNT","REVERT_MUTATION","on","object","eventKey","mutateStore","eventProps","event","l","currentListeners","STORE_UNMOUNT_DELAY","onMount","$store","initialize","payload","destroy","runListeners","originListen","args","originOff","computedStore","stores","cb","batched","previousArgs","currentEpoch","set","arg","i","value","asyncValue","$computed","get","run","unbinds","computed","fn","workflowCollections","searchIndex","selectedFilters","collectionSearchQuery","viewMode","searchQuery","allWorkflows","collections","collection","setWorkflowCollections","toggleFilter","filter","setFilterFromUrl","setSearchFromUrl","q","updateSearchUrl","query","params","newUrl","collectionToSlug"],"mappings":"CAEA,UAAA,CAAA,GAAA,CAAA,IAAA,EAAA,OAAA,OAAA,IAAA,OAAA,OAAA,OAAA,IAAA,OAAA,OAAA,WAAA,IAAA,WAAA,OAAA,KAAA,IAAA,KAAA,CAAA,EAAA,EAAA,eAAA,CAAA,GAAA,0CAAA,EAAA,IAAAA,EAAA,IAAA,EAAA,QAAA,MAAAA,IAAA,EAAA,gBAAA,EAAA,iBAAA,CAAA,EAAA,EAAA,gBAAAA,CAAA,EAAA,uCAAA,EAAA,yBAAA,mDAAA,MAAA,CAAA,CAAA,GAAA,EAAA,IAAIC,EAAgB,CAAA,EAChBC,EAAU,EACd,MAAMC,EAA2B,EAC1B,IAAIC,EAAQ,EAGZ,MAAMC,EAAOC,GAAgB,CAClC,IAAIC,EAAY,CAAA,EACZC,EAAQ,CACV,KAAM,CACJ,OAAKA,EAAM,IACTA,EAAM,OAAO,IAAM,CAAC,CAAC,EAAA,EAEhBA,EAAM,KACf,EACA,GAAI,EACJ,OAAOC,EAAU,CACf,OAAAD,EAAM,GAAKD,EAAU,KAAKE,CAAQ,EAE3B,IAAM,CACX,QACM,EAAIP,EAAUC,EAClB,EAAIF,EAAc,QAGdA,EAAc,CAAC,IAAMQ,EACvBR,EAAc,OAAO,EAAGE,CAAwB,EAEhD,GAAKA,EAIT,IAAIO,EAAQH,EAAU,QAAQE,CAAQ,EAClC,CAACC,IACHH,EAAU,OAAOG,EAAO,CAAC,EACpB,EAAEF,EAAM,MAAU,IAAA,EAE3B,CACF,EACA,OAAOG,EAAUC,EAAY,CAC3BR,IACA,IAAIS,EAAmB,CAACZ,EAAc,OACtC,QAASQ,KAAYF,EACnBN,EAAc,KAAKQ,EAAUD,EAAM,MAAOG,EAAUC,CAAU,EAGhE,GAAIC,EAAkB,CACpB,IACEX,EAAU,EACVA,EAAUD,EAAc,OACxBC,GAAWC,EAEXF,EAAcC,CAAO,EACnBD,EAAcC,EAAU,CAAC,EACzBD,EAAcC,EAAU,CAAC,EACzBD,EAAcC,EAAU,CAAC,CAAA,EAG7BD,EAAc,OAAS,CACzB,CACF,EAGA,KAAM,CAAC,EACP,IAAIa,EAAU,CACZ,IAAIH,EAAWH,EAAM,MACjBG,IAAaG,IACfN,EAAM,MAAQM,EACdN,EAAM,OAAOG,CAAQ,EAEzB,EACA,UAAUF,EAAU,CAClB,IAAIM,EAASP,EAAM,OAAOC,CAAQ,EAClC,OAAAA,EAASD,EAAM,KAAK,EACbO,CACT,EACA,MAAOT,CAAA,EAWT,OAAOE,CACT,ECpFMQ,EAAQ,EACRC,EAAU,EACVC,EAAkB,GAEjB,IAAIC,EAAK,CAACC,EAAQX,EAAUY,EAAUC,KAC3CF,EAAO,OAASA,EAAO,QAAU,CAAA,EAC5BA,EAAO,OAAOC,EAAWH,CAAe,IAC3CE,EAAO,OAAOC,EAAWH,CAAe,EAAII,EAAYC,GAAc,CAEpEH,EAAO,OAAOC,CAAQ,EAAE,YAAY,CAACG,EAAOC,KAAOA,EAAED,CAAK,EAAGA,GAAQ,CACnE,OAAQ,CAAA,EACR,GAAGD,CAAA,CACJ,CACH,CAAC,GAEHH,EAAO,OAAOC,CAAQ,EAAID,EAAO,OAAOC,CAAQ,GAAK,CAAA,EACrDD,EAAO,OAAOC,CAAQ,EAAE,KAAKZ,CAAQ,EAC9B,IAAM,CACX,IAAIiB,EAAmBN,EAAO,OAAOC,CAAQ,EACzCX,EAAQgB,EAAiB,QAAQjB,CAAQ,EAC7CiB,EAAiB,OAAOhB,EAAO,CAAC,EAC3BgB,EAAiB,SACpB,OAAON,EAAO,OAAOC,CAAQ,EAC7BD,EAAO,OAAOC,EAAWH,CAAe,EAAA,EACxC,OAAOE,EAAO,OAAOC,EAAWH,CAAe,EAEnD,GAkFSS,EAAsB,IAEtBC,EAAU,CAACC,EAAQC,IAKrBX,EAAGU,EAJKE,GAAW,CACxB,IAAIC,EAAUF,EAAWC,CAAO,EAC5BC,GAASH,EAAO,OAAOZ,CAAO,EAAE,KAAKe,CAAO,CAClD,EAC4BhB,EAAOiB,GAAgB,CACjD,IAAIC,EAAeL,EAAO,OAC1BA,EAAO,OAAS,IAAIM,KACd,CAACN,EAAO,IAAM,CAACA,EAAO,SACxBA,EAAO,OAAS,GAChBI,EAAA,GAEKC,EAAa,GAAGC,CAAI,GAG7B,IAAIC,EAAYP,EAAO,IACvB,OAAAA,EAAO,OAAOZ,CAAO,EAAI,CAAA,EACzBY,EAAO,IAAM,IAAM,CACjBO,EAAA,EACA,WAAW,IAAM,CACf,GAAIP,EAAO,QAAU,CAACA,EAAO,GAAI,CAC/BA,EAAO,OAAS,GAChB,QAASG,KAAWH,EAAO,OAAOZ,CAAO,EAAGe,EAAA,EAC5CH,EAAO,OAAOZ,CAAO,EAAI,CAAA,CAC3B,CACF,EAAGU,CAAmB,CACxB,EAYO,IAAM,CACXE,EAAO,OAASK,EAChBL,EAAO,IAAMO,CACf,CACF,CAAC,EC3JCC,EAAgB,CAACC,EAAQC,EAAIC,IAAY,CACtC,MAAM,QAAQF,CAAM,IAAGA,EAAS,CAACA,CAAM,GAE5C,IAAIG,EACAC,EACAC,EAAM,IAAM,CACd,GAAID,IAAiBtC,EAAO,OAC5BsC,EAAetC,EACf,IAAI+B,EAAOG,EAAO,IAAIT,GAAUA,EAAO,IAAG,CAAE,EAC5C,GAAI,CAACY,GAAgBN,EAAK,KAAK,CAACS,EAAKC,IAAMD,IAAQH,EAAaI,CAAC,CAAC,EAAG,CACnEJ,EAAeN,EACf,IAAIW,EAAQP,EAAG,GAAGJ,CAAI,EAClBW,GAASA,EAAM,MAAQA,EAAM,EAC/BA,EAAM,KAAKC,GAAc,CACnBN,IAAiBN,GAEnBa,EAAU,IAAID,CAAU,CAE5B,CAAC,GAEDC,EAAU,IAAIF,CAAK,EACnBJ,EAAetC,EAEnB,CACF,EACI4C,EAAY3C,EAAK,MAAS,EAC1B4C,EAAMD,EAAU,IACpBA,EAAU,IAAM,KACdL,EAAG,EACIM,EAAG,GAIZ,IAAIC,EAKAP,EAEJ,OAAAf,EAAQoB,EAAW,IAAM,CACvB,IAAIG,EAAUb,EAAO,IAAIT,GAAUA,EAAO,OAAOqB,CAAG,CAAC,EACrD,OAAAP,EAAG,EACI,IAAM,CACX,QAAS5B,KAAUoC,EAASpC,EAAM,CACpC,CACF,CAAC,EAEMiC,CACT,EAGO,MAAMI,EAAW,CAACd,EAAQe,IAAOhB,EAAcC,EAAQe,CAAE,ECnDnDC,EAAsBjD,EAA2B,EAAE,EAGnDkD,EAAclD,EAAyB,CAAA,CAAE,EAGzCmD,EAAkBnD,EAAe,CAAA,CAAE,EAGnCoD,EAAwBpD,EAAa,EAAE,EAGvCqD,EAAWrD,EAAsB,MAAM,EAGvCsD,EAActD,EAAa,EAAE,EAM7BuD,EAAeR,EAASE,EAAsBO,GAChDA,EAAY,QAASC,GAAeA,EAAW,SAAS,CAClE,EAOM,SAASC,EAAuBF,EAAmC,CACtEP,EAAoB,IAAIO,CAAW,CACvC,CAEO,SAASG,EAAaC,EAAgB,CACzBT,EAAgB,IAAA,EACpB,SAASS,CAAM,EACvBT,EAAgB,IAAI,EAAE,EAEtBA,EAAgB,IAAI,CAACS,CAAM,CAAC,CAEpC,CAEO,SAASC,GAAmB,CAC/B,GAAI,OAAO,OAAW,IAAa,CAE/B,MAAMD,EADS,IAAI,gBAAgB,OAAO,SAAS,MAAM,EACnC,IAAI,QAAQ,EAC9BA,GACAT,EAAgB,IAAI,CAACS,CAAM,CAAC,CAEpC,CACJ,CAEO,SAASE,GAAmB,CAC/B,GAAI,OAAO,OAAW,IAAa,CAE/B,MAAMC,EADS,IAAI,gBAAgB,OAAO,SAAS,MAAM,EACxC,IAAI,GAAG,EACpBA,GACAT,EAAY,IAAIS,CAAC,CAEzB,CACJ,CAEO,SAASC,EAAgBC,EAAe,CAC3C,GAAI,OAAO,OAAW,IAAa,CAC/B,MAAMC,EAAS,IAAI,gBAAgB,OAAO,SAAS,MAAM,EACrDD,EAAM,OACNC,EAAO,IAAI,IAAKD,EAAM,KAAA,CAAM,EAE5BC,EAAO,OAAO,GAAG,EAErB,MAAMC,EAASD,EAAO,SAAA,EAAa,IAAIA,EAAO,UAAU,GAAK,OAAO,SAAS,SAC7E,OAAO,QAAQ,aAAa,CAAA,EAAI,GAAIC,CAAM,CAC9C,CACJ,CAEO,SAASC,EAAiBX,EAA4B,CACzD,OAAOA,EACF,cACA,QAAQ,OAAQ,GAAG,EACnB,QAAQ,cAAe,EAAE,CAClC","x_google_ignoreList":[0,1,2]}